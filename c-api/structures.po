# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-29 14:35+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid "Common Object Structures"
msgstr "Estruturas Comuns de Objetos"

msgid ""
"There are a large number of structures which are used in the definition of "
"object types for Python.  This section describes these structures and how "
"they are used."
msgstr ""
"Existe um grande número de estruturas utilizadas na definição de tipos de "
"objetos em Python. Esta secção descreve essas estruturas e como são "
"utilizadas."

msgid "Base object types and macros"
msgstr "Tipos base de objetos e macros"

msgid ""
"All Python objects ultimately share a small number of fields at the "
"beginning of the object's representation in memory.  These are represented "
"by the :c:type:`PyObject` and :c:type:`PyVarObject` types, which are "
"defined, in turn, by the expansions of some macros also used, whether "
"directly or indirectly, in the definition of all other Python objects.  "
"Additional macros can be found under :ref:`reference counting "
"<countingrefs>`."
msgstr ""
"Todos os objetos Python partilham, em última instância, um pequeno número de "
"campos no início da representação do objeto na memória. Estes são "
"representados pelos tipos :c:type:`PyObject` e :c:type:`PyVarObject`, que "
"são definidos, por sua vez, pelas expansões de algumas macros também "
"utilizadas, direta ou indiretamente, na definição de todos os outros objetos "
"Python. Macros adicionais podem ser encontradas em :ref:`contagem de "
"referências <countingrefs>`."

msgid ""
"All object types are extensions of this type.  This is a type which contains "
"the information Python needs to treat a pointer to an object as an object.  "
"In a normal \"release\" build, it contains only the object's reference count "
"and a pointer to the corresponding type object. Nothing is actually declared "
"to be a :c:type:`PyObject`, but every pointer to a Python object can be cast "
"to a :c:expr:`PyObject*`."
msgstr ""
"Todos os tipos de objetos são extensões deste tipo. Este é um tipo que "
"contém a informação que o Python necessita para tratar um ponteiro para um "
"objeto como um objeto. Numa compilação \"release\" normal, contém apenas a "
"contagem de referências do objeto e um ponteiro para o objeto de tipo "
"correspondente. Nada é declarado explicitamente como :c:type:`PyObject`, mas "
"qualquer ponteiro para um objeto Python pode ser convertido para :c:expr:"
"`PyObject*`."

msgid ""
"The members must not be accessed directly; instead use macros such as :c:"
"macro:`Py_REFCNT` and :c:macro:`Py_TYPE`."
msgstr ""
"Os membros não devem ser acedidos diretamente; em vez disso, utilize macros "
"como :c:macro:`Py_REFCNT` e :c:macro:`Py_TYPE`."

msgid ""
"The object's reference count, as returned by :c:macro:`Py_REFCNT`. Do not "
"use this field directly; instead use functions and macros such as :c:macro:`!"
"Py_REFCNT`, :c:func:`Py_INCREF` and :c:func:`Py_DecRef`."
msgstr ""
"A contagem de referências do objeto, conforme retornado por :c:macro:"
"`Py_REFCNT`. Não utilize este campo diretamente; em vez disso, utilize "
"funções e macros como :c:macro:`!Py_REFCNT`, :c:func:`Py_INCREF` e :c:func:"
"`Py_DecRef`."

msgid ""
"The field type may be different from ``Py_ssize_t``, depending on build "
"configuration and platform."
msgstr ""
"O tipo do campo pode ser diferente de ``Py_ssize_t``, dependendo da "
"configuração da compilação e da plataforma."

msgid ""
"The object's type. Do not use this field directly; use :c:macro:`Py_TYPE` "
"and :c:func:`Py_SET_TYPE` instead."
msgstr ""
"O tipo do objeto. Não utilize este campo diretamente; utilize :c:macro:"
"`Py_TYPE` e :c:func:`Py_SET_TYPE` em vez disso."

msgid ""
"An extension of :c:type:`PyObject` that adds the :c:member:`~PyVarObject."
"ob_size` field. This is intended for objects that have some notion of "
"*length*."
msgstr ""
"Uma extensão de :c:type:`PyObject` que adiciona o campo :c:member:"
"`~PyVarObject.ob_size`. Isto destina-se a objetos que têm uma noção de "
"*comprimento*."

msgid ""
"As with :c:type:`!PyObject`, the members must not be accessed directly; "
"instead use macros such as :c:macro:`Py_SIZE`, :c:macro:`Py_REFCNT` and :c:"
"macro:`Py_TYPE`."
msgstr ""
"Tal como com :c:type:`!PyObject`, os membros não devem ser acedidos "
"diretamente; em vez disso, utilize macros como :c:macro:`Py_SIZE`, :c:macro:"
"`Py_REFCNT` e :c:macro:`Py_TYPE`."

msgid ""
"A size field, whose contents should be considered an object's internal "
"implementation detail."
msgstr ""
"Um campo de tamanho, cujo conteúdo deve ser considerado um detalhe interno "
"da implementação do objeto."

msgid "Do not use this field directly; use :c:macro:`Py_SIZE` instead."
msgstr ""
"Não utilize este campo diretamente; utilize :c:macro:`Py_SIZE` em vez disso."

msgid ""
"Object creation functions such as :c:func:`PyObject_NewVar` will generally "
"set this field to the requested size (number of items). After creation, "
"arbitrary values can be stored in :c:member:`!ob_size` using :c:macro:"
"`Py_SET_SIZE`."
msgstr ""
"Funções de criação de objetos, como :c:func:`PyObject_NewVar`, geralmente "
"definem este campo para o tamanho solicitado (número de itens). Após a "
"criação, valores arbitrários podem ser armazenados em :c:member:`!ob_size` "
"utilizando :c:macro:`Py_SET_SIZE`."

msgid ""
"To get an object's publicly exposed length, as returned by the Python "
"function :py:func:`len`, use :c:func:`PyObject_Length` instead."
msgstr ""
"Para obter o comprimento publicamente exposto de um objeto, conforme "
"retornado pela função Python :py:func:`len`, utilize :c:func:"
"`PyObject_Length` em vez disso."

msgid ""
"This is a macro used when declaring new types which represent objects "
"without a varying length.  The PyObject_HEAD macro expands to::"
msgstr ""
"Esta é uma macro utilizada ao declarar novos tipos que representam objetos "
"sem comprimento variável. A macro PyObject_HEAD expande-se para::"

msgid "PyObject ob_base;"
msgstr "PyObject ob_base;"

msgid "See documentation of :c:type:`PyObject` above."
msgstr "Consulte a documentação de :c:type:`PyObject` acima."

msgid ""
"This is a macro used when declaring new types which represent objects with a "
"length that varies from instance to instance. The PyObject_VAR_HEAD macro "
"expands to::"
msgstr ""
"Esta é uma macro utilizada ao declarar novos tipos que representam objetos "
"com um comprimento que varia de instância para instância. A macro "
"PyObject_VAR_HEAD expande-se para::"

msgid "PyVarObject ob_base;"
msgstr "PyVarObject ob_base;"

msgid "See documentation of :c:type:`PyVarObject` above."
msgstr "Consulte a documentação de :c:type:`PyVarObject` acima."

msgid ""
"The base class of all other objects, the same as :class:`object` in Python."
msgstr ""
"A classe base de todos os outros objetos, a mesma que :class:`object` em "
"Python."

msgid ""
"Test if the *x* object is the *y* object, the same as ``x is y`` in Python."
msgstr ""
"Testa se o objeto *x* é o objeto *y*, o mesmo que ``x is y`` em Python."

msgid ""
"Test if an object is the ``None`` singleton, the same as ``x is None`` in "
"Python."
msgstr ""
"Testa se um objeto é o singleton ``None``, o mesmo que ``x is None`` em "
"Python."

msgid ""
"Test if an object is the ``True`` singleton, the same as ``x is True`` in "
"Python."
msgstr ""
"Testa se um objeto é o singleton ``True``, o mesmo que ``x is True`` em "
"Python."

msgid ""
"Test if an object is the ``False`` singleton, the same as ``x is False`` in "
"Python."
msgstr ""
"Testa se um objeto é o singleton ``False``, o mesmo que ``x is False`` em "
"Python."

msgid "Get the type of the Python object *o*."
msgstr "Obtém o tipo do objeto Python *o*."

msgid ""
"The returned reference is :term:`borrowed <borrowed reference>` from *o*. Do "
"not release it with :c:func:`Py_DECREF` or similar."
msgstr ""
"A referência retornada é :term:`emprestada <borrowed reference>` de *o*. Não "
"a libere com :c:func:`Py_DECREF` ou similar."

msgid ""
":c:func:`Py_TYPE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyObject*`."
msgstr ""
":c:func:`Py_TYPE()` foi alterada para uma função estática em linha. O "
"parâmetro type já não é :c:expr:`const PyObject*`."

msgid ""
"Return non-zero if the object *o* type is *type*. Return zero otherwise. "
"Equivalent to: ``Py_TYPE(o) == type``."
msgstr ""
"Retorna um valor não-zero se o tipo do objeto *o* for *type*. Retorna zero "
"caso contrário. Equivalente a: ``Py_TYPE(o) == type``."

msgid ""
"Set the type of object *o* to *type*, without any checking or reference "
"counting."
msgstr ""
"Define o tipo do objeto *o* para *type*, sem qualquer verificação ou "
"contagem de referências."

msgid ""
"This is a very low-level operation. Consider instead setting the Python "
"attribute :attr:`~object.__class__` using :c:func:`PyObject_SetAttrString` "
"or similar."
msgstr ""
"Esta é uma operação de muito baixo nível. Considere, em vez disso, definir o "
"atributo Python :attr:`~object.__class__` utilizando :c:func:"
"`PyObject_SetAttrString` ou similar."

msgid ""
"Note that assigning an incompatible type can lead to undefined behavior."
msgstr ""
"Note que atribuir um tipo incompatível pode levar a comportamento indefinido."

msgid ""
"If *type* is a :ref:`heap type <heap-types>`, the caller must create a new "
"reference to it. Similarly, if the old type of *o* is a heap type, the "
"caller must release a reference to that type."
msgstr ""
"Se *type* for um :ref:`tipo heap <heap-types>`, o chamador deve criar uma "
"nova referência para ele. Da mesma forma, se o tipo antigo de *o* for um "
"tipo heap, o chamador deve libertar uma referência para esse tipo."

msgid "Get the :c:member:`~PyVarObject.ob_size` field of *o*."
msgstr "Obtém o campo :c:member:`~PyVarObject.ob_size` de *o*."

msgid ""
":c:func:`Py_SIZE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyVarObject*`."
msgstr ""
":c:func:`Py_SIZE()` foi alterada para uma função estática em linha. O "
"parâmetro type já não é :c:expr:`const PyVarObject*`."

msgid "Set the :c:member:`~PyVarObject.ob_size` field of *o* to *size*."
msgstr "Define o campo :c:member:`~PyVarObject.ob_size` de *o* para *size*."

msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyObject` type.  This macro expands to::"
msgstr ""
"Esta é uma macro que se expande para valores de inicialização para um novo "
"tipo :c:type:`PyObject`. Esta macro expande-se para::"

msgid ""
"_PyObject_EXTRA_INIT\n"
"1, type,"
msgstr ""
"_PyObject_EXTRA_INIT\n"
"1, type,"

msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyVarObject` type, including the :c:member:`~PyVarObject.ob_size` field. "
"This macro expands to::"
msgstr ""
"Esta é uma macro que se expande para valores de inicialização para um novo "
"tipo :c:type:`PyVarObject`, incluindo o campo :c:member:`~PyVarObject."
"ob_size`. Esta macro expande-se para::"

msgid ""
"_PyObject_EXTRA_INIT\n"
"1, type, size,"
msgstr ""
"_PyObject_EXTRA_INIT\n"
"1, type, size,"

msgid "Implementing functions and methods"
msgstr "Implementação de funções e métodos"

msgid ""
"Type of the functions used to implement most Python callables in C. "
"Functions of this type take two :c:expr:`PyObject*` parameters and return "
"one such value.  If the return value is ``NULL``, an exception shall have "
"been set.  If not ``NULL``, the return value is interpreted as the return "
"value of the function as exposed in Python.  The function must return a new "
"reference."
msgstr ""
"Tipo das funções utilizadas para implementar a maioria dos objetos chamáveis "
"em Python em C. Funções deste tipo recebem dois parâmetros :c:expr:"
"`PyObject*` e retornam um valor desse tipo. Se o valor de retorno for "
"``NULL``, uma exceção deve ter sido definida. Se não for ``NULL``, o valor "
"de retorno é interpretado como o valor de retorno da função conforme exposto "
"em Python. A função deve retornar uma nova referência."

msgid "The function signature is::"
msgstr "A assinatura da função é::"

msgid ""
"PyObject *PyCFunction(PyObject *self,\n"
"                      PyObject *args);"
msgstr ""
"PyObject *PyCFunction(PyObject *self,\n"
"                      PyObject *args);"

msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`. "
"The function signature is::"
msgstr ""
"Tipo das funções utilizadas para implementar objetos chamáveis em Python em "
"C com a assinatura :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-"
"METH_KEYWORDS>`. A assinatura da função é::"

msgid ""
"PyObject *PyCFunctionWithKeywords(PyObject *self,\n"
"                                  PyObject *args,\n"
"                                  PyObject *kwargs);"
msgstr ""
"PyObject *PyCFunctionWithKeywords(PyObject *self,\n"
"                                  PyObject *args,\n"
"                                  PyObject *kwargs);"

msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :c:macro:`METH_FASTCALL`. The function signature is::"
msgstr ""
"Tipo das funções utilizadas para implementar objetos chamáveis em Python em "
"C com a assinatura :c:macro:`METH_FASTCALL`. A assinatura da função é::"

msgid ""
"PyObject *PyCFunctionFast(PyObject *self,\n"
"                          PyObject *const *args,\n"
"                          Py_ssize_t nargs);"
msgstr ""
"PyObject *PyCFunctionFast(PyObject *self,\n"
"                          PyObject *const *args,\n"
"                          Py_ssize_t nargs);"

msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>`. The function signature is::"
msgstr ""
"Tipo das funções utilizadas para implementar objetos chamáveis em Python em "
"C com a assinatura :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>`. A assinatura da função é::"

msgid ""
"PyObject *PyCFunctionFastWithKeywords(PyObject *self,\n"
"                                      PyObject *const *args,\n"
"                                      Py_ssize_t nargs,\n"
"                                      PyObject *kwnames);"
msgstr ""
"PyObject *PyCFunctionFastWithKeywords(PyObject *self,\n"
"                                      PyObject *const *args,\n"
"                                      Py_ssize_t nargs,\n"
"                                      PyObject *kwnames);"

msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-"
"METH_FASTCALL-METH_KEYWORDS>`. The function signature is::"
msgstr ""
"Tipo das funções utilizadas para implementar objetos chamáveis em Python em "
"C com a assinatura :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS "
"<METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`. A assinatura da função é::"

msgid ""
"PyObject *PyCMethod(PyObject *self,\n"
"                    PyTypeObject *defining_class,\n"
"                    PyObject *const *args,\n"
"                    Py_ssize_t nargs,\n"
"                    PyObject *kwnames)"
msgstr ""
"PyObject *PyCMethod(PyObject *self,\n"
"                    PyTypeObject *defining_class,\n"
"                    PyObject *const *args,\n"
"                    Py_ssize_t nargs,\n"
"                    PyObject *kwnames)"

msgid ""
"Structure used to describe a method of an extension type.  This structure "
"has four fields:"
msgstr ""
"Estrutura utilizada para descrever um método de um tipo de extensão. Esta "
"estrutura tem quatro campos:"

msgid "Name of the method."
msgstr "Nome do método."

msgid "Pointer to the C implementation."
msgstr "Ponteiro para a implementação em C."

msgid "Flags bits indicating how the call should be constructed."
msgstr "Bits de flags que indicam como a chamada deve ser construída."

msgid "Points to the contents of the docstring."
msgstr "Aponta para o conteúdo da docstring."

msgid ""
"The :c:member:`~PyMethodDef.ml_meth` is a C function pointer. The functions "
"may be of different types, but they always return :c:expr:`PyObject*`.  If "
"the function is not of the :c:type:`PyCFunction`, the compiler will require "
"a cast in the method table. Even though :c:type:`PyCFunction` defines the "
"first parameter as :c:expr:`PyObject*`, it is common that the method "
"implementation uses the specific C type of the *self* object."
msgstr ""
"O :c:member:`~PyMethodDef.ml_meth` é um ponteiro para uma função em C. As "
"funções podem ser de tipos diferentes, mas sempre retornam :c:expr:"
"`PyObject*`. Se a função não for do tipo :c:type:`PyCFunction`, o compilador "
"exigirá um cast na tabela de métodos. Embora :c:type:`PyCFunction` defina o "
"primeiro parâmetro como :c:expr:`PyObject*`, é comum que a implementação do "
"método utilize o tipo C específico do objeto *self*."

msgid ""
"The :c:member:`~PyMethodDef.ml_flags` field is a bitfield which can include "
"the following flags. The individual flags indicate either a calling "
"convention or a binding convention."
msgstr ""
"O campo :c:member:`~PyMethodDef.ml_flags` é um campo de bits que pode "
"incluir as seguintes flags. As flags individuais indicam uma convenção de "
"chamada ou uma convenção de ligação."

msgid "There are these calling conventions:"
msgstr "Existem as seguintes convenções de chamada:"

msgid ""
"This is the typical calling convention, where the methods have the type :c:"
"type:`PyCFunction`. The function expects two :c:expr:`PyObject*` values. The "
"first one is the *self* object for methods; for module functions, it is the "
"module object.  The second parameter (often called *args*) is a tuple object "
"representing all arguments. This parameter is typically processed using :c:"
"func:`PyArg_ParseTuple` or :c:func:`PyArg_UnpackTuple`."
msgstr ""
"Esta é a convenção de chamada típica, onde os métodos têm o tipo :c:type:"
"`PyCFunction`. A função espera dois valores :c:expr:`PyObject*`. O primeiro "
"é o objeto *self* para métodos; para funções de módulo, é o objeto módulo. O "
"segundo parâmetro (geralmente chamado *args*) é um objeto tuplo que "
"representa todos os argumentos. Este parâmetro é tipicamente processado "
"utilizando :c:func:`PyArg_ParseTuple` ou :c:func:`PyArg_UnpackTuple`."

msgid ""
"Can only be used in certain combinations with other flags: :ref:"
"`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`, :ref:"
"`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>` and :ref:"
"`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>`."
msgstr ""
"Pode ser utilizada apenas em certas combinações com outras flags: :ref:"
"`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`, :ref:"
"`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>` e :ref:"
"`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>`."

msgid ":c:expr:`METH_VARARGS | METH_KEYWORDS`"
msgstr ":c:expr:`METH_VARARGS | METH_KEYWORDS`"

msgid ""
"Methods with these flags must be of type :c:type:`PyCFunctionWithKeywords`. "
"The function expects three parameters: *self*, *args*, *kwargs* where "
"*kwargs* is a dictionary of all the keyword arguments or possibly ``NULL`` "
"if there are no keyword arguments.  The parameters are typically processed "
"using :c:func:`PyArg_ParseTupleAndKeywords`."
msgstr ""
"Métodos com estas flags devem ser do tipo :c:type:`PyCFunctionWithKeywords`. "
"A função espera três parâmetros: *self*, *args*, *kwargs*, onde *kwargs* é "
"um dicionário de todos os argumentos nomeados ou possivelmente ``NULL`` se "
"não houver argumentos nomeados. Os parâmetros são tipicamente processados "
"utilizando :c:func:`PyArg_ParseTupleAndKeywords`."

msgid ""
"Fast calling convention supporting only positional arguments. The methods "
"have the type :c:type:`PyCFunctionFast`. The first parameter is *self*, the "
"second parameter is a C array of :c:expr:`PyObject*` values indicating the "
"arguments and the third parameter is the number of arguments (the length of "
"the array)."
msgstr ""
"Convenção de chamada rápida que suporta apenas argumentos posicionais. Os "
"métodos têm o tipo :c:type:`PyCFunctionFast`. O primeiro parâmetro é *self*, "
"o segundo parâmetro é um array C de valores :c:expr:`PyObject*` que indicam "
"os argumentos e o terceiro parâmetro é o número de argumentos (o comprimento "
"do array)."

msgid "``METH_FASTCALL`` is now part of the :ref:`stable ABI <stable-abi>`."
msgstr "``METH_FASTCALL`` faz agora parte da :ref:`ABI estável <stable-abi>`."

msgid ":c:expr:`METH_FASTCALL | METH_KEYWORDS`"
msgstr ":c:expr:`METH_FASTCALL | METH_KEYWORDS`"

msgid ""
"Extension of :c:macro:`METH_FASTCALL` supporting also keyword arguments, "
"with methods of type :c:type:`PyCFunctionFastWithKeywords`. Keyword "
"arguments are passed the same way as in the :ref:`vectorcall protocol "
"<vectorcall>`: there is an additional fourth :c:expr:`PyObject*` parameter "
"which is a tuple representing the names of the keyword arguments (which are "
"guaranteed to be strings) or possibly ``NULL`` if there are no keywords.  "
"The values of the keyword arguments are stored in the *args* array, after "
"the positional arguments."
msgstr ""
"Extensão de :c:macro:`METH_FASTCALL` que suporta também argumentos nomeados, "
"com métodos do tipo :c:type:`PyCFunctionFastWithKeywords`. Os argumentos "
"nomeados são passados da mesma forma que no protocolo :ref:`vectorcall "
"<vectorcall>`: existe um quarto parâmetro adicional :c:expr:`PyObject*` que "
"é um tuplo representando os nomes dos argumentos nomeados (que são "
"garantidamente strings) ou possivelmente ``NULL`` se não houver argumentos "
"nomeados. Os valores dos argumentos nomeados são armazenados no array "
"*args*, após os argumentos posicionais."

msgid ""
"Can only be used in the combination with other flags: :ref:`METH_METHOD | "
"METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`."
msgstr ""
"Pode ser utilizada apenas em combinação com outras flags: :ref:`METH_METHOD "
"| METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`."

msgid ":c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`"
msgstr ":c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`"

msgid ""
"Extension of :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` supporting the *defining class*, that is, the class that "
"contains the method in question. The defining class might be a superclass of "
"``Py_TYPE(self)``."
msgstr ""
"Extensão de :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` que suporta a *classe de definição*, ou seja, a classe que "
"contém o método em questão. A classe de definição pode ser uma superclasse "
"de ``Py_TYPE(self)``."

msgid ""
"The method needs to be of type :c:type:`PyCMethod`, the same as for "
"``METH_FASTCALL | METH_KEYWORDS`` with ``defining_class`` argument added "
"after ``self``."
msgstr ""
"O método precisa de ser do tipo :c:type:`PyCMethod`, o mesmo que para "
"``METH_FASTCALL | METH_KEYWORDS`` com o argumento ``defining_class`` "
"adicionado após ``self``."

msgid ""
"Methods without parameters don't need to check whether arguments are given "
"if they are listed with the :c:macro:`METH_NOARGS` flag.  They need to be of "
"type :c:type:`PyCFunction`.  The first parameter is typically named *self* "
"and will hold a reference to the module or object instance.  In all cases "
"the second parameter will be ``NULL``."
msgstr ""
"Métodos sem parâmetros não precisam de verificar se são fornecidos "
"argumentos se forem listados com a flag :c:macro:`METH_NOARGS`. Devem ser do "
"tipo :c:type:`PyCFunction`. O primeiro parâmetro é tipicamente chamado "
"*self* e conterá uma referência ao módulo ou instância do objeto. Em todos "
"os casos, o segundo parâmetro será ``NULL``."

msgid ""
"The function must have 2 parameters. Since the second parameter is unused, :"
"c:macro:`Py_UNUSED` can be used to prevent a compiler warning."
msgstr ""
"A função deve ter 2 parâmetros. Como o segundo parâmetro não é utilizado, "
"pode ser usada a macro :c:macro:`Py_UNUSED` para evitar um aviso do "
"compilador."

msgid ""
"Methods with a single object argument can be listed with the :c:macro:"
"`METH_O` flag, instead of invoking :c:func:`PyArg_ParseTuple` with a "
"``\"O\"`` argument. They have the type :c:type:`PyCFunction`, with the "
"*self* parameter, and a :c:expr:`PyObject*` parameter representing the "
"single argument."
msgstr ""
"Métodos com um único argumento de objeto podem ser listados com a flag :c:"
"macro:`METH_O`, em vez de invocar :c:func:`PyArg_ParseTuple` com um "
"argumento ``\"O\"``. Têm o tipo :c:type:`PyCFunction`, com o parâmetro "
"*self* e um parâmetro :c:expr:`PyObject*` que representa o argumento único."

msgid ""
"These two constants are not used to indicate the calling convention but the "
"binding when use with methods of classes.  These may not be used for "
"functions defined for modules.  At most one of these flags may be set for "
"any given method."
msgstr ""
"Estas duas constantes não são utilizadas para indicar a convenção de "
"chamada, mas sim a ligação quando usadas com métodos de classes. Não podem "
"ser utilizadas para funções definidas para módulos. No máximo, uma destas "
"flags pode ser definida para qualquer método dado."

msgid ""
"The method will be passed the type object as the first parameter rather than "
"an instance of the type.  This is used to create *class methods*, similar to "
"what is created when using the :func:`classmethod` built-in function."
msgstr ""
"O método receberá o objeto de tipo como primeiro parâmetro em vez de uma "
"instância do tipo. Isto é utilizado para criar *métodos de classe*, "
"semelhante ao que é criado ao utilizar a função incorporada :func:"
"`classmethod`."

msgid ""
"The method will be passed ``NULL`` as the first parameter rather than an "
"instance of the type.  This is used to create *static methods*, similar to "
"what is created when using the :func:`staticmethod` built-in function."
msgstr ""
"O método receberá ``NULL`` como primeiro parâmetro em vez de uma instância "
"do tipo. Isto é utilizado para criar *métodos estáticos*, semelhante ao que "
"é criado ao utilizar a função incorporada :func:`staticmethod`."

msgid ""
"One other constant controls whether a method is loaded in place of another "
"definition with the same method name."
msgstr ""
"Outra constante controla se um método é carregado no lugar de outra "
"definição com o mesmo nome de método."

msgid ""
"The method will be loaded in place of existing definitions.  Without "
"*METH_COEXIST*, the default is to skip repeated definitions.  Since slot "
"wrappers are loaded before the method table, the existence of a "
"*sq_contains* slot, for example, would generate a wrapped method named :meth:"
"`~object.__contains__` and preclude the loading of a corresponding "
"PyCFunction with the same name.  With the flag defined, the PyCFunction will "
"be loaded in place of the wrapper object and will co-exist with the slot.  "
"This is helpful because calls to PyCFunctions are optimized more than "
"wrapper object calls."
msgstr ""
"O método será carregado no lugar de definições existentes. Sem "
"*METH_COEXIST*, o comportamento predefinido é ignorar definições repetidas. "
"Como os wrappers de slots são carregados antes da tabela de métodos, a "
"existência de um slot *sq_contains*, por exemplo, geraria um método "
"encapsulado chamado :meth:`~object.__contains__` e impediria o carregamento "
"de uma PyCFunction correspondente com o mesmo nome. Com a flag definida, a "
"PyCFunction será carregada no lugar do objeto wrapper e coexistirá com o "
"slot. Isto é útil porque as chamadas para PyCFunctions são mais otimizadas "
"do que as chamadas para objetos wrapper."

msgid ""
"The type object corresponding to Python C method objects. This is available "
"as :class:`types.BuiltinMethodType` in the Python layer."
msgstr ""
"O objeto de tipo correspondente a objetos de métodos C em Python. Isto está "
"disponível como :class:`types.BuiltinMethodType` na camada Python."

msgid ""
"Return true if *op* is an instance of the :c:type:`PyCMethod_Type` type or a "
"subtype of it. This function always succeeds."
msgstr ""
"Retorna verdadeiro se *op* for uma instância do tipo :c:type:"
"`PyCMethod_Type` ou de um subtipo deste. Esta função sempre tem sucesso."

msgid ""
"This is the same as :c:func:`PyCMethod_Check`, but does not account for "
"subtypes."
msgstr ""
"Isto é o mesmo que :c:func:`PyCMethod_Check`, mas não considera subtipos."

msgid ""
"Turn *ml* into a Python :term:`callable` object. The caller must ensure that "
"*ml* outlives the :term:`callable`. Typically, *ml* is defined as a static "
"variable."
msgstr ""
"Converte *ml* num objeto Python :term:`chamável`. O chamador deve garantir "
"que *ml* sobrevive ao objeto :term:`chamável`. Tipicamente, *ml* é definido "
"como uma variável estática."

msgid ""
"The *self* parameter will be passed as the *self* argument to the C function "
"in ``ml->ml_meth`` when invoked. *self* can be ``NULL``."
msgstr ""
"O parâmetro *self* será passado como argumento *self* para a função C em "
"``ml->ml_meth`` quando invocada. *self* pode ser ``NULL``."

msgid ""
"The :term:`callable` object's ``__module__`` attribute can be set from the "
"given *module* argument. *module* should be a Python string, which will be "
"used as name of the module the function is defined in. If unavailable, it "
"can be set to :const:`None` or ``NULL``."
msgstr ""
"O atributo ``__module__`` do objeto :term:`chamável` pode ser definido a "
"partir do argumento *module*. *module* deve ser uma string Python, que será "
"utilizada como nome do módulo onde a função está definida. Se não estiver "
"disponível, pode ser definido como :const:`None` ou ``NULL``."

msgid ":attr:`function.__module__`"
msgstr ":attr:`function.__module__`"

msgid ""
"The *cls* parameter will be passed as the *defining_class* argument to the C "
"function. Must be set if :c:macro:`METH_METHOD` is set on ``ml->ml_flags``."
msgstr ""
"O parâmetro *cls* será passado como argumento *defining_class* para a função "
"C. Deve ser definido se :c:macro:`METH_METHOD` estiver definido em ``ml-"
">ml_flags``."

msgid ""
"The type object corresponding to Python C function objects. This is "
"available as :class:`types.BuiltinFunctionType` in the Python layer."
msgstr ""
"O objeto de tipo correspondente a objetos de funções C em Python. Isto está "
"disponível como :class:`types.BuiltinFunctionType` na camada Python."

msgid ""
"Return true if *op* is an instance of the :c:type:`PyCFunction_Type` type or "
"a subtype of it. This function always succeeds."
msgstr ""
"Retorna verdadeiro se *op* for uma instância do tipo :c:type:"
"`PyCFunction_Type` ou de um subtipo deste. Esta função sempre tem sucesso."

msgid ""
"This is the same as :c:func:`PyCFunction_Check`, but does not account for "
"subtypes."
msgstr ""
"Isto é o mesmo que :c:func:`PyCFunction_Check`, mas não considera subtipos."

msgid "Equivalent to ``PyCMethod_New(ml, self, module, NULL)``."
msgstr "Equivalente a ``PyCMethod_New(ml, self, module, NULL)``."

msgid "Equivalent to ``PyCMethod_New(ml, self, NULL, NULL)``."
msgstr "Equivalente a ``PyCMethod_New(ml, self, NULL, NULL)``."

msgid ""
"Get the function's flags on *func* as they were passed to :c:member:"
"`~PyMethodDef.ml_flags`."
msgstr ""
"Obtém as flags da função em *func* conforme foram passadas para :c:member:"
"`~PyMethodDef.ml_flags`."

msgid ""
"If *func* is not a C function object, this fails with an exception. *func* "
"must not be ``NULL``."
msgstr ""
"Se *func* não for um objeto de função C, isto falha com uma exceção. *func* "
"não deve ser ``NULL``."

msgid ""
"This function returns the function's flags on success, and ``-1`` with an "
"exception set on failure."
msgstr ""
"Esta função retorna as flags da função em caso de sucesso, e ``-1`` com uma "
"exceção definida em caso de falha."

msgid ""
"This is the same as :c:func:`PyCFunction_GetFlags`, but without error or "
"type checking."
msgstr ""
"Isto é o mesmo que :c:func:`PyCFunction_GetFlags`, mas sem verificação de "
"erros ou de tipo."

msgid ""
"Get the function pointer on *func* as it was passed to :c:member:"
"`~PyMethodDef.ml_meth`."
msgstr ""
"Obtém o ponteiro da função em *func* conforme foi passado para :c:member:"
"`~PyMethodDef.ml_meth`."

msgid ""
"This function returns the function pointer on success, and ``NULL`` with an "
"exception set on failure."
msgstr ""
"Esta função retorna o ponteiro da função em caso de sucesso, e ``NULL`` com "
"uma exceção definida em caso de falha."

msgid ""
"This is the same as :c:func:`PyCFunction_GetFunction`, but without error or "
"type checking."
msgstr ""
"Isto é o mesmo que :c:func:`PyCFunction_GetFunction`, mas sem verificação de "
"erros ou de tipo."

msgid ""
"Get the \"self\" object on *func*. This is the object that would be passed "
"to the first argument of a :c:type:`PyCFunction`. For C function objects "
"created through a :c:type:`PyMethodDef` on a :c:type:`PyModuleDef`, this is "
"the resulting module object."
msgstr ""
"Obtém o objeto \"self\" em *func*. Este é o objeto que seria passado para o "
"primeiro argumento de uma :c:type:`PyCFunction`. Para objetos de função C "
"criados através de uma :c:type:`PyMethodDef` num :c:type:`PyModuleDef`, este "
"é o objeto módulo resultante."

msgid ""
"This function returns a :term:`borrowed reference` to the \"self\" object on "
"success, and ``NULL`` with an exception set on failure."
msgstr ""
"Esta função retorna uma :term:`referência emprestada` para o objeto \"self\" "
"em caso de sucesso, e ``NULL`` com uma exceção definida em caso de falha."

msgid ""
"This is the same as :c:func:`PyCFunction_GetSelf`, but without error or type "
"checking."
msgstr ""
"Isto é o mesmo que :c:func:`PyCFunction_GetSelf`, mas sem verificação de "
"erros ou de tipo."

msgid "Accessing attributes of extension types"
msgstr "Acesso a atributos de tipos de extensão"

msgid ""
"Structure which describes an attribute of a type which corresponds to a C "
"struct member. When defining a class, put a NULL-terminated array of these "
"structures in the :c:member:`~PyTypeObject.tp_members` slot."
msgstr ""
"Estrutura que descreve um atributo de um tipo que corresponde a um membro de "
"uma struct C. Ao definir uma classe, coloque um array terminado por NULL "
"destas estruturas no slot :c:member:`~PyTypeObject.tp_members`."

msgid "Its fields are, in order:"
msgstr "Os seus campos são, por ordem:"

msgid ""
"Name of the member. A NULL value marks the end of a ``PyMemberDef[]`` array."
msgstr ""
"Nome do membro. Um valor NULL marca o fim de um array ``PyMemberDef[]``."

msgid "The string should be static, no copy is made of it."
msgstr "A string deve ser estática, não é feita nenhuma cópia."

msgid ""
"The type of the member in the C struct. See :ref:`PyMemberDef-types` for the "
"possible values."
msgstr ""
"O tipo do membro na struct C. Consulte :ref:`PyMemberDef-types` para os "
"valores possíveis."

msgid ""
"The offset in bytes that the member is located on the type’s object struct."
msgstr ""
"O deslocamento em bytes onde o membro está localizado na struct do objeto do "
"tipo."

msgid ""
"Zero or more of the :ref:`PyMemberDef-flags`, combined using bitwise OR."
msgstr ""
"Zero ou mais das :ref:`PyMemberDef-flags`, combinadas utilizando OR bit a "
"bit."

msgid ""
"The docstring, or NULL. The string should be static, no copy is made of it. "
"Typically, it is defined using :c:macro:`PyDoc_STR`."
msgstr ""
"A docstring, ou NULL. A string deve ser estática, não é feita nenhuma cópia. "
"Tipicamente, é definida utilizando :c:macro:`PyDoc_STR`."

msgid ""
"By default (when :c:member:`~PyMemberDef.flags` is ``0``), members allow "
"both read and write access. Use the :c:macro:`Py_READONLY` flag for read-"
"only access. Certain types, like :c:macro:`Py_T_STRING`, imply :c:macro:"
"`Py_READONLY`. Only :c:macro:`Py_T_OBJECT_EX` (and legacy :c:macro:"
"`T_OBJECT`) members can be deleted."
msgstr ""
"Por predefinição (quando :c:member:`~PyMemberDef.flags` é ``0``), os membros "
"permitem acesso de leitura e escrita. Utilize a flag :c:macro:`Py_READONLY` "
"para acesso apenas de leitura. Certos tipos, como :c:macro:`Py_T_STRING`, "
"implicam :c:macro:`Py_READONLY`. Apenas membros :c:macro:`Py_T_OBJECT_EX` (e "
"legados :c:macro:`T_OBJECT`) podem ser eliminados."

msgid ""
"For heap-allocated types (created using :c:func:`PyType_FromSpec` or "
"similar), ``PyMemberDef`` may contain a definition for the special member "
"``\"__vectorcalloffset__\"``, corresponding to :c:member:`~PyTypeObject."
"tp_vectorcall_offset` in type objects. This member must be defined with "
"``Py_T_PYSSIZET``, and either ``Py_READONLY`` or ``Py_READONLY | "
"Py_RELATIVE_OFFSET``. For example::"
msgstr ""
"Para tipos alocados em heap (criados utilizando :c:func:`PyType_FromSpec` ou "
"similar), ``PyMemberDef`` pode conter uma definição para o membro especial "
"``\"__vectorcalloffset__\"``, correspondente a :c:member:`~PyTypeObject."
"tp_vectorcall_offset` em objetos de tipo. Este membro deve ser definido com "
"``Py_T_PYSSIZET``, e com ``Py_READONLY`` ou ``Py_READONLY | "
"Py_RELATIVE_OFFSET``. Por exemplo::"

msgid ""
"static PyMemberDef spam_type_members[] = {\n"
"    {\"__vectorcalloffset__\", Py_T_PYSSIZET,\n"
"     offsetof(Spam_object, vectorcall), Py_READONLY},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"static PyMemberDef spam_type_members[] = {\n"
"    {\"__vectorcalloffset__\", Py_T_PYSSIZET,\n"
"     offsetof(Spam_object, vectorcall), Py_READONLY},\n"
"    {NULL}  /* Sentinela */\n"
"};"

msgid "(You may need to ``#include <stddef.h>`` for :c:func:`!offsetof`.)"
msgstr ""
"(Pode ser necessário ``#include <stddef.h>`` para :c:func:`!offsetof`.)"

msgid ""
"The legacy offsets :c:member:`~PyTypeObject.tp_dictoffset` and :c:member:"
"`~PyTypeObject.tp_weaklistoffset` can be defined similarly using "
"``\"__dictoffset__\"`` and ``\"__weaklistoffset__\"`` members, but "
"extensions are strongly encouraged to use :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"and :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` instead."
msgstr ""
"Os deslocamentos legados :c:member:`~PyTypeObject.tp_dictoffset` e :c:member:"
"`~PyTypeObject.tp_weaklistoffset` podem ser definidos de forma semelhante "
"utilizando membros ``\"__dictoffset__\"`` e ``\"__weaklistoffset__\"``, mas "
"é fortemente recomendado que as extensões utilizem :c:macro:"
"`Py_TPFLAGS_MANAGED_DICT` e :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` em vez "
"disso."

msgid ""
"``PyMemberDef`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""
"``PyMemberDef`` está sempre disponível. Anteriormente, era necessário "
"incluir ``\"structmember.h\"``."

msgid ""
":c:macro:`Py_RELATIVE_OFFSET` is now allowed for "
"``\"__vectorcalloffset__\"``, ``\"__dictoffset__\"`` and "
"``\"__weaklistoffset__\"``."
msgstr ""
"A macro :c:macro:`Py_RELATIVE_OFFSET` é agora permitida para "
"``\"__vectorcalloffset__\"``, ``\"__dictoffset__\"`` e "
"``\"__weaklistoffset__\"``."

msgid ""
"Get an attribute belonging to the object at address *obj_addr*.  The "
"attribute is described by ``PyMemberDef`` *m*.  Returns ``NULL`` on error."
msgstr ""
"Obtém um atributo pertencente ao objeto no endereço *obj_addr*. O atributo é "
"descrito por ``PyMemberDef`` *m*. Retorna ``NULL`` em caso de erro."

msgid ""
"``PyMember_GetOne`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""
"``PyMember_GetOne`` está sempre disponível. Anteriormente, era necessário "
"incluir ``\"structmember.h\"``."

msgid ""
"Set an attribute belonging to the object at address *obj_addr* to object "
"*o*. The attribute to set is described by ``PyMemberDef`` *m*.  Returns "
"``0`` if successful and a negative value on failure."
msgstr ""
"Define um atributo pertencente ao objeto no endereço *obj_addr* para o "
"objeto *o*. O atributo a definir é descrito por ``PyMemberDef`` *m*. Retorna "
"``0`` em caso de sucesso e um valor negativo em caso de falha."

msgid ""
"``PyMember_SetOne`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""
"``PyMember_SetOne`` está sempre disponível. Anteriormente, era necessário "
"incluir ``\"structmember.h\"``."

msgid "Member flags"
msgstr "Flags de membros"

msgid "The following flags can be used with :c:member:`PyMemberDef.flags`:"
msgstr ""
"As seguintes flags podem ser utilizadas com :c:member:`PyMemberDef.flags`:"

msgid "Not writable."
msgstr "Não gravável."

msgid ""
"Emit an ``object.__getattr__`` :ref:`audit event <audit-events>` before "
"reading."
msgstr ""
"Emite um evento de auditoria :ref:`audit event <audit-events>` de ``object."
"__getattr__`` antes da leitura."

msgid ""
"Indicates that the :c:member:`~PyMemberDef.offset` of this ``PyMemberDef`` "
"entry indicates an offset from the subclass-specific data, rather than from "
"``PyObject``."
msgstr ""
"Indica que o :c:member:`~PyMemberDef.offset` desta entrada ``PyMemberDef`` "
"indica um deslocamento a partir dos dados específicos da subclasse, em vez "
"de a partir de ``PyObject``."

msgid ""
"Can only be used as part of the :c:data:`Py_tp_members` :c:type:`slot "
"<PyType_Slot>` when creating a class using negative :c:member:`~PyType_Spec."
"basicsize`. It is mandatory in that case. When setting :c:member:"
"`~PyTypeObject.tp_members` from the slot during class creation, Python "
"clears the flag and sets :c:member:`PyMemberDef.offset` to the offset from "
"the ``PyObject`` struct."
msgstr ""
"Pode ser utilizada apenas como parte do :c:data:`Py_tp_members` :c:type:"
"`slot <PyType_Slot>` ao criar uma classe utilizando um :c:member:"
"`~PyType_Spec.basicsize` negativo. É obrigatório nesse caso. Ao definir :c:"
"member:`~PyTypeObject.tp_members` a partir do slot durante a criação da "
"classe, o Python limpa a flag e define :c:member:`PyMemberDef.offset` para o "
"deslocamento a partir da struct ``PyObject``."

msgid ""
"The :c:macro:`!RESTRICTED`, :c:macro:`!READ_RESTRICTED` and :c:macro:`!"
"WRITE_RESTRICTED` macros available with ``#include \"structmember.h\"`` are "
"deprecated. :c:macro:`!READ_RESTRICTED` and :c:macro:`!RESTRICTED` are "
"equivalent to :c:macro:`Py_AUDIT_READ`; :c:macro:`!WRITE_RESTRICTED` does "
"nothing."
msgstr ""
"As macros :c:macro:`!RESTRICTED`, :c:macro:`!READ_RESTRICTED` e :c:macro:`!"
"WRITE_RESTRICTED`, disponíveis com ``#include \"structmember.h\"``, estão "
"obsoleta. :c:macro:`!READ_RESTRICTED` e :c:macro:`!RESTRICTED` são "
"equivalentes a :c:macro:`Py_AUDIT_READ`; :c:macro:`!WRITE_RESTRICTED` não "
"faz nada."

msgid ""
"The :c:macro:`!READONLY` macro was renamed to :c:macro:`Py_READONLY`. The :c:"
"macro:`!PY_AUDIT_READ` macro was renamed with the ``Py_`` prefix. The new "
"names are now always available. Previously, these required ``#include "
"\"structmember.h\"``. The header is still available and it provides the old "
"names."
msgstr ""
"A macro :c:macro:`!READONLY` foi renomeada para :c:macro:`Py_READONLY`. A "
"macro :c:macro:`!PY_AUDIT_READ` foi renomeada com o prefixo ``Py_``. Os "
"novos nomes estão agora sempre disponíveis. Anteriormente, era necessário "
"``#include \"structmember.h\"``. O cabeçalho ainda está disponível e fornece "
"os nomes antigos."

msgid "Member types"
msgstr "Tipos de membros"

msgid ""
":c:member:`PyMemberDef.type` can be one of the following macros "
"corresponding to various C types. When the member is accessed in Python, it "
"will be converted to the equivalent Python type. When it is set from Python, "
"it will be converted back to the C type. If that is not possible, an "
"exception such as :exc:`TypeError` or :exc:`ValueError` is raised."
msgstr ""
"O :c:member:`PyMemberDef.type` pode ser uma das seguintes macros "
"correspondentes a vários tipos C. Quando o membro é acedido em Python, será "
"convertido para o tipo Python equivalente. Quando é definido a partir do "
"Python, será convertido de volta para o tipo C. Se isso não for possível, é "
"levantada uma exceção como :exc:`TypeError` ou :exc:`ValueError`."

msgid ""
"Unless marked (D), attributes defined this way cannot be deleted using e.g. :"
"keyword:`del` or :py:func:`delattr`."
msgstr ""
"A menos que marcado com (D), os atributos definidos desta forma não podem "
"ser eliminados utilizando, por exemplo, :keyword:`del` ou :py:func:`delattr`."

msgid "Macro name"
msgstr "Nome da macro"

msgid "C type"
msgstr "tipo C"

msgid "Python type"
msgstr "tipo Python"

msgid ":c:expr:`char`"
msgstr ":c:expr:`char`"

msgid ":py:class:`int`"
msgstr ":py:class:`int`"

msgid ":c:expr:`short`"
msgstr ":c:expr:`short`"

msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

msgid ":c:expr:`long`"
msgstr ":c:expr:`long`"

msgid ":c:expr:`long long`"
msgstr ":c:expr:`long long`"

msgid ":c:expr:`unsigned char`"
msgstr ":c:expr:`unsigned char`"

msgid ":c:expr:`unsigned int`"
msgstr ":c:expr:`unsigned int`"

msgid ":c:expr:`unsigned short`"
msgstr ":c:expr:`unsigned short`"

msgid ":c:expr:`unsigned long`"
msgstr ":c:expr:`unsigned long`"

msgid ":c:expr:`unsigned long long`"
msgstr ":c:expr:`unsigned long long`"

msgid ":c:expr:`Py_ssize_t`"
msgstr ":c:expr:`Py_ssize_t`"

msgid ":c:expr:`float`"
msgstr ":c:expr:`float`"

msgid ":py:class:`float`"
msgstr ":py:class:`float`"

msgid ":c:expr:`double`"
msgstr ":c:expr:`double`"

msgid ":c:expr:`char` (written as 0 or 1)"
msgstr ":c:expr:`char` (escrito como 0 ou 1)"

msgid ":py:class:`bool`"
msgstr ":py:class:`bool`"

msgid ":c:expr:`const char *` (*)"
msgstr ":c:expr:`const char *` (*)"

msgid ":py:class:`str` (RO)"
msgstr ":py:class:`str` (SO)"

msgid ":c:expr:`const char[]` (*)"
msgstr ":c:expr:`const char[]` (*)"

msgid ":c:expr:`char` (0-127)"
msgstr ":c:expr:`char` (0-127)"

msgid ":py:class:`str` (**)"
msgstr ":py:class:`str` (**)"

msgid ":c:expr:`PyObject *`"
msgstr ":c:expr:`PyObject *`"

msgid ":py:class:`object` (D)"
msgstr ":py:class:`object` (E)"

msgid ""
"(*): Zero-terminated, UTF8-encoded C string. With :c:macro:`!Py_T_STRING` "
"the C representation is a pointer; with :c:macro:`!Py_T_STRING_INPLACE` the "
"string is stored directly in the structure."
msgstr ""
"(*): String C terminada por zero, codificada em UTF8. Com :c:macro:`!"
"Py_T_STRING`, a representação C é um ponteiro; com :c:macro:`!"
"Py_T_STRING_INPLACE`, a string é armazenada diretamente na estrutura."

msgid "(**): String of length 1. Only ASCII is accepted."
msgstr "(**): String de comprimento 1. Apenas ASCII é aceite."

msgid "(RO): Implies :c:macro:`Py_READONLY`."
msgstr "(SO): Implica :c:macro:`Py_READONLY`."

msgid ""
"(D): Can be deleted, in which case the pointer is set to ``NULL``. Reading a "
"``NULL`` pointer raises :py:exc:`AttributeError`."
msgstr ""
"(E): Pode ser eliminado, caso em que o ponteiro é definido para ``NULL``. A "
"leitura de um ponteiro ``NULL`` levanta :py:exc:`AttributeError`."

msgid ""
"In previous versions, the macros were only available with ``#include "
"\"structmember.h\"`` and were named without the ``Py_`` prefix (e.g. as "
"``T_INT``). The header is still available and contains the old names, along "
"with the following deprecated types:"
msgstr ""
"Em versões anteriores, as macros estavam disponíveis apenas com ``#include "
"\"structmember.h\"`` e eram nomeadas sem o prefixo ``Py_`` (por exemplo, "
"como ``T_INT``). O cabeçalho ainda está disponível e contém os nomes "
"antigos, juntamente com os seguintes tipos obsoletos:"

msgid ""
"Like ``Py_T_OBJECT_EX``, but ``NULL`` is converted to ``None``. This results "
"in surprising behavior in Python: deleting the attribute effectively sets it "
"to ``None``."
msgstr ""
"Semelhante a ``Py_T_OBJECT_EX``, mas ``NULL`` é convertido para ``None``. "
"Isto resulta em comportamento surpreendente em Python: eliminar o atributo "
"define-o efetivamente para ``None``."

msgid "Always ``None``. Must be used with :c:macro:`Py_READONLY`."
msgstr "Sempre ``None``. Deve ser utilizado com :c:macro:`Py_READONLY`."

msgid "Defining Getters and Setters"
msgstr "Definição de Getters e Setters"

msgid ""
"Structure to define property-like access for a type. See also description of "
"the :c:member:`PyTypeObject.tp_getset` slot."
msgstr ""
"Estrutura para definir acesso semelhante a propriedades para um tipo. Veja "
"também a descrição do slot :c:member:`PyTypeObject.tp_getset`."

msgid "attribute name"
msgstr "nome do atributo"

msgid "C function to get the attribute."
msgstr "Função C para obter o atributo."

msgid ""
"Optional C function to set or delete the attribute. If ``NULL``, the "
"attribute is read-only."
msgstr ""
"Função C opcional para definir ou eliminar o atributo. Se ``NULL``, o "
"atributo é apenas de leitura."

msgid "optional docstring"
msgstr "docstring opcional"

msgid ""
"Optional user data pointer, providing additional data for getter and setter."
msgstr ""
"Ponteiro de dados do utilizador opcional, fornecendo dados adicionais para "
"getter e setter."

msgid ""
"The ``get`` function takes one :c:expr:`PyObject*` parameter (the instance) "
"and a user data pointer (the associated ``closure``):"
msgstr ""
"A função ``get`` recebe um parâmetro :c:expr:`PyObject*` (a instância) e um "
"ponteiro de dados do utilizador (o ``closure`` associado):"

msgid ""
"It should return a new reference on success or ``NULL`` with a set exception "
"on failure."
msgstr ""
"Deve retornar uma nova referência em caso de sucesso ou ``NULL`` com uma "
"exceção definida em caso de falha."

msgid ""
"``set`` functions take two :c:expr:`PyObject*` parameters (the instance and "
"the value to be set) and a user data pointer (the associated ``closure``):"
msgstr ""
"As funções ``set`` recebem dois parâmetros :c:expr:`PyObject*` (a instância "
"e o valor a definir) e um ponteiro de dados do utilizador (o ``closure`` "
"associado):"

msgid ""
"In case the attribute should be deleted the second parameter is ``NULL``. "
"Should return ``0`` on success or ``-1`` with a set exception on failure."
msgstr ""
"Caso o atributo deva ser eliminado, o segundo parâmetro é ``NULL``. Deve "
"retornar ``0`` em caso de sucesso ou ``-1`` com uma exceção definida em caso "
"de falha."

msgid "built-in function"
msgstr "função incorporada"

msgid "classmethod"
msgstr "método de classe"

msgid "staticmethod"
msgstr "método estático"

msgid "READ_RESTRICTED (C macro)"
msgstr "LEITURA_RESTRITA (macro C)"

msgid "WRITE_RESTRICTED (C macro)"
msgstr "ESCRITA_RESTRITA (macro C)"

msgid "RESTRICTED (C macro)"
msgstr "RESTRITA (macro C)"

msgid "READONLY (C macro)"
msgstr "APENAS_LEITURA (macro C)"

msgid "T_BYTE (C macro)"
msgstr "T_BYTE (macro C)"

msgid "T_SHORT (C macro)"
msgstr "T_SHORT (macro C)"

msgid "T_INT (C macro)"
msgstr "T_INT (macro C)"

msgid "T_LONG (C macro)"
msgstr "T_LONG (macro C)"

msgid "T_LONGLONG (C macro)"
msgstr "T_LONGLONG (macro C)"

msgid "T_UBYTE (C macro)"
msgstr "T_UBYTE (macro C)"

msgid "T_USHORT (C macro)"
msgstr "T_USHORT (macro C)"

msgid "T_UINT (C macro)"
msgstr "T_UINT (macro C)"

msgid "T_ULONG (C macro)"
msgstr "T_ULONG (macro C)"

msgid "T_ULONGULONG (C macro)"
msgstr "T_ULONGULONG (macro C)"

msgid "T_PYSSIZET (C macro)"
msgstr "T_PYSSIZET (macro C)"

msgid "T_FLOAT (C macro)"
msgstr "T_FLOAT (macro C)"

msgid "T_DOUBLE (C macro)"
msgstr "T_DOUBLE (macro C)"

msgid "T_BOOL (C macro)"
msgstr "T_BOOL (macro C)"

msgid "T_CHAR (C macro)"
msgstr "T_CHAR (macro C)"

msgid "T_STRING (C macro)"
msgstr "T_STRING (macro C)"

msgid "T_STRING_INPLACE (C macro)"
msgstr "T_STRING_INPLACE (macro C)"

msgid "T_OBJECT_EX (C macro)"
msgstr "T_OBJECT_EX (macro C)"

msgid "structmember.h"
msgstr "structmember.h"
