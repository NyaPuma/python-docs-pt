# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-01 14:20+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid "Extending/Embedding FAQ"
msgstr "Perguntas frequentes sobre extensão/integração"

msgid "Contents"
msgstr "Conteúdos"

msgid "Can I create my own functions in C?"
msgstr "Posso criar as minhas próprias funções em C?"

msgid ""
"Yes, you can create built-in modules containing functions, variables, "
"exceptions and even new types in C.  This is explained in the document :ref:"
"`extending-index`."
msgstr ""
"Sim, é possível criar módulos integrados que contêm funções, variáveis, "
"exceções e até mesmo novos tipos em C. Isso é explicado no documento :ref:"
"`extending-index`."

msgid "Most intermediate or advanced Python books will also cover this topic."
msgstr ""
"A maioria dos livros de Python de nível intermediário ou avançado também "
"abordam este tópico."

msgid "Can I create my own functions in C++?"
msgstr "Posso criar as minhas próprias funções em C++?"

msgid ""
"Yes, using the C compatibility features found in C++.  Place ``extern "
"\"C\" { ... }`` around the Python include files and put ``extern \"C\"`` "
"before each function that is going to be called by the Python interpreter.  "
"Global or static C++ objects with constructors are probably not a good idea."
msgstr ""
"Sim, se utilizar os recursos de compatibilidade C encontrados em C++. "
"Coloque ``extern \"C\" { ... }`` em torno dos ficheiros de inclusão Python e "
"coloque ``extern \"C\"`` antes de cada função que será chamada pelo "
"interpretador Python. Objetos C++ globais ou estáticos com construtores "
"provavelmente não são uma boa ideia."

msgid "Writing C is hard; are there any alternatives?"
msgstr "Escrever em C é difícil; há alternativas?"

msgid ""
"There are a number of alternatives to writing your own C extensions, "
"depending on what you're trying to do. :ref:`Recommended third party tools "
"<c-api-tools>` offer both simpler and more sophisticated approaches to "
"creating C and C++ extensions for Python."
msgstr ""
"Existem várias alternativas para escrever as suas próprias extensões C, "
"dependendo do que pretende fazer. :ref:`Ferramentas de terceiros "
"recomendadas <c-api-tools>` oferecem abordagens mais simples e sofisticadas "
"para criar extensões C e C++ para Python."

msgid "How can I execute arbitrary Python statements from C?"
msgstr "Como posso executar instruções Python arbitrárias a partir de C?"

msgid ""
"The highest-level function to do this is :c:func:`PyRun_SimpleString` which "
"takes a single string argument to be executed in the context of the module "
"``__main__`` and returns ``0`` for success and ``-1`` when an exception "
"occurred (including :exc:`SyntaxError`).  If you want more control, use :c:"
"func:`PyRun_String`; see the source for :c:func:`PyRun_SimpleString` in "
"``Python/pythonrun.c``."
msgstr ""
"A função de nível mais alto para fazer isso é :c:func:`PyRun_SimpleString`, "
"que recebe um único argumento de string para ser executado no contexto do "
"módulo ``__main__`` e retorna ``0`` em caso de sucesso e ``-1`` quando "
"ocorre uma exceção (incluindo :exc:`SyntaxError`). Se desejar mais controlo, "
"utilize :c:func:`PyRun_String`; consulte o código-fonte de :c:func:"
"`PyRun_SimpleString` em ``Python/pythonrun.c``."

msgid "How can I evaluate an arbitrary Python expression from C?"
msgstr "Como posso avaliar uma expressão Python arbitrária a partir de C?"

msgid ""
"Call the function :c:func:`PyRun_String` from the previous question with the "
"start symbol :c:data:`Py_eval_input`; it parses an expression, evaluates it "
"and returns its value."
msgstr ""
"Chame a função :c:func:`PyRun_String` da pergunta anterior com o símbolo "
"inicial :c:data:`Py_eval_input`; ela analisa uma expressão, avalia-a e "
"retorna o seu valor."

msgid "How do I extract C values from a Python object?"
msgstr "Como extrair valores C de um objeto Python?"

msgid ""
"That depends on the object's type.  If it's a tuple, :c:func:`PyTuple_Size` "
"returns its length and :c:func:`PyTuple_GetItem` returns the item at a "
"specified index.  Lists have similar functions, :c:func:`PyList_Size` and :c:"
"func:`PyList_GetItem`."
msgstr ""
"Isso depende do tipo do objeto. Se for um tuplo, :c:func:`PyTuple_Size` "
"retorna o seu comprimento e :c:func:`PyTuple_GetItem` retorna o item em um "
"índice especificado. As listas têm funções semelhantes, :c:func:"
"`PyList_Size` e :c:func:`PyList_GetItem`."

msgid ""
"For bytes, :c:func:`PyBytes_Size` returns its length and :c:func:"
"`PyBytes_AsStringAndSize` provides a pointer to its value and its length.  "
"Note that Python bytes objects may contain null bytes so C's :c:func:`!"
"strlen` should not be used."
msgstr ""
"Para bytes, :c:func:`PyBytes_Size` retorna o seu comprimento e :c:func:"
"`PyBytes_AsStringAndSize` fornece um ponteiro para o seu valor e "
"comprimento. Observe que os objetos bytes do Python podem conter bytes "
"nulos, portanto, :c:func:`!strlen` do C não deve ser usado."

msgid ""
"To test the type of an object, first make sure it isn't ``NULL``, and then "
"use :c:func:`PyBytes_Check`, :c:func:`PyTuple_Check`, :c:func:"
"`PyList_Check`, etc."
msgstr ""
"Para testar o tipo de um objeto, primeiro certifique-se de que ele não é "
"``NULL`` e, em seguida, use :c:func:`PyBytes_Check`, :c:func:"
"`PyTuple_Check`, :c:func:`PyList_Check`, etc."

msgid ""
"There is also a high-level API to Python objects which is provided by the so-"
"called 'abstract' interface -- read ``Include/abstract.h`` for further "
"details.  It allows interfacing with any kind of Python sequence using calls "
"like :c:func:`PySequence_Length`, :c:func:`PySequence_GetItem`, etc. as well "
"as many other useful protocols such as numbers (:c:func:`PyNumber_Index` et "
"al.) and mappings in the PyMapping APIs."
msgstr ""
"Existe também uma API de alto nível para objetos Python, fornecida pela "
"chamada interface 'abstrata' — leia ``Include/abstract.h`` para obter mais "
"detalhes. Ela permite a interface com qualquer tipo de sequência Python "
"utilizando chamadas como :c:func:`PySequence_Length`, :c:func:"
"`PySequence_GetItem`, etc., bem como muitos outros protocolos úteis, como "
"números (:c:func:`PyNumber_Index` et al.) e mapeamentos nas APIs PyMapping."

msgid "How do I use Py_BuildValue() to create a tuple of arbitrary length?"
msgstr ""
"Como posso usar Py_BuildValue() para criar um tuplo de comprimento "
"arbitrário?"

msgid "You can't.  Use :c:func:`PyTuple_Pack` instead."
msgstr "Não pode. Use :c:func:`PyTuple_Pack` em vez disso."

msgid "How do I call an object's method from C?"
msgstr "Como chamar o método de um objeto a partir de C?"

msgid ""
"The :c:func:`PyObject_CallMethod` function can be used to call an arbitrary "
"method of an object.  The parameters are the object, the name of the method "
"to call, a format string like that used with :c:func:`Py_BuildValue`, and "
"the argument values::"
msgstr ""
"A função :c:func:`PyObject_CallMethod` pode ser utilizada para chamar um "
"método arbitrário de um objeto. Os parâmetros são o objeto, o nome do método "
"a ser chamado, uma string de formato como a utilizada com :c:func:"
"`Py_BuildValue` e os valores dos argumentos::"

msgid ""
"PyObject *\n"
"PyObject_CallMethod(PyObject *object, const char *method_name,\n"
"                    const char *arg_format, ...);"
msgstr ""
"PyObject *\n"
"PyObject_CallMethod(PyObject *object, const char *method_name,\n"
"                    const char *arg_format, ...);"

msgid ""
"This works for any object that has methods -- whether built-in or user-"
"defined. You are responsible for eventually :c:func:`Py_DECREF`\\ 'ing the "
"return value."
msgstr ""
"Isto funciona para qualquer objeto que tenha métodos -- sejam eles "
"integrados ou definidos pelo utilizador. Você é responsável por "
"eventualmente :c:func:`Py_DECREF`\\ 'ing o valor de retorno."

msgid ""
"To call, e.g., a file object's \"seek\" method with arguments 10, 0 "
"(assuming the file object pointer is \"f\")::"
msgstr ""
"Para chamar, por exemplo, o método \"seek\" de um objeto de ficheiro com os "
"argumentos 10, 0 (assumindo que o ponteiro do objeto de ficheiro é \"f\")::"

msgid ""
"res = PyObject_CallMethod(f, \"seek\", \"(ii)\", 10, 0);\n"
"if (res == NULL) {\n"
"        ... an exception occurred ...\n"
"}\n"
"else {\n"
"        Py_DECREF(res);\n"
"}"
msgstr ""
"res = PyObject_CallMethod(f, \"seek\", \"(ii)\", 10, 0);\n"
"if (res == NULL) {\n"
"        ... an exception occurred ...\n"
"}\n"
"else {\n"
"        Py_DECREF(res);\n"
"}"

msgid ""
"Note that since :c:func:`PyObject_CallObject` *always* wants a tuple for the "
"argument list, to call a function without arguments, pass \"()\" for the "
"format, and to call a function with one argument, surround the argument in "
"parentheses, e.g. \"(i)\"."
msgstr ""
"Observe que, como :c:func:`PyObject_CallObject` *sempre* requer um tuplo "
"para a lista de argumentos, para chamar uma função sem argumentos, passe "
"\"()\" para o formato e, para chamar uma função com um argumento, coloque o "
"argumento entre parênteses, por exemplo, \"(i)\"."

msgid ""
"How do I catch the output from PyErr_Print() (or anything that prints to "
"stdout/stderr)?"
msgstr ""
"Como posso capturar a saída de PyErr_Print() (ou qualquer coisa que imprima "
"em stdout/stderr)?"

msgid ""
"In Python code, define an object that supports the ``write()`` method.  "
"Assign this object to :data:`sys.stdout` and :data:`sys.stderr`.  Call "
"print_error, or just allow the standard traceback mechanism to work. Then, "
"the output will go wherever your ``write()`` method sends it."
msgstr ""
"No código Python, defina um objeto que suporte o método ``write()``. Atribua "
"este objeto a :data:`sys.stdout` e :data:`sys.stderr`. Chame print_error ou "
"simplesmente permita que o mecanismo de rastreamento padrão funcione. Então, "
"a saída irá para onde quer que o seu método ``write()`` a envie."

msgid "The easiest way to do this is to use the :class:`io.StringIO` class:"
msgstr ""
"A maneira mais fácil de fazer isso é usar a classe :class:`io.StringIO`:"

msgid ""
">>> import io, sys\n"
">>> sys.stdout = io.StringIO()\n"
">>> print('foo')\n"
">>> print('hello world!')\n"
">>> sys.stderr.write(sys.stdout.getvalue())\n"
"foo\n"
"hello world!"
msgstr ""
">>> import io, sys\n"
">>> sys.stdout = io.StringIO()\n"
">>> print('foo')\n"
">>> print('hello world!')\n"
">>> sys.stderr.write(sys.stdout.getvalue())\n"
"foo\n"
"hello world!"

msgid "A custom object to do the same would look like this:"
msgstr "Um objeto personalizado para fazer o mesmo ficaria assim:"

msgid ""
">>> import io, sys\n"
">>> class StdoutCatcher(io.TextIOBase):\n"
"...     def __init__(self):\n"
"...         self.data = []\n"
"...     def write(self, stuff):\n"
"...         self.data.append(stuff)\n"
"...\n"
">>> import sys\n"
">>> sys.stdout = StdoutCatcher()\n"
">>> print('foo')\n"
">>> print('hello world!')\n"
">>> sys.stderr.write(''.join(sys.stdout.data))\n"
"foo\n"
"hello world!"
msgstr ""
">>> import io, sys\n"
">>> class StdoutCatcher(io.TextIOBase):\n"
"...     def __init__(self):\n"
"...         self.data = []\n"
"...     def write(self, stuff):\n"
"...         self.data.append(stuff)\n"
"...\n"
">>> import sys\n"
">>> sys.stdout = StdoutCatcher()\n"
">>> print('foo')\n"
">>> print('hello world!')\n"
">>> sys.stderr.write(''.join(sys.stdout.data))\n"
"foo\n"
"hello world!"

msgid "How do I access a module written in Python from C?"
msgstr "Como posso aceder a um módulo escrito em Python a partir de C?"

msgid "You can get a pointer to the module object as follows::"
msgstr "Pode obter um ponteiro para o objeto do módulo da seguinte forma::"

msgid "module = PyImport_ImportModule(\"<modulename>\");"
msgstr "module = PyImport_ImportModule(\"<modulename>\");"

msgid ""
"If the module hasn't been imported yet (i.e. it is not yet present in :data:"
"`sys.modules`), this initializes the module; otherwise it simply returns the "
"value of ``sys.modules[\"<modulename>\"]``.  Note that it doesn't enter the "
"module into any namespace -- it only ensures it has been initialized and is "
"stored in :data:`sys.modules`."
msgstr ""
"Se o módulo ainda não tiver sido importado (ou seja, ainda não estiver "
"presente em :data:`sys.modules`), isso inicializa o módulo; caso contrário, "
"simplesmente retorna o valor de ``sys.modules[\"<modulename>\"]``. Note que "
"não insere o módulo em nenhum namespace -- apenas garante que ele foi "
"inicializado e está armazenado em :data:`sys.modules`."

msgid ""
"You can then access the module's attributes (i.e. any name defined in the "
"module) as follows::"
msgstr ""
"Você pode então aceder aos atributos do módulo (ou seja, qualquer nome "
"definido no módulo) da seguinte forma::"

msgid "attr = PyObject_GetAttrString(module, \"<attrname>\");"
msgstr "attr = PyObject_GetAttrString(module, \"<attrname>\");"

msgid ""
"Calling :c:func:`PyObject_SetAttrString` to assign to variables in the "
"module also works."
msgstr ""
"Chamar :c:func:`PyObject_SetAttrString` para atribuir a variáveis no módulo "
"também funciona."

msgid "How do I interface to C++ objects from Python?"
msgstr "Como faço para interagir com objetos C++ a partir do Python?"

msgid ""
"Depending on your requirements, there are many approaches.  To do this "
"manually, begin by reading :ref:`the \"Extending and Embedding\" document "
"<extending-index>`.  Realize that for the Python run-time system, there "
"isn't a whole lot of difference between C and C++ -- so the strategy of "
"building a new Python type around a C structure (pointer) type will also "
"work for C++ objects."
msgstr ""
"Dependendo dos seus requisitos, existem várias abordagens. Para fazer isso "
"manualmente, comece por ler :ref:`o documento \"Extending and Embedding\" "
"<extending-index>`. Tenha em conta que, para o sistema de tempo de execução "
"Python, não há muita diferença entre C e C++ -- portanto, a estratégia de "
"construir um novo tipo Python em torno de um tipo de estrutura C (ponteiro) "
"também funcionará para objetos C++."

msgid "For C++ libraries, see :ref:`c-wrapper-software`."
msgstr "Para bibliotecas C++, consulte :ref:`c-wrapper-software`."

msgid "I added a module using the Setup file and the make fails; why?"
msgstr ""
"Adicionei um módulo utilizando o ficheiro de configuração e o make falha; "
"porquê?"

msgid ""
"Setup must end in a newline, if there is no newline there, the build process "
"fails.  (Fixing this requires some ugly shell script hackery, and this bug "
"is so minor that it doesn't seem worth the effort.)"
msgstr ""
"A configuração deve terminar numa nova linha; se não houver uma nova linha, "
"o processo de compilação falhará. (Corrigir isso requer alguns truques feios "
"de script de shell, e esse bug é tão insignificante que não parece valer a "
"pena o esforço.)"

msgid "How do I debug an extension?"
msgstr "Como posso depurar uma extensão?"

msgid ""
"When using GDB with dynamically loaded extensions, you can't set a "
"breakpoint in your extension until your extension is loaded."
msgstr ""
"Ao utilizar o GDB com extensões carregadas dinamicamente, não é possível "
"definir um ponto de interrupção na extensão até que ela seja carregada."

msgid "In your ``.gdbinit`` file (or interactively), add the command:"
msgstr "No seu ficheiro ``.gdbinit`` (ou interativamente), adicione o comando:"

msgid "br _PyImport_LoadDynamicModule"
msgstr "br _PyImport_LoadDynamicModule"

msgid "Then, when you run GDB:"
msgstr "Então, quando executar o GDB:"

msgid ""
"$ gdb /local/bin/python\n"
"gdb) run myscript.py\n"
"gdb) continue # repeat until your extension is loaded\n"
"gdb) finish   # so that your extension is loaded\n"
"gdb) br myfunction.c:50\n"
"gdb) continue"
msgstr ""
"$ gdb /local/bin/python\n"
"gdb) run myscript.py\n"
"gdb) continue # repita até que a sua extensão seja carregada\n"
"gdb) finish # para que a sua extensão seja carregada\n"
"gdb) br myfunction.c:50\n"
"gdb) continue"

msgid ""
"I want to compile a Python module on my Linux system, but some files are "
"missing. Why?"
msgstr ""
"Quero compilar um módulo Python no meu sistema Linux, mas alguns ficheiros "
"estão em falta. Porquê?"

msgid ""
"Most packaged versions of Python omit some files required for compiling "
"Python extensions."
msgstr ""
"A maioria das versões empacotadas do Python omitem alguns ficheiros "
"necessários para compilar extensões do Python."

msgid "For Red Hat, install the python3-devel RPM to get the necessary files."
msgstr ""
"Para o Red Hat, instale o RPM python3-devel para obter os ficheiros "
"necessários."

msgid "For Debian, run ``apt-get install python3-dev``."
msgstr "Para Debian, execute ``apt-get install python3-dev``."

msgid "How do I tell \"incomplete input\" from \"invalid input\"?"
msgstr "Como distinguir entre \"entrada incompleta\" e \"entrada inválida\"?"

msgid ""
"Sometimes you want to emulate the Python interactive interpreter's behavior, "
"where it gives you a continuation prompt when the input is incomplete (e.g. "
"you typed the start of an \"if\" statement or you didn't close your "
"parentheses or triple string quotes), but it gives you a syntax error "
"message immediately when the input is invalid."
msgstr ""
"Às vezes, você deseja emular o comportamento do interpretador interativo do "
"Python, que exibe um prompt de continuação quando a entrada está incompleta "
"(por exemplo, você digitou o início de uma instrução \"if\" ou não fechou os "
"parênteses ou as aspas triplas), mas exibe uma mensagem de erro de sintaxe "
"imediatamente quando a entrada é inválida."

msgid ""
"In Python you can use the :mod:`codeop` module, which approximates the "
"parser's behavior sufficiently.  IDLE uses this, for example."
msgstr ""
"Em Python, pode usar o módulo :mod:`codeop`, que aproxima suficientemente o "
"comportamento do analisador. O IDLE usa-o, por exemplo."

msgid ""
"The easiest way to do it in C is to call :c:func:`PyRun_InteractiveLoop` "
"(perhaps in a separate thread) and let the Python interpreter handle the "
"input for you. You can also set the :c:func:`PyOS_ReadlineFunctionPointer` "
"to point at your custom input function. See ``Modules/readline.c`` and "
"``Parser/myreadline.c`` for more hints."
msgstr ""
"A maneira mais fácil de fazer isso em C é chamar :c:func:"
"`PyRun_InteractiveLoop` (talvez num thread separado) e deixar o "
"interpretador Python lidar com a entrada para você. Você também pode "
"definir :c:func:`PyOS_ReadlineFunctionPointer` para apontar para a sua "
"função de entrada personalizada. Consulte ``Modules/readline.c`` e ``Parser/"
"myreadline.c`` para obter mais dicas."

msgid "How do I find undefined g++ symbols __builtin_new or __pure_virtual?"
msgstr ""
"Como posso encontrar os símbolos g++ indefinidos __builtin_new ou "
"__pure_virtual?"

msgid ""
"To dynamically load g++ extension modules, you must recompile Python, relink "
"it using g++ (change LINKCC in the Python Modules Makefile), and link your "
"extension module using g++ (e.g., ``g++ -shared -o mymodule.so mymodule.o``)."
msgstr ""
"Para carregar dinamicamente os módulos de extensão g++, é necessário "
"recompilar o Python, religá-lo utilizando g++ (altere LINKCC no Makefile dos "
"módulos Python) e ligar o seu módulo de extensão utilizando g++ (por "
"exemplo, ``g++ -shared -o mymodule.so mymodule.o``)."

msgid ""
"Can I create an object class with some methods implemented in C and others "
"in Python (e.g. through inheritance)?"
msgstr ""
"Posso criar uma classe de objeto com alguns métodos implementados em C e "
"outros em Python (por exemplo, através de herança)?"

msgid ""
"Yes, you can inherit from built-in classes such as :class:`int`, :class:"
"`list`, :class:`dict`, etc."
msgstr ""
"Sim, pode herdar de classes integradas, tais como :class:`int`, :class:"
"`list`, :class:`dict`, etc."

msgid ""
"The Boost Python Library (BPL, https://www.boost.org/libs/python/doc/index."
"html) provides a way of doing this from C++ (i.e. you can inherit from an "
"extension class written in C++ using the BPL)."
msgstr ""
"A Biblioteca Boost Python (BPL, https://www.boost.org/libs/python/doc/index."
"html) fornece uma maneira de fazer isso a partir do C++ (ou seja, você pode "
"herdar de uma classe de extensão escrita em C++ utilizando a BPL)."
