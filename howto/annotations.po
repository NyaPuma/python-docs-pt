# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-05 14:39+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid "Annotations Best Practices"
msgstr "Boas Práticas para Anotações"

msgid "author"
msgstr "autor"

msgid "Larry Hastings"
msgstr "Larry Hastings"

msgid "Abstract"
msgstr "Resumo"

msgid ""
"This document is designed to encapsulate the best practices for working with "
"annotations dicts.  If you write Python code that examines "
"``__annotations__`` on Python objects, we encourage you to follow the "
"guidelines described below."
msgstr ""
"Este documento foi concebido para reunir as melhores práticas para trabalhar "
"com dicionários de anotações. Se escreve código Python que examina "
"``__annotations__`` em objetos Python, encorajamo-lo a seguir as diretrizes "
"descritas abaixo."

msgid ""
"The document is organized into four sections: best practices for accessing "
"the annotations of an object in Python versions 3.10 and newer, best "
"practices for accessing the annotations of an object in Python versions 3.9 "
"and older, other best practices for ``__annotations__`` that apply to any "
"Python version, and quirks of ``__annotations__``."
msgstr ""
"O documento está organizado em quatro secções: melhores práticas para aceder "
"às anotações de um objeto no Python 3.10 e mais recentes, melhores práticas "
"para aceder às anotações de um objeto no Python 3.9 e anteriores, outras "
"melhores práticas para ``__annotations__`` aplicáveis a qualquer versão do "
"Python, e as particularidades (*quirks*) de ``__annotations__``."

msgid ""
"Note that this document is specifically about working with "
"``__annotations__``, not uses *for* annotations. If you're looking for "
"information on how to use \"type hints\" in your code, please see the :mod:"
"`typing` module."
msgstr ""
"Note que este documento é especificamente sobre como trabalhar com "
"``__annotations__``, e não sobre os usos *das* anotações. Se procura "
"informações sobre como usar \"type hints\" no seu código, por favor consulte "
"o módulo :mod:`typing`."

msgid "Accessing The Annotations Dict Of An Object In Python 3.10 And Newer"
msgstr ""
"Aceder ao Dicionário de Anotações de um Objeto no Python 3.10 e Mais Recentes"

msgid ""
"Python 3.10 adds a new function to the standard library: :func:`inspect."
"get_annotations`.  In Python versions 3.10 through 3.13, calling this "
"function is the best practice for accessing the annotations dict of any "
"object that supports annotations.  This function can also \"un-stringize\" "
"stringized annotations for you."
msgstr ""
"O Python 3.10 adiciona uma nova função à biblioteca padrão: :func:`inspect."
"get_annotations`. Nas versões 3.10 a 3.13, chamar esta função é a melhor "
"prática para aceder ao dicionário de anotações de qualquer objeto que "
"suporte anotações. Esta função também pode converter anotações em string "
"(*stringized*) de volta para objetos para si."

msgid ""
"In Python 3.14, there is a new :mod:`annotationlib` module with "
"functionality for working with annotations. This includes a :func:"
"`annotationlib.get_annotations` function, which supersedes :func:`inspect."
"get_annotations`."
msgstr ""
"No Python 3.14, existe um novo módulo :mod:`annotationlib` com "
"funcionalidades para trabalhar com anotações. Isto inclui a função :func:"
"`annotationlib.get_annotations`, que substitui a :func:`inspect."
"get_annotations`."

msgid ""
"If for some reason :func:`inspect.get_annotations` isn't viable for your use "
"case, you may access the ``__annotations__`` data member manually.  Best "
"practice for this changed in Python 3.10 as well: as of Python 3.10, ``o."
"__annotations__`` is guaranteed to *always* work on Python functions, "
"classes, and modules.  If you're certain the object you're examining is one "
"of these three *specific* objects, you may simply use ``o.__annotations__`` "
"to get at the object's annotations dict."
msgstr ""
"Se, por alguma razão, :func:`inspect.get_annotations` não for viável para o "
"seu caso de uso, pode aceder manualmente ao membro de dados "
"``__annotations__``. A melhor prática para isto também mudou no Python 3.10: "
"a partir desta versão, garante-se que ``o.__annotations__`` funciona "
"*sempre* em funções, classes e módulos Python. Se tiver a certeza de que o "
"objeto que está a examinar é um destes três objetos *específicos*, pode "
"simplesmente usar ``o.__annotations__`` para obter o dicionário de anotações "
"do objeto."

msgid ""
"However, other types of callables--for example, callables created by :func:"
"`functools.partial`--may not have an ``__annotations__`` attribute defined.  "
"When accessing the ``__annotations__`` of a possibly unknown object,  best "
"practice in Python versions 3.10 and newer is to call :func:`getattr` with "
"three arguments, for example ``getattr(o, '__annotations__', None)``."
msgstr ""
"No entanto, outros tipos de invocáveis (*callables*) — por exemplo, criados "
"por :func:`functools.partial` — podem não ter o atributo ``__annotations__`` "
"definido. Ao aceder ao ``__annotations__`` de um objeto possivelmente "
"desconhecido, a melhor prática no Python 3.10 e superior é chamar :func:"
"`getattr` com três argumentos, por exemplo: ``getattr(o, '__annotations__', "
"None)``."

msgid ""
"Before Python 3.10, accessing ``__annotations__`` on a class that defines no "
"annotations but that has a parent class with annotations would return the "
"parent's ``__annotations__``. In Python 3.10 and newer, the child class's "
"annotations will be an empty dict instead."
msgstr ""
"Antes do Python 3.10, aceder a ``__annotations__`` numa classe que não "
"define anotações, mas que tem uma classe pai com anotações, retornaria as "
"``__annotations__`` do pai. No Python 3.10 e mais recentes, as anotações da "
"classe filha serão, em vez disso, um dicionário vazio."

msgid "Accessing The Annotations Dict Of An Object In Python 3.9 And Older"
msgstr ""
"Aceder ao Dicionário de Anotações de um Objeto no Python 3.9 e Anterior"

msgid ""
"In Python 3.9 and older, accessing the annotations dict of an object is much "
"more complicated than in newer versions. The problem is a design flaw in "
"these older versions of Python, specifically to do with class annotations."
msgstr ""
"No Python 3.9 e anteriores, aceder ao dicionário de anotações de um objeto é "
"muito mais complicado do que nas versões mais recentes. O problema deve-se a "
"uma falha de design nestas versões antigas do Python, especificamente "
"relacionada com anotações de classes."

msgid ""
"Best practice for accessing the annotations dict of other objects--"
"functions, other callables, and modules--is the same as best practice for "
"3.10, assuming you aren't calling :func:`inspect.get_annotations`: you "
"should use three-argument :func:`getattr` to access the object's "
"``__annotations__`` attribute."
msgstr ""
"A melhor prática para aceder ao dicionário de anotações de outros objetos — "
"funções, outros invocáveis e módulos — é a mesma que no 3.10, assumindo que "
"não está a chamar :func:`inspect.get_annotations`: deve usar o :func:"
"`getattr` com três argumentos para aceder ao atributo ``__annotations__`` do "
"objeto."

msgid ""
"Unfortunately, this isn't best practice for classes.  The problem is that, "
"since ``__annotations__`` is optional on classes, and because classes can "
"inherit attributes from their base classes, accessing the "
"``__annotations__`` attribute of a class may inadvertently return the "
"annotations dict of a *base class.* As an example::"
msgstr ""
"Infelizmente, esta não é a melhor prática para classes. O problema é que, "
"como o atributo ``__annotations__`` é opcional em classes e as classes podem "
"herdar atributos das suas classes base, aceder ao atributo "
"``__annotations__`` de uma classe pode inadvertidamente retornar o "
"dicionário de anotações de uma *classe base.* Como exemplo::"

msgid ""
"class Base:\n"
"    a: int = 3\n"
"    b: str = 'abc'\n"
"\n"
"class Derived(Base):\n"
"    pass\n"
"\n"
"print(Derived.__annotations__)"
msgstr ""
"class Base:\n"
"    a: int = 3\n"
"    b: str = 'abc'\n"
"\n"
"class Derived(Base):\n"
"    pass\n"
"\n"
"print(Derived.__annotations__)"

msgid "This will print the annotations dict from ``Base``, not ``Derived``."
msgstr ""
"Isto irá imprimir o dicionário de anotações de ``Base``, não de ``Derived``."

msgid ""
"Your code will have to have a separate code path if the object you're "
"examining is a class (``isinstance(o, type)``). In that case, best practice "
"relies on an implementation detail of Python 3.9 and before: if a class has "
"annotations defined, they are stored in the class's :attr:`~type.__dict__` "
"dictionary.  Since the class may or may not have annotations defined, best "
"practice is to call the :meth:`~dict.get` method on the class dict."
msgstr ""
"O seu código terá de ter um caminho separado se o objeto que estiver a "
"examinar for uma classe (``isinstance(o, type)``). Nesse caso, a melhor "
"prática baseia-se num detalhe de implementação do Python 3.9 e anteriores: "
"se uma classe tem anotações definidas, elas são guardadas no dicionário :"
"attr:`~type.__dict__` da classe. Como a classe pode ou não ter anotações "
"definidas, a melhor prática é chamar o método :meth:`~dict.get` no "
"dicionário da classe."

msgid ""
"To put it all together, here is some sample code that safely accesses the "
"``__annotations__`` attribute on an arbitrary object in Python 3.9 and "
"before::"
msgstr ""
"Para resumir, aqui está um exemplo de código que acede com segurança ao "
"atributo ``__annotations__`` num objeto arbitrário no Python 3.9 e "
"anteriores::"

msgid ""
"if isinstance(o, type):\n"
"    ann = o.__dict__.get('__annotations__', None)\n"
"else:\n"
"    ann = getattr(o, '__annotations__', None)"
msgstr ""
"if isinstance(o, type):\n"
"    ann = o.__dict__.get('__annotations__', None)\n"
"else:\n"
"    ann = getattr(o, '__annotations__', None)"

msgid ""
"After running this code, ``ann`` should be either a dictionary or ``None``.  "
"You're encouraged to double-check the type of ``ann`` using :func:"
"`isinstance` before further examination."
msgstr ""
"Após executar este código, ``ann`` deverá ser um dicionário ou ``None``. "
"Recomenda-se que verifique o tipo de ``ann`` usando :func:`isinstance` antes "
"de prosseguir com a análise."

msgid ""
"Note that some exotic or malformed type objects may not have a :attr:`~type."
"__dict__` attribute, so for extra safety you may also wish to use :func:"
"`getattr` to access :attr:`!__dict__`."
msgstr ""
"Note que alguns objetos de tipo exóticos ou malformados podem não ter um "
"atributo :attr:`~type.__dict__`, por isso, para maior segurança, pode também "
"querer usar :func:`getattr` para aceder a :attr:`!__dict__`."

msgid "Manually Un-Stringizing Stringized Annotations"
msgstr "Remover Manualmente o Formato String de Anotações"

msgid ""
"In situations where some annotations may be \"stringized\", and you wish to "
"evaluate those strings to produce the Python values they represent, it "
"really is best to call :func:`inspect.get_annotations` to do this work for "
"you."
msgstr ""
"Em situações onde algumas anotações possam estar em formato de string "
"(*stringized*) e deseje avaliar essas strings para produzir os valores "
"Python que representam, o ideal é mesmo chamar :func:`inspect."
"get_annotations` para fazer esse trabalho por si."

msgid ""
"If you're using Python 3.9 or older, or if for some reason you can't use :"
"func:`inspect.get_annotations`, you'll need to duplicate its logic.  You're "
"encouraged to examine the implementation of :func:`inspect.get_annotations` "
"in the current Python version and follow a similar approach."
msgstr ""
"Se estiver a usar o Python 3.9 ou anterior, ou se por alguma razão não puder "
"usar :func:`inspect.get_annotations`, terá de duplicar a sua lógica. "
"Recomenda-se que examine a implementação de :func:`inspect.get_annotations` "
"na versão atual do Python e siga uma abordagem semelhante."

msgid ""
"In a nutshell, if you wish to evaluate a stringized annotation on an "
"arbitrary object ``o``:"
msgstr ""
"Em resumo, se desejar avaliar uma anotação em formato string num objeto "
"qualquer ``o``:"

msgid ""
"If ``o`` is a module, use ``o.__dict__`` as the ``globals`` when calling :"
"func:`eval`."
msgstr ""
"Se ``o`` for um módulo, use ``o.__dict__`` como ``globals`` ao chamar :func:"
"`eval`."

msgid ""
"If ``o`` is a class, use ``sys.modules[o.__module__].__dict__`` as the "
"``globals``, and ``dict(vars(o))`` as the ``locals``, when calling :func:"
"`eval`."
msgstr ""
"Se ``o`` for uma classe, use ``sys.modules[o.__module__].__dict__`` como "
"``globals``, e ``dict(vars(o))`` como ``locals``, ao chamar :func:`eval`."

msgid ""
"If ``o`` is a wrapped callable using :func:`functools.update_wrapper`, :func:"
"`functools.wraps`, or :func:`functools.partial`, iteratively unwrap it by "
"accessing either ``o.__wrapped__`` or ``o.func`` as appropriate, until you "
"have found the root unwrapped function."
msgstr ""
"Se ``o`` for um invocável embrulhado (*wrapped*) usando :func:`functools."
"update_wrapper`, :func:`functools.wraps` ou :func:`functools.partial`, "
"desembrulhe-o iterativamente acedendo a ``o.__wrapped__`` ou ``o.func`` "
"conforme apropriado, até encontrar a função raiz não embrulhada."

msgid ""
"If ``o`` is a callable (but not a class), use :attr:`o.__globals__ <function."
"__globals__>` as the globals when calling :func:`eval`."
msgstr ""
"Se ``o`` for um invocável (mas não uma classe), use :attr:`o.__globals__ "
"<function.__globals__>` como globals ao chamar :func:`eval`."

msgid ""
"However, not all string values used as annotations can be successfully "
"turned into Python values by :func:`eval`. String values could theoretically "
"contain any valid string, and in practice there are valid use cases for type "
"hints that require annotating with string values that specifically *can't* "
"be evaluated.  For example:"
msgstr ""
"No entanto, nem todos os valores de string usados como anotações podem ser "
"convertidos com sucesso em valores Python pelo :func:`eval`. Teoricamente, "
"os valores de string podem conter qualquer string válida e, na prática, "
"existem casos de uso legítimos para dicas de tipo que requerem anotações com "
"valores de string que especificamente *não podem* ser avaliados. Por exemplo:"

msgid ""
":pep:`604` union types using ``|``, before support for this was added to "
"Python 3.10."
msgstr ""
"Tipos de união da :pep:`604` usando ``|``, antes do suporte para isto ter "
"sido adicionado no Python 3.10."

msgid ""
"Definitions that aren't needed at runtime, only imported when :const:`typing."
"TYPE_CHECKING` is true."
msgstr ""
"Definições que não são necessárias em tempo de execução, apenas importadas "
"quando :const:`typing.TYPE_CHECKING` é verdadeiro."

msgid ""
"If :func:`eval` attempts to evaluate such values, it will fail and raise an "
"exception.  So, when designing a library API that works with annotations, "
"it's recommended to only attempt to evaluate string values when explicitly "
"requested to by the caller."
msgstr ""
"Se o :func:`eval` tentar avaliar tais valores, irá falhar e lançar uma "
"exceção. Assim, ao desenhar uma API de biblioteca que trabalhe com "
"anotações, recomenda-se que apenas tente avaliar valores de string quando "
"solicitado explicitamente pelo utilizador."

msgid "Best Practices For ``__annotations__`` In Any Python Version"
msgstr "Boas Práticas para ``__annotations__`` em Qualquer Versão do Python"

msgid ""
"You should avoid assigning to the ``__annotations__`` member of objects "
"directly.  Let Python manage setting ``__annotations__``."
msgstr ""
"Deve evitar atribuir valores diretamente ao membro ``__annotations__`` dos "
"objetos. Deixe o Python gerir a definição de ``__annotations__``."

msgid ""
"If you do assign directly to the ``__annotations__`` member of an object, "
"you should always set it to a ``dict`` object."
msgstr ""
"Se atribuir diretamente ao membro ``__annotations__`` de um objeto, deve "
"defini-lo sempre como um objeto ``dict``."

msgid ""
"You should avoid accessing ``__annotations__`` directly on any object. "
"Instead, use :func:`annotationlib.get_annotations` (Python 3.14+) or :func:"
"`inspect.get_annotations` (Python 3.10+)."
msgstr ""
"Deve evitar aceder a ``__annotations__`` diretamente em qualquer objeto. Em "
"vez disso, use :func:`annotationlib.get_annotations` (Python 3.14+) ou :func:"
"`inspect.get_annotations` (Python 3.10+)."

msgid ""
"If you do directly access the ``__annotations__`` member of an object, you "
"should ensure that it's a dictionary before attempting to examine its "
"contents."
msgstr ""
"Se aceder diretamente ao membro ``__annotations__`` de um objeto, deve "
"garantir que se trata de um dicionário antes de tentar examinar o seu "
"conteúdo."

msgid "You should avoid modifying ``__annotations__`` dicts."
msgstr "Deve evitar modificar dicionários ``__annotations__``."

msgid ""
"You should avoid deleting the ``__annotations__`` attribute of an object."
msgstr "Deve evitar eliminar o atributo ``__annotations__`` de um objeto."

msgid "``__annotations__`` Quirks"
msgstr "Particularidades de ``__annotations__``"

msgid ""
"In all versions of Python 3, function objects lazy-create an annotations "
"dict if no annotations are defined on that object.  You can delete the "
"``__annotations__`` attribute using ``del fn.__annotations__``, but if you "
"then access ``fn.__annotations__`` the object will create a new empty dict "
"that it will store and return as its annotations.  Deleting the annotations "
"on a function before it has lazily created its annotations dict will throw "
"an ``AttributeError``; using ``del fn.__annotations__`` twice in a row is "
"guaranteed to always throw an ``AttributeError``."
msgstr ""
"Em todas as versões do Python 3, os objetos de função criam o dicionário de "
"anotações de forma preguiçosa (*lazy-create*) se não houver anotações "
"definidas. Pode eliminar o atributo usando ``del fn.__annotations__``, mas "
"se depois aceder a ``fn.__annotations__``, o objeto criará um novo "
"dicionário vazio que guardará e retornará como as suas anotações. Eliminar "
"as anotações de uma função antes desta ter criado o seu dicionário lançará "
"um ``AttributeError``; usar ``del fn.__annotations__`` duas vezes seguidas "
"garante sempre o lançamento de um ``AttributeError``."

msgid ""
"Everything in the above paragraph also applies to class and module objects "
"in Python 3.10 and newer."
msgstr ""
"Tudo o que foi dito no parágrafo acima também se aplica a objetos de classe "
"e módulo no Python 3.10 e mais recentes."

msgid ""
"In all versions of Python 3, you can set ``__annotations__`` on a function "
"object to ``None``.  However, subsequently accessing the annotations on that "
"object using ``fn.__annotations__`` will lazy-create an empty dictionary as "
"per the first paragraph of this section.  This is *not* true of modules and "
"classes, in any Python version; those objects permit setting "
"``__annotations__`` to any Python value, and will retain whatever value is "
"set."
msgstr ""
"Em todas as versões do Python 3, pode definir ``__annotations__`` num objeto "
"de função como ``None``. No entanto, aceder posteriormente às anotações "
"desse objeto via ``fn.__annotations__`` irá criar um dicionário vazio como "
"explicado no primeiro parágrafo desta secção. Isto *não* se aplica a módulos "
"e classes em nenhuma versão do Python; esses objetos permitem definir "
"``__annotations__`` como qualquer valor Python e manterão esse valor."

msgid ""
"If Python stringizes your annotations for you (using ``from __future__ "
"import annotations``), and you specify a string as an annotation, the string "
"will itself be quoted.  In effect the annotation is quoted *twice.*  For "
"example::"
msgstr ""
"Se o Python converter as suas anotações em strings (usando ``from __future__ "
"import annotations``) e você especificar uma string como anotação, a própria "
"string será colocada entre aspas. Na prática, a anotação será colocada entre "
"aspas *duas vezes*. Por exemplo::"

msgid ""
"from __future__ import annotations\n"
"def foo(a: \"str\"): pass\n"
"\n"
"print(foo.__annotations__)"
msgstr ""
"from __future__ import annotations\n"
"def foo(a: \"str\"): pass\n"
"\n"
"print(foo.__annotations__)"

msgid ""
"This prints ``{'a': \"'str'\"}``.  This shouldn't really be considered a "
"\"quirk\"; it's mentioned here simply because it might be surprising."
msgstr ""
"Isto imprime ``{'a': \"'str'\"}``. Isto não deve ser propriamente "
"considerado uma \"particularidade\"; é mencionado aqui apenas porque pode "
"ser surpreendente."

msgid ""
"If you use a class with a custom metaclass and access ``__annotations__`` on "
"the class, you may observe unexpected behavior; see :pep:`749 <749#pep749-"
"metaclasses>` for some examples. You can avoid these quirks by using :func:"
"`annotationlib.get_annotations` on Python 3.14+ or :func:`inspect."
"get_annotations` on Python 3.10+. On earlier versions of Python, you can "
"avoid these bugs by accessing the annotations from the class's :attr:`~type."
"__dict__` (for example, ``cls.__dict__.get('__annotations__', None)``)."
msgstr ""
"Se usar uma classe com uma metaclasse personalizada e aceder a "
"``__annotations__`` na classe, poderá observar comportamentos inesperados; "
"veja a :pep:`749 <749#pep749-metaclasses>` para alguns exemplos. Pode evitar "
"estas situações usando :func:`annotationlib.get_annotations` no Python 3.14+ "
"ou :func:`inspect.get_annotations` no Python 3.10+. Em versões anteriores do "
"Python, pode evitar estes erros acedendo às anotações através do :attr:"
"`~type.__dict__` da classe (por exemplo, ``cls.__dict__."
"get('__annotations__', None)``)."

msgid ""
"In some versions of Python, instances of classes may have an "
"``__annotations__`` attribute. However, this is not supported functionality. "
"If you need the annotations of an instance, you can use :func:`type` to "
"access its class (for example, ``annotationlib."
"get_annotations(type(myinstance))`` on Python 3.14+)."
msgstr ""
"Em algumas versões do Python, instâncias de classes podem ter um atributo "
"``__annotations__``. No entanto, esta funcionalidade não é suportada. Se "
"precisar das anotações de uma instância, pode usar :func:`type` para aceder "
"à sua classe (por exemplo, ``annotationlib."
"get_annotations(type(myinstance))`` no Python 3.14+)."
