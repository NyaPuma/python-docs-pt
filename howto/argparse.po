# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-05 14:39+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid "Argparse Tutorial"
msgstr "Tutorial do Argparse"

msgid "author"
msgstr "autor"

msgid "Tshepang Mbambo"
msgstr "Tshepang Mbambo"

msgid ""
"This tutorial is intended to be a gentle introduction to :mod:`argparse`, "
"the recommended command-line parsing module in the Python standard library."
msgstr ""
"Este tutorial destina-se a ser uma introdução suave ao :mod:`argparse`, o "
"módulo recomendado para análise de linha de comandos na biblioteca padrão do "
"Python."

msgid ""
"The standard library includes two other libraries directly related to "
"command-line parameter processing: the lower level :mod:`optparse` module "
"(which may require more code to configure for a given application, but also "
"allows an application to request behaviors that ``argparse`` doesn't "
"support), and the very low level :mod:`getopt` (which specifically serves as "
"an equivalent to the :c:func:`!getopt` family of functions available to C "
"programmers). While neither of those modules is covered directly in this "
"guide, many of the core concepts in ``argparse`` first originated in "
"``optparse``, so some aspects of this tutorial will also be relevant to "
"``optparse`` users."
msgstr ""
"A biblioteca padrão inclui outros dois módulos diretamente relacionados ao "
"processamento de parâmetros de linha de comando: o módulo de nível inferior :"
"mod:`optparse` (que pode exigir mais código para configurar uma aplicação, "
"mas também permite que uma aplicação solicite comportamentos que o "
"``argparse`` não suporta) e o módulo de nível muito baixo :mod:`getopt` (que "
"serve especificamente como equivalente à família de funções :c:func:`!"
"getopt` disponíveis para programadores C). Embora nenhum desses módulos seja "
"abordado diretamente neste guia, muitos dos conceitos principais do "
"``argparse`` tiveram origem no ``optparse``, por isso alguns aspetos deste "
"tutorial também serão relevantes para os utilizadores do ``optparse``."

msgid "Concepts"
msgstr "Conceitos"

msgid ""
"Let's show the sort of functionality that we are going to explore in this "
"introductory tutorial by making use of the :command:`ls` command:"
msgstr ""
"Vamos mostrar o tipo de funcionalidade que vamos explorar neste tutorial "
"introdutório utilizando o comando :command:`ls`:"

msgid ""
"$ ls\n"
"cpython  devguide  prog.py  pypy  rm-unused-function.patch\n"
"$ ls pypy\n"
"ctypes_configure  demo  dotviewer  include  lib_pypy  lib-python ...\n"
"$ ls -l\n"
"total 20\n"
"drwxr-xr-x 19 wena wena 4096 Feb 18 18:51 cpython\n"
"drwxr-xr-x  4 wena wena 4096 Feb  8 12:04 devguide\n"
"-rwxr-xr-x  1 wena wena  535 Feb 19 00:05 prog.py\n"
"drwxr-xr-x 14 wena wena 4096 Feb  7 00:59 pypy\n"
"-rw-r--r--  1 wena wena  741 Feb 18 01:01 rm-unused-function.patch\n"
"$ ls --help\n"
"Usage: ls [OPTION]... [FILE]...\n"
"List information about the FILEs (the current directory by default).\n"
"Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n"
"..."
msgstr ""
"$ ls\n"
"cpython  devguide  prog.py  pypy  rm-unused-function.patch\n"
"$ ls pypy\n"
"ctypes_configure  demo  dotviewer  include  lib_pypy  lib-python ...\n"
"$ ls -l\n"
"total 20\n"
"drwxr-xr-x 19 wena wena 4096 Fev 18 18:51 cpython\n"
"drwxr-xr-x  4 wena wena 4096 Fev  8 12:04 devguide\n"
"-rwxr-xr-x  1 wena wena  535 Fev 19 00:05 prog.py\n"
"drwxr-xr-x 14 wena wena 4096 Fev  7 00:59 pypy\n"
"-rw-r--r--  1 wena wena  741 Fev 18 01:01 rm-unused-function.patch\n"
"$ ls --help\n"
"Uso: ls [OPÇÃO]... [FICHEIRO]...\n"
"Lista informações sobre os FICHEIROS (o diretório atual por predefinição).\n"
"Ordena as entradas alfabéticamente se nenhuma das opções -cftuvSUX ou --sort "
"for especificada.\n"
"..."

msgid "A few concepts we can learn from the four commands:"
msgstr "Alguns conceitos que podemos aprender com os quatro comandos:"

msgid ""
"The :command:`ls` command is useful when run without any options at all. It "
"defaults to displaying the contents of the current directory."
msgstr ""
"O comando :command:`ls` é útil quando executado sem quaisquer opções. Por "
"predefinição, mostra o conteúdo do diretório atual."

msgid ""
"If we want beyond what it provides by default, we tell it a bit more. In "
"this case, we want it to display a different directory, ``pypy``. What we "
"did is specify what is known as a positional argument. It's named so because "
"the program should know what to do with the value, solely based on where it "
"appears on the command line. This concept is more relevant to a command "
"like :command:`cp`, whose most basic usage is ``cp SRC DEST``. The first "
"position is *what you want copied,* and the second position is *where you "
"want it copied to*."
msgstr ""
"Se quisermos ir além do que é fornecido por predefinição, temos de lhe dizer "
"um pouco mais. Neste caso, queremos que mostre um diretório diferente, "
"``pypy``. O que fizemos foi especificar o que é conhecido como um argumento "
"posicional. É chamado assim porque o programa deve saber o que fazer com o "
"valor, com base apenas na posição em que aparece na linha de comandos. Este "
"conceito é mais relevante para um comando como :command:`cp`, cujo uso mais "
"básico é ``cp SRC DEST``. A primeira posição é *o que quer copiar*, e a "
"segunda posição é *para onde quer copiar*."

msgid ""
"Now, say we want to change behaviour of the program. In our example, we "
"display more info for each file instead of just showing the file names. The "
"``-l`` in that case is known as an optional argument."
msgstr ""
"Agora, digamos que queremos alterar o comportamento do programa. No nosso "
"exemplo, mostramos mais informações para cada ficheiro em vez de apenas "
"mostrar os nomes dos ficheiros. O ``-l`` nesse caso é conhecido como um "
"argumento opcional."

msgid ""
"That's a snippet of the help text. It's very useful in that you can come "
"across a program you have never used before, and can figure out how it works "
"simply by reading its help text."
msgstr ""
"Este é um trecho do texto de ajuda. É muito útil, pois pode encontrar um "
"programa que nunca usou antes e descobrir como funciona simplesmente lendo o "
"seu texto de ajuda."

msgid "The basics"
msgstr "O básico"

msgid "Let us start with a very simple example which does (almost) nothing::"
msgstr "Vamos começar com um exemplo muito simples que faz (quase) nada:"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.parse_args()"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.parse_args()"

msgid "Following is a result of running the code:"
msgstr "Segue-se o resultado da execução do código:"

msgid ""
"$ python prog.py\n"
"$ python prog.py --help\n"
"usage: prog.py [-h]\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"$ python prog.py --verbose\n"
"usage: prog.py [-h]\n"
"prog.py: error: unrecognized arguments: --verbose\n"
"$ python prog.py foo\n"
"usage: prog.py [-h]\n"
"prog.py: error: unrecognized arguments: foo"
msgstr ""
"$ python prog.py\n"
"$ python prog.py --help\n"
"uso: prog.py [-h]\n"
"\n"
"opções:\n"
"  -h, --help  mostra esta mensagem de ajuda e sai\n"
"$ python prog.py --verbose\n"
"uso: prog.py [-h]\n"
"prog.py: erro: argumentos não reconhecidos: --verbose\n"
"$ python prog.py foo\n"
"uso: prog.py [-h]\n"
"prog.py: erro: argumentos não reconhecidos: foo"

msgid "Here is what is happening:"
msgstr "Aqui está o que está a acontecer:"

msgid ""
"Running the script without any options results in nothing displayed to "
"stdout. Not so useful."
msgstr ""
"Executar o script sem quaisquer opções não resulta em nada exibido no "
"stdout. Não é muito útil."

msgid ""
"The second one starts to display the usefulness of the :mod:`argparse` "
"module. We have done almost nothing, but already we get a nice help message."
msgstr ""
"O segundo começa a mostrar a utilidade do módulo :mod:`argparse`. Não "
"fizemos quase nada, mas já obtemos uma mensagem de ajuda agradável."

msgid ""
"The ``--help`` option, which can also be shortened to ``-h``, is the only "
"option we get for free (i.e. no need to specify it). Specifying anything "
"else results in an error. But even then, we do get a useful usage message, "
"also for free."
msgstr ""
"A opção ``--help``, que também pode ser abreviada para ``-h``, é a única "
"opção que obtemos gratuitamente (ou seja, não é necessário especificá-la). "
"Especificar qualquer outra coisa resulta em um erro. Mas mesmo assim, "
"obtemos uma mensagem de uso útil, também gratuitamente."

msgid "Introducing Positional arguments"
msgstr "Introdução aos argumentos posicionais"

msgid "An example::"
msgstr "Um exemplo:"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"echo\")\n"
"args = parser.parse_args()\n"
"print(args.echo)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"echo\")\n"
"args = parser.parse_args()\n"
"print(args.echo)"

msgid "And running the code:"
msgstr "E executando o código:"

msgid ""
"$ python prog.py\n"
"usage: prog.py [-h] echo\n"
"prog.py: error: the following arguments are required: echo\n"
"$ python prog.py --help\n"
"usage: prog.py [-h] echo\n"
"\n"
"positional arguments:\n"
"  echo\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"$ python prog.py foo\n"
"foo"
msgstr ""
"$ python prog.py\n"
"uso: prog.py [-h] echo\n"
"prog.py: erro: os seguintes argumentos são obrigatórios: echo\n"
"$ python prog.py --help\n"
"uso: prog.py [-h] echo\n"
"\n"
"argumentos posicionais:\n"
"  echo\n"
"\n"
"opções:\n"
"  -h, --help  mostra esta mensagem de ajuda e sai\n"
"$ python prog.py foo\n"
"foo"

msgid "Here is what's happening:"
msgstr "Aqui está o que está a acontecer:"

msgid ""
"We've added the :meth:`~ArgumentParser.add_argument` method, which is what "
"we use to specify which command-line options the program is willing to "
"accept. In this case, I've named it ``echo`` so that it's in line with its "
"function."
msgstr ""
"Adicionámos o método :meth:`~ArgumentParser.add_argument`, que usamos para "
"especificar quais as opções de linha de comandos que o programa está "
"disposto a aceitar. Neste caso, chamei-lhe ``echo`` para que esteja em linha "
"com a sua função."

msgid "Calling our program now requires us to specify an option."
msgstr "Chamar o nosso programa agora exige que especifiquemos uma opção."

msgid ""
"The :meth:`~ArgumentParser.parse_args` method actually returns some data "
"from the options specified, in this case, ``echo``."
msgstr ""
"O método :meth:`~ArgumentParser.parse_args` devolve alguns dados das opções "
"especificadas, neste caso, ``echo``."

msgid ""
"The variable is some form of 'magic' that :mod:`argparse` performs for free "
"(i.e. no need to specify which variable that value is stored in). You will "
"also notice that its name matches the string argument given to the method, "
"``echo``."
msgstr ""
"A variável é uma forma de 'magia' que o :mod:`argparse` realiza "
"gratuitamente (ou seja, não é necessário especificar em que variável esse "
"valor é armazenado). Também notará que o seu nome corresponde ao argumento "
"de string dado ao método, ``echo``."

msgid ""
"Note however that, although the help display looks nice and all, it "
"currently is not as helpful as it can be. For example we see that we got "
"``echo`` as a positional argument, but we don't know what it does, other "
"than by guessing or by reading the source code. So, let's make it a bit more "
"useful::"
msgstr ""
"Note, no entanto, que embora a exibição da ajuda pareça agradável, "
"atualmente não é tão útil quanto poderia ser. Por exemplo, vemos que "
"obtivemos ``echo`` como um argumento posicional, mas não sabemos o que faz, "
"a não ser por adivinhação ou lendo o código-fonte. Vamos torná-lo um pouco "
"mais útil:"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"echo\", help=\"echo the string you use here\")\n"
"args = parser.parse_args()\n"
"print(args.echo)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"echo\", help=\"repete a string que usar aqui\")\n"
"args = parser.parse_args()\n"
"print(args.echo)"

msgid "And we get:"
msgstr "E obtemos:"

msgid ""
"$ python prog.py -h\n"
"usage: prog.py [-h] echo\n"
"\n"
"positional arguments:\n"
"  echo        echo the string you use here\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit"
msgstr ""
"$ python prog.py -h\n"
"uso: prog.py [-h] echo\n"
"\n"
"argumentos posicionais:\n"
"  echo        repete a string que usar aqui\n"
"\n"
"opções:\n"
"  -h, --help  mostra esta mensagem de ajuda e sai"

msgid "Now, how about doing something even more useful::"
msgstr "Agora, que tal fazer algo ainda mais útil:"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", help=\"display a square of a given "
"number\")\n"
"args = parser.parse_args()\n"
"print(args.square**2)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", help=\"mostra o quadrado de um número "
"dado\")\n"
"args = parser.parse_args()\n"
"print(args.square**2)"

msgid ""
"$ python prog.py 4\n"
"Traceback (most recent call last):\n"
"  File \"prog.py\", line 5, in <module>\n"
"    print(args.square**2)\n"
"TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'"
msgstr ""
"$ python prog.py 4\n"
"Traceback (most recent call last):\n"
"  File \"prog.py\", line 5, in <module>\n"
"    print(args.square**2)\n"
"TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'"

msgid ""
"That didn't go so well. That's because :mod:`argparse` treats the options we "
"give it as strings, unless we tell it otherwise. So, let's tell :mod:"
"`argparse` to treat that input as an integer::"
msgstr ""
"Isto não correu bem. Isso acontece porque o :mod:`argparse` trata as opções "
"que lhe damos como strings, a menos que lhe digamos o contrário. Vamos dizer "
"ao :mod:`argparse` para tratar essa entrada como um inteiro:"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", help=\"display a square of a given "
"number\",\n"
"                    type=int)\n"
"args = parser.parse_args()\n"
"print(args.square**2)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", help=\"mostra o quadrado de um número "
"dado\",\n"
"                    type=int)\n"
"args = parser.parse_args()\n"
"print(args.square**2)"

msgid ""
"$ python prog.py 4\n"
"16\n"
"$ python prog.py four\n"
"usage: prog.py [-h] square\n"
"prog.py: error: argument square: invalid int value: 'four'"
msgstr ""
"$ python prog.py 4\n"
"16\n"
"$ python prog.py four\n"
"uso: prog.py [-h] square\n"
"prog.py: erro: argumento square: valor int inválido: 'four'"

msgid ""
"That went well. The program now even helpfully quits on bad illegal input "
"before proceeding."
msgstr ""
"Isso correu bem. O programa agora até termina de forma útil com entrada "
"ilegal inválida antes de continuar."

msgid "Introducing Optional arguments"
msgstr "Introdução aos argumentos opcionais"

msgid ""
"So far we have been playing with positional arguments. Let us have a look on "
"how to add optional ones::"
msgstr ""
"Até agora temos vindo a trabalhar com argumentos posicionais. Vamos ver como "
"adicionar argumentos opcionais:"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"--verbosity\", help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"if args.verbosity:\n"
"    print(\"verbosity turned on\")"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"--verbosity\", help=\"aumenta a verbosidade da "
"saída\")\n"
"args = parser.parse_args()\n"
"if args.verbosity:\n"
"    print(\"verbosidade ativada\")"

msgid "And the output:"
msgstr "E a saída:"

msgid ""
"$ python prog.py --verbosity 1\n"
"verbosity turned on\n"
"$ python prog.py\n"
"$ python prog.py --help\n"
"usage: prog.py [-h] [--verbosity VERBOSITY]\n"
"\n"
"options:\n"
"  -h, --help            show this help message and exit\n"
"  --verbosity VERBOSITY\n"
"                        increase output verbosity\n"
"$ python prog.py --verbosity\n"
"usage: prog.py [-h] [--verbosity VERBOSITY]\n"
"prog.py: error: argument --verbosity: expected one argument"
msgstr ""
"$ python prog.py --verbosity 1\n"
"verbosidade ativada\n"
"$ python prog.py\n"
"$ python prog.py --help\n"
"uso: prog.py [-h] [--verbosity VERBOSITY]\n"
"\n"
"opções:\n"
"  -h, --help            mostra esta mensagem de ajuda e sai\n"
"  --verbosity VERBOSITY\n"
"                        aumenta a verbosidade da saída\n"
"$ python prog.py --verbosity\n"
"uso: prog.py [-h] [--verbosity VERBOSITY]\n"
"prog.py: erro: argumento --verbosity: esperado um argumento"

msgid ""
"The program is written so as to display something when ``--verbosity`` is "
"specified and display nothing when not."
msgstr ""
"O programa está escrito para mostrar algo quando ``--verbosity`` é "
"especificado e não mostrar nada quando não é."

msgid ""
"To show that the option is actually optional, there is no error when running "
"the program without it. Note that by default, if an optional argument isn't "
"used, the relevant variable, in this case ``args.verbosity``, is given "
"``None`` as a value, which is the reason it fails the truth test of the :"
"keyword:`if` statement."
msgstr ""
"Para mostrar que a opção é realmente opcional, não há erro ao executar o "
"programa sem ela. Note que, por predefinição, se um argumento opcional não "
"for usado, a variável relevante, neste caso ``args.verbosity``, recebe o "
"valor ``None``, o que é a razão pela qual falha no teste de verdade da "
"instrução :keyword:`if`."

msgid "The help message is a bit different."
msgstr "A mensagem de ajuda é um pouco diferente."

msgid ""
"When using the ``--verbosity`` option, one must also specify some value, any "
"value."
msgstr ""
"Ao usar a opção ``--verbosity``, deve-se também especificar algum valor, "
"qualquer valor."

msgid ""
"The above example accepts arbitrary integer values for ``--verbosity``, but "
"for our simple program, only two values are actually useful, ``True`` or "
"``False``. Let's modify the code accordingly::"
msgstr ""
"O exemplo acima aceita valores inteiros arbitrários para ``--verbosity``, "
"mas para o nosso programa simples, apenas dois valores são realmente úteis, "
"``True`` ou ``False``. Vamos modificar o código de acordo:"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"--verbose\", help=\"increase output verbosity\",\n"
"                    action=\"store_true\")\n"
"args = parser.parse_args()\n"
"if args.verbose:\n"
"    print(\"verbosity turned on\")"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"--verbose\", help=\"aumenta a verbosidade da saída\",\n"
"                    action=\"store_true\")\n"
"args = parser.parse_args()\n"
"if args.verbose:\n"
"    print(\"verbosidade ativada\")"

msgid ""
"$ python prog.py --verbose\n"
"verbosity turned on\n"
"$ python prog.py --verbose 1\n"
"usage: prog.py [-h] [--verbose]\n"
"prog.py: error: unrecognized arguments: 1\n"
"$ python prog.py --help\n"
"usage: prog.py [-h] [--verbose]\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --verbose   increase output verbosity"
msgstr ""
"$ python prog.py --verbose\n"
"verbosidade ativada\n"
"$ python prog.py --verbose 1\n"
"uso: prog.py [-h] [--verbose]\n"
"prog.py: erro: argumentos não reconhecidos: 1\n"
"$ python prog.py --help\n"
"uso: prog.py [-h] [--verbose]\n"
"\n"
"opções:\n"
"  -h, --help  mostra esta mensagem de ajuda e sai\n"
"  --verbose   aumenta a verbosidade da saída"

msgid ""
"The option is now more of a flag than something that requires a value. We "
"even changed the name of the option to match that idea. Note that we now "
"specify a new keyword, ``action``, and give it the value ``\"store_true\"``. "
"This means that, if the option is specified, assign the value ``True`` to "
"``args.verbose``. Not specifying it implies ``False``."
msgstr ""
"A opção é agora mais uma flag do que algo que requer um valor. Até mudámos o "
"nome da opção para corresponder a essa ideia. Note que agora especificamos "
"uma nova palavra-chave, ``action``, e damos-lhe o valor ``\"store_true\"``. "
"Isto significa que, se a opção for especificada, atribui o valor ``True`` a "
"``args.verbose``. Não a especificar implica ``False``."

msgid ""
"It complains when you specify a value, in true spirit of what flags actually "
"are."
msgstr ""
"Reclama quando especifica um valor, em verdadeiro espírito do que as flags "
"realmente são."

msgid "Notice the different help text."
msgstr "Repare no texto de ajuda diferente."

msgid "Short options"
msgstr "Opções curtas"

msgid ""
"If you are familiar with command line usage, you will notice that I haven't "
"yet touched on the topic of short versions of the options. It's quite "
"simple::"
msgstr ""
"Se estiver familiarizado com o uso da linha de comandos, notará que ainda "
"não abordei o tópico das versões curtas das opções. É bastante simples:"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"-v\", \"--verbose\", help=\"increase output "
"verbosity\",\n"
"                    action=\"store_true\")\n"
"args = parser.parse_args()\n"
"if args.verbose:\n"
"    print(\"verbosity turned on\")"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"-v\", \"--verbose\", help=\"aumenta a verbosidade da "
"saída\",\n"
"                    action=\"store_true\")\n"
"args = parser.parse_args()\n"
"if args.verbose:\n"
"    print(\"verbosidade ativada\")"

msgid "And here goes:"
msgstr "E aqui está:"

msgid ""
"$ python prog.py -v\n"
"verbosity turned on\n"
"$ python prog.py --help\n"
"usage: prog.py [-h] [-v]\n"
"\n"
"options:\n"
"  -h, --help     show this help message and exit\n"
"  -v, --verbose  increase output verbosity"
msgstr ""
"$ python prog.py -v\n"
"verbosidade ativada\n"
"$ python prog.py --help\n"
"uso: prog.py [-h] [-v]\n"
"\n"
"opções:\n"
"  -h, --help     mostra esta mensagem de ajuda e sai\n"
"  -v, --verbose  aumenta a verbosidade da saída"

msgid "Note that the new ability is also reflected in the help text."
msgstr "Note que a nova capacidade também é refletida no texto de ajuda."

msgid "Combining Positional and Optional arguments"
msgstr "Combinar argumentos posicionais e opcionais"

msgid "Our program keeps growing in complexity::"
msgstr "O nosso programa continua a crescer em complexidade:"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\",\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbose:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"mostra o quadrado de um número dado\")\n"
"parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\",\n"
"                    help=\"aumenta a verbosidade da saída\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbose:\n"
"    print(f\"o quadrado de {args.square} é igual a {answer}\")\n"
"else:\n"
"    print(answer)"

msgid "And now the output:"
msgstr "E agora a saída:"

msgid ""
"$ python prog.py\n"
"usage: prog.py [-h] [-v] square\n"
"prog.py: error: the following arguments are required: square\n"
"$ python prog.py 4\n"
"16\n"
"$ python prog.py 4 --verbose\n"
"the square of 4 equals 16\n"
"$ python prog.py --verbose 4\n"
"the square of 4 equals 16"
msgstr ""
"$ python prog.py\n"
"uso: prog.py [-h] [-v] square\n"
"prog.py: erro: os seguintes argumentos são obrigatórios: square\n"
"$ python prog.py 4\n"
"16\n"
"$ python prog.py 4 --verbose\n"
"o quadrado de 4 é igual a 16\n"
"$ python prog.py --verbose 4\n"
"o quadrado de 4 é igual a 16"

msgid "We've brought back a positional argument, hence the complaint."
msgstr "Voltámos a incluir um argumento posicional, daí a reclamação."

msgid "Note that the order does not matter."
msgstr "Note que a ordem não importa."

msgid ""
"How about we give this program of ours back the ability to have multiple "
"verbosity values, and actually get to use them::"
msgstr ""
"Que tal devolvermos a este nosso programa a capacidade de ter múltiplos "
"valores de verbosidade e realmente usá-los:"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", type=int,\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity == 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity == 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"mostra o quadrado de um número dado\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", type=int,\n"
"                    help=\"aumenta a verbosidade da saída\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity == 2:\n"
"    print(f\"o quadrado de {args.square} é igual a {answer}\")\n"
"elif args.verbosity == 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"

msgid ""
"$ python prog.py 4\n"
"16\n"
"$ python prog.py 4 -v\n"
"usage: prog.py [-h] [-v VERBOSITY] square\n"
"prog.py: error: argument -v/--verbosity: expected one argument\n"
"$ python prog.py 4 -v 1\n"
"4^2 == 16\n"
"$ python prog.py 4 -v 2\n"
"the square of 4 equals 16\n"
"$ python prog.py 4 -v 3\n"
"16"
msgstr ""
"$ python prog.py 4\n"
"16\n"
"$ python prog.py 4 -v\n"
"uso: prog.py [-h] [-v VERBOSITY] square\n"
"prog.py: erro: argumento -v/--verbosity: esperado um argumento\n"
"$ python prog.py 4 -v 1\n"
"4^2 == 16\n"
"$ python prog.py 4 -v 2\n"
"o quadrado de 4 é igual a 16\n"
"$ python prog.py 4 -v 3\n"
"16"

msgid ""
"These all look good except the last one, which exposes a bug in our program. "
"Let's fix it by restricting the values the ``--verbosity`` option can "
"accept::"
msgstr ""
"Todos parecem bons, exceto o último, que expõe um bug no nosso programa. "
"Vamos corrigi-lo restringindo os valores que a opção ``--verbosity`` pode "
"aceitar:"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", type=int, choices=[0, 1, 2],\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity == 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity == 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"mostra o quadrado de um número dado\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", type=int, choices=[0, 1, 2],\n"
"                    help=\"aumenta a verbosidade da saída\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity == 2:\n"
"    print(f\"o quadrado de {args.square} é igual a {answer}\")\n"
"elif args.verbosity == 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"

msgid ""
"$ python prog.py 4 -v 3\n"
"usage: prog.py [-h] [-v {0,1,2}] square\n"
"prog.py: error: argument -v/--verbosity: invalid choice: 3 (choose from 0, "
"1, 2)\n"
"$ python prog.py 4 -h\n"
"usage: prog.py [-h] [-v {0,1,2}] square\n"
"\n"
"positional arguments:\n"
"  square                display a square of a given number\n"
"\n"
"options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbosity {0,1,2}\n"
"                        increase output verbosity"
msgstr ""
"$ python prog.py 4 -v 3\n"
"uso: prog.py [-h] [-v {0,1,2}] square\n"
"prog.py: erro: argumento -v/--verbosity: escolha inválida: 3 (escolha entre "
"0, 1, 2)\n"
"$ python prog.py 4 -h\n"
"uso: prog.py [-h] [-v {0,1,2}] square\n"
"\n"
"argumentos posicionais:\n"
"  square                mostra o quadrado de um número dado\n"
"\n"
"opções:\n"
"  -h, --help            mostra esta mensagem de ajuda e sai\n"
"  -v, --verbosity {0,1,2}\n"
"                        aumenta a verbosidade da saída"

msgid ""
"Note that the change also reflects both in the error message as well as the "
"help string."
msgstr ""
"Note que a alteração também se reflete tanto na mensagem de erro como na "
"string de ajuda."

msgid ""
"Now, let's use a different approach of playing with verbosity, which is "
"pretty common. It also matches the way the CPython executable handles its "
"own verbosity argument (check the output of ``python --help``)::"
msgstr ""
"Agora, vamos usar uma abordagem diferente para lidar com a verbosidade, que "
"é bastante comum. Também corresponde à forma como o executável CPython trata "
"o seu próprio argumento de verbosidade (verifique a saída de ``python --"
"help``):"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display the square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\",\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity == 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity == 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"mostra o quadrado de um número dado\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\",\n"
"                    help=\"aumenta a verbosidade da saída\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity == 2:\n"
"    print(f\"o quadrado de {args.square} é igual a {answer}\")\n"
"elif args.verbosity == 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"

msgid ""
"We have introduced another action, \"count\", to count the number of "
"occurrences of specific options."
msgstr ""
"Introduzimos outra ação, \"count\", para contar o número de ocorrências de "
"opções específicas."

msgid ""
"$ python prog.py 4\n"
"16\n"
"$ python prog.py 4 -v\n"
"4^2 == 16\n"
"$ python prog.py 4 -vv\n"
"the square of 4 equals 16\n"
"$ python prog.py 4 --verbosity --verbosity\n"
"the square of 4 equals 16\n"
"$ python prog.py 4 -v 1\n"
"usage: prog.py [-h] [-v] square\n"
"prog.py: error: unrecognized arguments: 1\n"
"$ python prog.py 4 -h\n"
"usage: prog.py [-h] [-v] square\n"
"\n"
"positional arguments:\n"
"  square           display a square of a given number\n"
"\n"
"options:\n"
"  -h, --help       show this help message and exit\n"
"  -v, --verbosity  increase output verbosity\n"
"$ python prog.py 4 -vvv\n"
"16"
msgstr ""
"$ python prog.py 4\n"
"16\n"
"$ python prog.py 4 -v\n"
"4^2 == 16\n"
"$ python prog.py 4 -vv\n"
"o quadrado de 4 é igual a 16\n"
"$ python prog.py 4 --verbosity --verbosity\n"
"o quadrado de 4 é igual a 16\n"
"$ python prog.py 4 -v 1\n"
"uso: prog.py [-h] [-v] square\n"
"prog.py: erro: argumentos não reconhecidos: 1\n"
"$ python prog.py 4 -h\n"
"uso: prog.py [-h] [-v] square\n"
"\n"
"argumentos posicionais:\n"
"  square           mostra o quadrado de um número dado\n"
"\n"
"opções:\n"
"  -h, --help       mostra esta mensagem de ajuda e sai\n"
"  -v, --verbosity  aumenta a verbosidade da saída\n"
"$ python prog.py 4 -vvv\n"
"16"

msgid ""
"Yes, it's now more of a flag (similar to ``action=\"store_true\"``) in the "
"previous version of our script. That should explain the complaint."
msgstr ""
"Sim, agora é mais uma flag (semelhante a ``action=\"store_true\"``) na "
"versão anterior do nosso script. Isso deve explicar a reclamação."

msgid "It also behaves similar to \"store_true\" action."
msgstr "Também se comporta de forma semelhante à ação \"store_true\"."

msgid ""
"Now here's a demonstration of what the \"count\" action gives. You've "
"probably seen this sort of usage before."
msgstr ""
"Aqui está uma demonstração do que a ação \"count\" oferece. Provavelmente já "
"viu este tipo de uso antes."

msgid ""
"And if you don't specify the ``-v`` flag, that flag is considered to have "
"``None`` value."
msgstr ""
"E se não especificar a flag ``-v``, essa flag é considerada como tendo o "
"valor ``None``."

msgid ""
"As should be expected, specifying the long form of the flag, we should get "
"the same output."
msgstr ""
"Como seria de esperar, ao especificar a forma longa da flag, devemos obter a "
"mesma saída."

msgid ""
"Sadly, our help output isn't very informative on the new ability our script "
"has acquired, but that can always be fixed by improving the documentation "
"for our script (e.g. via the ``help`` keyword argument)."
msgstr ""
"Infelizmente, a nossa saída de ajuda não é muito informativa sobre a nova "
"capacidade que o nosso script adquiriu, mas isso pode sempre ser corrigido "
"melhorando a documentação do nosso script (por exemplo, através do argumento "
"``help``)."

msgid "That last output exposes a bug in our program."
msgstr "A última saída expõe um bug no nosso programa."

msgid "Let's fix::"
msgstr "Vamos corrigir:"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\",\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"\n"
"# bugfix: replace == with >=\n"
"if args.verbosity >= 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity >= 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"mostra o quadrado de um número dado\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\",\n"
"                    help=\"aumenta a verbosidade da saída\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"\n"
"# correção: substituir == por >=\n"
"if args.verbosity >= 2:\n"
"    print(f\"o quadrado de {args.square} é igual a {answer}\")\n"
"elif args.verbosity >= 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"

msgid "And this is what it gives:"
msgstr "E isto é o que produz:"

msgid ""
"$ python prog.py 4 -vvv\n"
"the square of 4 equals 16\n"
"$ python prog.py 4 -vvvv\n"
"the square of 4 equals 16\n"
"$ python prog.py 4\n"
"Traceback (most recent call last):\n"
"  File \"prog.py\", line 11, in <module>\n"
"    if args.verbosity >= 2:\n"
"TypeError: '>=' not supported between instances of 'NoneType' and 'int'"
msgstr ""
"$ python prog.py 4 -vvv\n"
"o quadrado de 4 é igual a 16\n"
"$ python prog.py 4 -vvvv\n"
"o quadrado de 4 é igual a 16\n"
"$ python prog.py 4\n"
"Traceback (most recent call last):\n"
"  File \"prog.py\", line 11, in <module>\n"
"    if args.verbosity >= 2:\n"
"TypeError: '>=' não é suportado entre instâncias de 'NoneType' e 'int'"

msgid ""
"First output went well, and fixes the bug we had before. That is, we want "
"any value >= 2 to be as verbose as possible."
msgstr ""
"A primeira saída correu bem e corrige o bug que tínhamos antes. Ou seja, "
"queremos que qualquer valor >= 2 seja o mais verboso possível."

msgid "Third output not so good."
msgstr "A terceira saída não está tão boa."

msgid "Let's fix that bug::"
msgstr "Vamos corrigir esse bug:"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0,\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity >= 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity >= 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"mostra o quadrado de um número dado\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0,\n"
"                    help=\"aumenta a verbosidade da saída\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity >= 2:\n"
"    print(f\"o quadrado de {args.square} é igual a {answer}\")\n"
"elif args.verbosity >= 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"

msgid ""
"We've just introduced yet another keyword, ``default``. We've set it to "
"``0`` in order to make it comparable to the other int values. Remember that "
"by default, if an optional argument isn't specified, it gets the ``None`` "
"value, and that cannot be compared to an int value (hence the :exc:"
"`TypeError` exception)."
msgstr ""
"Acabámos de introduzir mais uma palavra-chave, ``default``. Definimo-la para "
"``0`` para que seja comparável a outros valores inteiros. Lembre-se de que, "
"por predefinição, se um argumento opcional não for especificado, recebe o "
"valor ``None``, e isso não pode ser comparado a um valor inteiro (daí a "
"exceção :exc:`TypeError`)."

msgid "And:"
msgstr "E:"

msgid ""
"$ python prog.py 4\n"
"16"
msgstr ""
"$ python prog.py 4\n"
"16"

msgid ""
"You can go quite far just with what we've learned so far, and we have only "
"scratched the surface. The :mod:`argparse` module is very powerful, and "
"we'll explore a bit more of it before we end this tutorial."
msgstr ""
"Pode ir bastante longe apenas com o que aprendemos até agora, e só "
"arranhamos a superfície. O módulo :mod:`argparse` é muito poderoso, e vamos "
"explorar um pouco mais antes de terminar este tutorial."

msgid "Getting a little more advanced"
msgstr "Avançando um pouco mais"

msgid ""
"What if we wanted to expand our tiny program to perform other powers, not "
"just squares::"
msgstr ""
"E se quiséssemos expandir o nosso pequeno programa para realizar outras "
"potências, não apenas quadrados:"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"x\", type=int, help=\"the base\")\n"
"parser.add_argument(\"y\", type=int, help=\"the exponent\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0)\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"if args.verbosity >= 2:\n"
"    print(f\"{args.x} to the power {args.y} equals {answer}\")\n"
"elif args.verbosity >= 1:\n"
"    print(f\"{args.x}^{args.y} == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"x\", type=int, help=\"a base\")\n"
"parser.add_argument(\"y\", type=int, help=\"o expoente\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0)\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"if args.verbosity >= 2:\n"
"    print(f\"{args.x} elevado a {args.y} é igual a {answer}\")\n"
"elif args.verbosity >= 1:\n"
"    print(f\"{args.x}^{args.y} == {answer}\")\n"
"else:\n"
"    print(answer)"

msgid "Output:"
msgstr "Saída:"

msgid ""
"$ python prog.py\n"
"usage: prog.py [-h] [-v] x y\n"
"prog.py: error: the following arguments are required: x, y\n"
"$ python prog.py -h\n"
"usage: prog.py [-h] [-v] x y\n"
"\n"
"positional arguments:\n"
"  x                the base\n"
"  y                the exponent\n"
"\n"
"options:\n"
"  -h, --help       show this help message and exit\n"
"  -v, --verbosity\n"
"$ python prog.py 4 2 -v\n"
"4^2 == 16"
msgstr ""
"$ python prog.py\n"
"uso: prog.py [-h] [-v] x y\n"
"prog.py: erro: os seguintes argumentos são obrigatórios: x, y\n"
"$ python prog.py -h\n"
"uso: prog.py [-h] [-v] x y\n"
"\n"
"argumentos posicionais:\n"
"  x                a base\n"
"  y                o expoente\n"
"\n"
"opções:\n"
"  -h, --help       mostra esta mensagem de ajuda e sai\n"
"  -v, --verbosity\n"
"$ python prog.py 4 2 -v\n"
"4^2 == 16"

msgid ""
"Notice that so far we've been using verbosity level to *change* the text "
"that gets displayed. The following example instead uses verbosity level to "
"display *more* text instead::"
msgstr ""
"Note que até agora temos usado o nível de verbosidade para *alterar* o texto "
"que é exibido. O exemplo seguinte usa o nível de verbosidade para exibir "
"*mais* texto:"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"x\", type=int, help=\"the base\")\n"
"parser.add_argument(\"y\", type=int, help=\"the exponent\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0)\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"if args.verbosity >= 2:\n"
"    print(f\"Running '{__file__}'\")\n"
"if args.verbosity >= 1:\n"
"    print(f\"{args.x}^{args.y} == \", end=\"\")\n"
"print(answer)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"x\", type=int, help=\"a base\")\n"
"parser.add_argument(\"y\", type=int, help=\"o expoente\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0)\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"if args.verbosity >= 2:\n"
"    print(f\"A executar '{__file__}'\")\n"
"if args.verbosity >= 1:\n"
"    print(f\"{args.x}^{args.y} == \", end=\"\")\n"
"print(answer)"

msgid ""
"$ python prog.py 4 2\n"
"16\n"
"$ python prog.py 4 2 -v\n"
"4^2 == 16\n"
"$ python prog.py 4 2 -vv\n"
"Running 'prog.py'\n"
"4^2 == 16"
msgstr ""
"$ python prog.py 4 2\n"
"16\n"
"$ python prog.py 4 2 -v\n"
"4^2 == 16\n"
"$ python prog.py 4 2 -vv\n"
"A executar 'prog.py'\n"
"4^2 == 16"

msgid "Specifying ambiguous arguments"
msgstr "Especificar argumentos ambíguos"

msgid ""
"When there is ambiguity in deciding whether an argument is positional or for "
"an argument, ``--`` can be used to tell :meth:`~ArgumentParser.parse_args` "
"that everything after that is a positional argument::"
msgstr ""
"Quando há ambiguidade ao decidir se um argumento é posicional ou não, ``--`` "
"pode ser usado para indicar ao :meth:`~ArgumentParser.parse_args` que tudo o "
"que vem depois é um argumento posicional:"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-n', nargs='+')\n"
">>> parser.add_argument('args', nargs='*')\n"
"\n"
">>> # ambiguous, so parse_args assumes it's an option\n"
">>> parser.parse_args(['-f'])\n"
"usage: PROG [-h] [-n N [N ...]] [args ...]\n"
"PROG: error: unrecognized arguments: -f\n"
"\n"
">>> parser.parse_args(['--', '-f'])\n"
"Namespace(args=['-f'], n=None)\n"
"\n"
">>> # ambiguous, so the -n option greedily accepts arguments\n"
">>> parser.parse_args(['-n', '1', '2', '3'])\n"
"Namespace(args=[], n=['1', '2', '3'])\n"
"\n"
">>> parser.parse_args(['-n', '1', '--', '2', '3'])\n"
"Namespace(args=['2', '3'], n=['1'])"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-n', nargs='+')\n"
">>> parser.add_argument('args', nargs='*')\n"
"\n"
">>> # ambíguo, então parse_args assume que é uma opção\n"
">>> parser.parse_args(['-f'])\n"
"uso: PROG [-h] [-n N [N ...]] [args ...]\n"
"PROG: erro: argumentos não reconhecidos: -f\n"
"\n"
">>> parser.parse_args(['--', '-f'])\n"
"Namespace(args=['-f'], n=None)\n"
"\n"
">>> # ambíguo, então a opção -n aceita avidamente argumentos\n"
">>> parser.parse_args(['-n', '1', '2', '3'])\n"
"Namespace(args=[], n=['1', '2', '3'])\n"
"\n"
">>> parser.parse_args(['-n', '1', '--', '2', '3'])\n"
"Namespace(args=['2', '3'], n=['1'])"

msgid "Conflicting options"
msgstr "Opções conflitantes"

msgid ""
"So far, we have been working with two methods of an :class:`argparse."
"ArgumentParser` instance. Let's introduce a third one, :meth:"
"`~ArgumentParser.add_mutually_exclusive_group`. It allows for us to specify "
"options that conflict with each other. Let's also change the rest of the "
"program so that the new functionality makes more sense: we'll introduce the "
"``--quiet`` option, which will be the opposite of the ``--verbose`` one::"
msgstr ""
"Até agora, temos vindo a trabalhar com dois métodos de uma instância :class:"
"`argparse.ArgumentParser`. Vamos introduzir um terceiro, :meth:"
"`~ArgumentParser.add_mutually_exclusive_group`. Ele permite-nos especificar "
"opções que conflitam entre si. Vamos também alterar o resto do programa para "
"que a nova funcionalidade faça mais sentido: vamos introduzir a opção ``--"
"quiet``, que será o oposto da ``--verbose``:"

msgid ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"group = parser.add_mutually_exclusive_group()\n"
"group.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n"
"group.add_argument(\"-q\", \"--quiet\", action=\"store_true\")\n"
"parser.add_argument(\"x\", type=int, help=\"the base\")\n"
"parser.add_argument(\"y\", type=int, help=\"the exponent\")\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"\n"
"if args.quiet:\n"
"    print(answer)\n"
"elif args.verbose:\n"
"    print(f\"{args.x} to the power {args.y} equals {answer}\")\n"
"else:\n"
"    print(f\"{args.x}^{args.y} == {answer}\")"
msgstr ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"group = parser.add_mutually_exclusive_group()\n"
"group.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n"
"group.add_argument(\"-q\", \"--quiet\", action=\"store_true\")\n"
"parser.add_argument(\"x\", type=int, help=\"a base\")\n"
"parser.add_argument(\"y\", type=int, help=\"o expoente\")\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"\n"
"if args.quiet:\n"
"    print(answer)\n"
"elif args.verbose:\n"
"    print(f\"{args.x} elevado a {args.y} é igual a {answer}\")\n"
"else:\n"
"    print(f\"{args.x}^{args.y} == {answer}\")"

msgid ""
"Our program is now simpler, and we've lost some functionality for the sake "
"of demonstration. Anyways, here's the output:"
msgstr ""
"O nosso programa é agora mais simples, e perdemos alguma funcionalidade em "
"prol da demonstração. De qualquer forma, aqui está a saída:"

msgid ""
"$ python prog.py 4 2\n"
"4^2 == 16\n"
"$ python prog.py 4 2 -q\n"
"16\n"
"$ python prog.py 4 2 -v\n"
"4 to the power 2 equals 16\n"
"$ python prog.py 4 2 -vq\n"
"usage: prog.py [-h] [-v | -q] x y\n"
"prog.py: error: argument -q/--quiet: not allowed with argument -v/--verbose\n"
"$ python prog.py 4 2 -v --quiet\n"
"usage: prog.py [-h] [-v | -q] x y\n"
"prog.py: error: argument -q/--quiet: not allowed with argument -v/--verbose"
msgstr ""
"$ python prog.py 4 2\n"
"4^2 == 16\n"
"$ python prog.py 4 2 -q\n"
"16\n"
"$ python prog.py 4 2 -v\n"
"4 elevado a 2 é igual a 16\n"
"$ python prog.py 4 2 -vq\n"
"uso: prog.py [-h] [-v | -q] x y\n"
"prog.py: erro: argumento -q/--quiet: não permitido com argumento -v/--"
"verbose\n"
"$ python prog.py 4 2 -v --quiet\n"
"uso: prog.py [-h] [-v | -q] x y\n"
"prog.py: erro: argumento -q/--quiet: não permitido com argumento -v/--verbose"

msgid ""
"That should be easy to follow. I've added that last output so you can see "
"the sort of flexibility you get, i.e. mixing long form options with short "
"form ones."
msgstr ""
"Isso deve ser fácil de seguir. Adicionei essa última saída para que possa "
"ver o tipo de flexibilidade que obtém, ou seja, misturar opções de forma "
"longa com formas curtas."

msgid ""
"Before we conclude, you probably want to tell your users the main purpose of "
"your program, just in case they don't know::"
msgstr ""
"Antes de concluirmos, provavelmente quer informar os seus utilizadores sobre "
"o objetivo principal do seu programa, caso não saibam:"

msgid ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser(description=\"calculate X to the power of "
"Y\")\n"
"group = parser.add_mutually_exclusive_group()\n"
"group.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n"
"group.add_argument(\"-q\", \"--quiet\", action=\"store_true\")\n"
"parser.add_argument(\"x\", type=int, help=\"the base\")\n"
"parser.add_argument(\"y\", type=int, help=\"the exponent\")\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"\n"
"if args.quiet:\n"
"    print(answer)\n"
"elif args.verbose:\n"
"    print(f\"{args.x} to the power {args.y} equals {answer}\")\n"
"else:\n"
"    print(f\"{args.x}^{args.y} == {answer}\")"
msgstr ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser(description=\"calcular X elevado a Y\")\n"
"group = parser.add_mutually_exclusive_group()\n"
"group.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n"
"group.add_argument(\"-q\", \"--quiet\", action=\"store_true\")\n"
"parser.add_argument(\"x\", type=int, help=\"a base\")\n"
"parser.add_argument(\"y\", type=int, help=\"o expoente\")\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"\n"
"if args.quiet:\n"
"    print(answer)\n"
"elif args.verbose:\n"
"    print(f\"{args.x} elevado a {args.y} é igual a {answer}\")\n"
"else:\n"
"    print(f\"{args.x}^{args.y} == {answer}\")"

msgid ""
"Note that slight difference in the usage text. Note the ``[-v | -q]``, which "
"tells us that we can either use ``-v`` or ``-q``, but not both at the same "
"time:"
msgstr ""
"Note a pequena diferença no texto de uso. Note o ``[-v | -q]``, que nos diz "
"que podemos usar ``-v`` ou ``-q``, mas não ambos ao mesmo tempo:"

msgid ""
"$ python prog.py --help\n"
"usage: prog.py [-h] [-v | -q] x y\n"
"\n"
"calculate X to the power of Y\n"
"\n"
"positional arguments:\n"
"  x              the base\n"
"  y              the exponent\n"
"\n"
"options:\n"
"  -h, --help     show this help message and exit\n"
"  -v, --verbose\n"
"  -q, --quiet"
msgstr ""
"$ python prog.py --help\n"
"uso: prog.py [-h] [-v | -q] x y\n"
"\n"
"calcular X elevado a Y\n"
"\n"
"argumentos posicionais:\n"
"  x              a base\n"
"  y              o expoente\n"
"\n"
"opções:\n"
"  -h, --help     mostra esta mensagem de ajuda e sai\n"
"  -v, --verbose\n"
"  -q, --quiet"

msgid "How to translate the argparse output"
msgstr "Como traduzir a saída do argparse"

msgid ""
"The output of the :mod:`argparse` module such as its help text and error "
"messages are all made translatable using the :mod:`gettext` module. This "
"allows applications to easily localize messages produced by :mod:`argparse`. "
"See also :ref:`i18n-howto`."
msgstr ""
"A saída do módulo :mod:`argparse`, como o seu texto de ajuda e mensagens de "
"erro, são todas tornadas traduzíveis usando o módulo :mod:`gettext`. Isto "
"permite que as aplicações localizem facilmente as mensagens produzidas pelo :"
"mod:`argparse`. Veja também :ref:`i18n-howto`."

msgid "For instance, in this :mod:`argparse` output:"
msgstr "Por exemplo, nesta saída do :mod:`argparse`:"

msgid ""
"The strings ``usage:``, ``positional arguments:``, ``options:`` and ``show "
"this help message and exit`` are all translatable."
msgstr ""
"As strings ``usage:``, ``positional arguments:``, ``options:`` e ``show this "
"help message and exit`` são todas traduzíveis."

msgid ""
"In order to translate these strings, they must first be extracted into a ``."
"po`` file. For example, using `Babel <https://babel.pocoo.org/>`__, run this "
"command:"
msgstr ""
"Para traduzir estas strings, elas devem primeiro ser extraídas para um "
"ficheiro ``.po``. Por exemplo, usando o `Babel <https://babel.pocoo.org/"
">`__, execute este comando:"

msgid "$ pybabel extract -o messages.po /usr/lib/python3.12/argparse.py"
msgstr "$ pybabel extract -o messages.po /usr/lib/python3.12/argparse.py"

msgid ""
"This command will extract all translatable strings from the :mod:`argparse` "
"module and output them into a file named ``messages.po``. This command "
"assumes that your Python installation is in ``/usr/lib``."
msgstr ""
"Este comando extrairá todas as strings traduzíveis do módulo :mod:`argparse` "
"e colocá-las-á num ficheiro chamado ``messages.po``. Este comando assume que "
"a sua instalação do Python está em ``/usr/lib``."

msgid ""
"You can find out the location of the :mod:`argparse` module on your system "
"using this script::"
msgstr ""
"Pode descobrir a localização do módulo :mod:`argparse` no seu sistema usando "
"este script:"

msgid ""
"import argparse\n"
"print(argparse.__file__)"
msgstr ""
"import argparse\n"
"print(argparse.__file__)"

msgid ""
"Once the messages in the ``.po`` file are translated and the translations "
"are installed using :mod:`gettext`, :mod:`argparse` will be able to display "
"the translated messages."
msgstr ""
"Uma vez que as mensagens no ficheiro ``.po`` estejam traduzidas e as "
"traduções estejam instaladas usando o :mod:`gettext`, o :mod:`argparse` será "
"capaz de exibir as mensagens traduzidas."

msgid ""
"To translate your own strings in the :mod:`argparse` output, use :mod:"
"`gettext`."
msgstr ""
"Para traduzir as suas próprias strings na saída do :mod:`argparse`, use :mod:"
"`gettext`."

msgid "Custom type converters"
msgstr "Conversores de tipo personalizados"

msgid ""
"The :mod:`argparse` module allows you to specify custom type converters for "
"your command-line arguments. This allows you to modify user input before "
"it's stored in the :class:`argparse.Namespace`. This can be useful when you "
"need to pre-process the input before it is used in your program."
msgstr ""
"O módulo :mod:`argparse` permite-lhe especificar conversores de tipo "
"personalizados para os seus argumentos de linha de comandos. Isto permite-"
"lhe modificar a entrada do utilizador antes de ser armazenada no :class:"
"`argparse.Namespace`. Isto pode ser útil quando precisa de pré-processar a "
"entrada antes de ser usada no seu programa."

msgid ""
"When using a custom type converter, you can use any callable that takes a "
"single string argument (the argument value) and returns the converted value. "
"However, if you need to handle more complex scenarios, you can use a custom "
"action class with the **action** parameter instead."
msgstr ""
"Ao usar um conversor de tipo personalizado, pode usar qualquer função que "
"aceite um único argumento de string (o valor do argumento) e retorne o valor "
"convertido. No entanto, se precisar de lidar com cenários mais complexos, "
"pode usar uma classe de ação personalizada com o parâmetro **action**."

msgid ""
"For example, let's say you want to handle arguments with different prefixes "
"and process them accordingly::"
msgstr ""
"Por exemplo, digamos que quer lidar com argumentos com diferentes prefixos e "
"processá-los de acordo:"

msgid ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser(prefix_chars='-+')\n"
"\n"
"parser.add_argument('-a', metavar='<value>', action='append',\n"
"                    type=lambda x: ('-', x))\n"
"parser.add_argument('+a', metavar='<value>', action='append',\n"
"                    type=lambda x: ('+', x))\n"
"\n"
"args = parser.parse_args()\n"
"print(args)"
msgstr ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser(prefix_chars='-+')\n"
"\n"
"parser.add_argument('-a', metavar='<valor>', action='append',\n"
"                    type=lambda x: ('-', x))\n"
"parser.add_argument('+a', metavar='<valor>', action='append',\n"
"                    type=lambda x: ('+', x))\n"
"\n"
"args = parser.parse_args()\n"
"print(args)"

msgid ""
"$ python prog.py -a value1 +a value2\n"
"Namespace(a=[('-', 'value1'), ('+', 'value2')])"
msgstr ""
"$ python prog.py -a valor1 +a valor2\n"
"Namespace(a=[('-', 'valor1'), ('+', 'valor2')])"

msgid "In this example, we:"
msgstr "Neste exemplo, nós:"

msgid ""
"Created a parser with custom prefix characters using the ``prefix_chars`` "
"parameter."
msgstr ""
"Criámos um parser com caracteres de prefixo personalizados usando o "
"parâmetro ``prefix_chars``."

msgid ""
"Defined two arguments, ``-a`` and ``+a``, which used the ``type`` parameter "
"to create custom type converters to store the value in a tuple with the "
"prefix."
msgstr ""
"Definimos dois argumentos, ``-a`` e ``+a``, que usaram o parâmetro ``type`` "
"para criar conversores de tipo personalizados para armazenar o valor num "
"tuplo com o prefixo."

msgid ""
"Without the custom type converters, the arguments would have treated the ``-"
"a`` and ``+a`` as the same argument, which would have been undesirable. By "
"using custom type converters, we were able to differentiate between the two "
"arguments."
msgstr ""
"Sem os conversores de tipo personalizados, os argumentos teriam tratado ``-"
"a`` e ``+a`` como o mesmo argumento, o que seria indesejável. Ao usar "
"conversores de tipo personalizados, conseguimos diferenciar entre os dois "
"argumentos."

msgid "Conclusion"
msgstr "Conclusão"

msgid ""
"The :mod:`argparse` module offers a lot more than shown here. Its docs are "
"quite detailed and thorough, and full of examples. Having gone through this "
"tutorial, you should easily digest them without feeling overwhelmed."
msgstr ""
"O módulo :mod:`argparse` oferece muito mais do que foi mostrado aqui. A sua "
"documentação é bastante detalhada e completa, e cheia de exemplos. Depois de "
"passar por este tutorial, deve conseguir assimilá-los sem se sentir "
"sobrecarregado."
