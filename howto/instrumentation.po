# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-01 14:20+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid "Instrumenting CPython with DTrace and SystemTap"
msgstr "Instrumentar o CPython com DTrace e SystemTap"

msgid "author"
msgstr "autor"

msgid "David Malcolm"
msgstr "David Malcolm"

msgid "Łukasz Langa"
msgstr "Łukasz Langa"

msgid ""
"DTrace and SystemTap are monitoring tools, each providing a way to inspect "
"what the processes on a computer system are doing.  They both use domain-"
"specific languages allowing a user to write scripts which:"
msgstr ""
"O DTrace e o SystemTap são ferramentas de monitorização, fornecendo cada uma "
"forma de inspecionar o que os processos num sistema informático estão a "
"fazer. Ambas utilizam linguagens específicas de domínio que permitem ao "
"utilizador escrever scripts que:"

msgid "filter which processes are to be observed"
msgstr "filtram quais os processos a serem observados"

msgid "gather data from the processes of interest"
msgstr "recolhem dados dos processos de interesse"

msgid "generate reports on the data"
msgstr "geram relatórios sobre os dados"

msgid ""
"As of Python 3.6, CPython can be built with embedded \"markers\", also known "
"as \"probes\", that can be observed by a DTrace or SystemTap script, making "
"it easier to monitor what the CPython processes on a system are doing."
msgstr ""
"A partir do Python 3.6, o CPython pode ser compilado com \"marcadores\" "
"embutidos, também conhecidos como \"probes\", que podem ser observados por "
"um script DTrace ou SystemTap, facilitando a monitorização do que os "
"processos CPython num sistema estão a fazer."

msgid ""
"DTrace markers are implementation details of the CPython interpreter. No "
"guarantees are made about probe compatibility between versions of CPython. "
"DTrace scripts can stop working or work incorrectly without warning when "
"changing CPython versions."
msgstr ""
"Os marcadores DTrace são detalhes de implementação do intérprete CPython. "
"Não são dadas garantias sobre a compatibilidade das probes entre versões do "
"CPython. Os scripts DTrace podem deixar de funcionar ou funcionar "
"incorretamente sem aviso prévio ao mudar de versão do CPython."

msgid "Enabling the static markers"
msgstr "Ativar os marcadores estáticos"

msgid ""
"macOS comes with built-in support for DTrace.  On Linux, in order to build "
"CPython with the embedded markers for SystemTap, the SystemTap development "
"tools must be installed."
msgstr ""
"O macOS traz suporte nativo para DTrace. No Linux, para compilar o CPython "
"com marcadores embutidos para SystemTap, as ferramentas de desenvolvimento "
"do SystemTap devem estar instaladas."

msgid "On a Linux machine, this can be done via::"
msgstr "Numa máquina Linux, isto pode ser feito através de::"

msgid "$ yum install systemtap-sdt-devel"
msgstr "$ yum install systemtap-sdt-devel"

msgid "or::"
msgstr "ou:"

msgid "$ sudo apt-get install systemtap-sdt-dev"
msgstr "$ sudo apt-get install systemtap-sdt-dev"

msgid ""
"CPython must then be :option:`configured with the --with-dtrace option <--"
"with-dtrace>`:"
msgstr ""
"O CPython deve então ser :option:`configurado com a opção --with-dtrace <--"
"with-dtrace>`:"

msgid "checking for --with-dtrace... yes"
msgstr "checking for --with-dtrace... yes"

msgid ""
"On macOS, you can list available DTrace probes by running a Python process "
"in the background and listing all probes made available by the Python "
"provider::"
msgstr ""
"No macOS, pode listar as probes DTrace disponíveis executando um processo "
"Python em background e listando todas as probes disponibilizadas pelo "
"provider Python::"

msgid ""
"$ python3.6 -q &\n"
"$ sudo dtrace -l -P python$!  # or: dtrace -l -m python3.6\n"
"\n"
"   ID   PROVIDER            MODULE                          FUNCTION NAME\n"
"29564 python18035        python3.6          _PyEval_EvalFrameDefault "
"function-entry\n"
"29565 python18035        python3.6             dtrace_function_entry "
"function-entry\n"
"29566 python18035        python3.6          _PyEval_EvalFrameDefault "
"function-return\n"
"29567 python18035        python3.6            dtrace_function_return "
"function-return\n"
"29568 python18035        python3.6                           collect gc-"
"done\n"
"29569 python18035        python3.6                           collect gc-"
"start\n"
"29570 python18035        python3.6          _PyEval_EvalFrameDefault line\n"
"29571 python18035        python3.6                 maybe_dtrace_line line"
msgstr ""

msgid ""
"On Linux, you can verify if the SystemTap static markers are present in the "
"built binary by seeing if it contains a \".note.stapsdt\" section."
msgstr ""
"No Linux, pode verificar se os marcadores estáticos do SystemTap estão "
"presentes no binário compilado vendo se este contém uma secção \".note."
"stapsdt\"."

msgid ""
"$ readelf -S ./python | grep .note.stapsdt\n"
"[30] .note.stapsdt        NOTE         0000000000000000 00308d78"
msgstr ""
"$ readelf -S ./python | grep .note.stapsdt\n"
"[30] .note.stapsdt        NOTE         0000000000000000 00308d78"

msgid ""
"If you've built Python as a shared library (with the :option:`--enable-"
"shared` configure option), you need to look instead within the shared "
"library.  For example::"
msgstr ""
"Se compilou o Python como uma biblioteca partilhada (com a opção de "
"configuração :option:`--enable-shared`), deve procurar dentro da biblioteca "
"partilhada. Por exemplo::"

msgid ""
"$ readelf -S libpython3.3dm.so.1.0 | grep .note.stapsdt\n"
"[29] .note.stapsdt        NOTE         0000000000000000 00365b68"
msgstr ""
"$ readelf -S libpython3.3dm.so.1.0 | grep .note.stapsdt\n"
"[29] .note.stapsdt        NOTE         0000000000000000 00365b68"

msgid "Sufficiently modern readelf can print the metadata::"
msgstr "Um readelf suficientemente moderno pode imprimir os metadados::"

msgid ""
"$ readelf -n ./python\n"
"\n"
"Displaying notes found at file offset 0x00000254 with length 0x00000020:\n"
"    Owner                 Data size          Description\n"
"    GNU                  0x00000010          NT_GNU_ABI_TAG (ABI version "
"tag)\n"
"        OS: Linux, ABI: 2.6.32\n"
"\n"
"Displaying notes found at file offset 0x00000274 with length 0x00000024:\n"
"    Owner                 Data size          Description\n"
"    GNU                  0x00000014          NT_GNU_BUILD_ID (unique build "
"ID bitstring)\n"
"        Build ID: df924a2b08a7e89f6e11251d4602022977af2670\n"
"\n"
"Displaying notes found at file offset 0x002d6c30 with length 0x00000144:\n"
"    Owner                 Data size          Description\n"
"    stapsdt              0x00000031          NT_STAPSDT (SystemTap probe "
"descriptors)\n"
"        Provider: python\n"
"        Name: gc__start\n"
"        Location: 0x00000000004371c3, Base: 0x0000000000630ce2, Semaphore: "
"0x00000000008d6bf6\n"
"        Arguments: -4@%ebx\n"
"    stapsdt              0x00000030          NT_STAPSDT (SystemTap probe "
"descriptors)\n"
"        Provider: python\n"
"        Name: gc__done\n"
"        Location: 0x00000000004374e1, Base: 0x0000000000630ce2, Semaphore: "
"0x00000000008d6bf8\n"
"        Arguments: -8@%rax\n"
"    stapsdt              0x00000045          NT_STAPSDT (SystemTap probe "
"descriptors)\n"
"        Provider: python\n"
"        Name: function__entry\n"
"        Location: 0x000000000053db6c, Base: 0x0000000000630ce2, Semaphore: "
"0x00000000008d6be8\n"
"        Arguments: 8@%rbp 8@%r12 -4@%eax\n"
"    stapsdt              0x00000046          NT_STAPSDT (SystemTap probe "
"descriptors)\n"
"        Provider: python\n"
"        Name: function__return\n"
"        Location: 0x000000000053dba8, Base: 0x0000000000630ce2, Semaphore: "
"0x00000000008d6bea\n"
"        Arguments: 8@%rbp 8@%r12 -4@%eax"
msgstr ""

msgid ""
"The above metadata contains information for SystemTap describing how it can "
"patch strategically placed machine code instructions to enable the tracing "
"hooks used by a SystemTap script."
msgstr ""
"Os metadados acima contêm informações para o SystemTap descrevendo como este "
"pode aplicar patches em instruções de código de máquina colocadas "
"estrategicamente para ativar os hooks de tracing usados por um script "
"SystemTap."

msgid "Static DTrace probes"
msgstr "Probes DTrace estáticas"

msgid ""
"The following example DTrace script can be used to show the call/return "
"hierarchy of a Python script, only tracing within the invocation of a "
"function called \"start\". In other words, import-time function invocations "
"are not going to be listed:"
msgstr ""
"O seguinte exemplo de script DTrace pode ser usado para mostrar a hierarquia "
"de chamada/retorno de um script Python, rastreando apenas dentro da "
"invocação de uma função chamada \"start\". Por outras palavras, as "
"invocações de funções em tempo de importação não serão listadas:"

msgid ""
"self int indent;\n"
"\n"
"python$target:::function-entry\n"
"/copyinstr(arg1) == \"start\"/\n"
"{\n"
"        self->trace = 1;\n"
"}\n"
"\n"
"python$target:::function-entry\n"
"/self->trace/\n"
"{\n"
"        printf(\"%d\\t%*s:\", timestamp, 15, probename);\n"
"        printf(\"%*s\", self->indent, \"\");\n"
"        printf(\"%s:%s:%d\\n\", basename(copyinstr(arg0)), copyinstr(arg1), "
"arg2);\n"
"        self->indent++;\n"
"}\n"
"\n"
"python$target:::function-return\n"
"/self->trace/\n"
"{\n"
"        self->indent--;\n"
"        printf(\"%d\\t%*s:\", timestamp, 15, probename);\n"
"        printf(\"%*s\", self->indent, \"\");\n"
"        printf(\"%s:%s:%d\\n\", basename(copyinstr(arg0)), copyinstr(arg1), "
"arg2);\n"
"}\n"
"\n"
"python$target:::function-return\n"
"/copyinstr(arg1) == \"start\"/\n"
"{\n"
"        self->trace = 0;\n"
"}"
msgstr ""

msgid "It can be invoked like this::"
msgstr "Pode ser invocado desta forma::"

msgid "$ sudo dtrace -q -s call_stack.d -c \"python3.6 script.py\""
msgstr ""

msgid "The output looks like this:"
msgstr "A saída parece-se com isto:"

msgid ""
"156641360502280  function-entry:call_stack.py:start:23\n"
"156641360518804  function-entry: call_stack.py:function_1:1\n"
"156641360532797  function-entry:  call_stack.py:function_3:9\n"
"156641360546807 function-return:  call_stack.py:function_3:10\n"
"156641360563367 function-return: call_stack.py:function_1:2\n"
"156641360578365  function-entry: call_stack.py:function_2:5\n"
"156641360591757  function-entry:  call_stack.py:function_1:1\n"
"156641360605556  function-entry:   call_stack.py:function_3:9\n"
"156641360617482 function-return:   call_stack.py:function_3:10\n"
"156641360629814 function-return:  call_stack.py:function_1:2\n"
"156641360642285 function-return: call_stack.py:function_2:6\n"
"156641360656770  function-entry: call_stack.py:function_3:9\n"
"156641360669707 function-return: call_stack.py:function_3:10\n"
"156641360687853  function-entry: call_stack.py:function_4:13\n"
"156641360700719 function-return: call_stack.py:function_4:14\n"
"156641360719640  function-entry: call_stack.py:function_5:18\n"
"156641360732567 function-return: call_stack.py:function_5:21\n"
"156641360747370 function-return:call_stack.py:start:28"
msgstr ""

msgid "Static SystemTap markers"
msgstr "Marcadores SystemTap estáticos"

msgid ""
"The low-level way to use the SystemTap integration is to use the static "
"markers directly.  This requires you to explicitly state the binary file "
"containing them."
msgstr ""
"A forma de baixo nível de utilizar a integração com o SystemTap é usar "
"diretamente os marcadores estáticos. Isto requer que indique explicitamente "
"o ficheiro binário que os contém."

msgid ""
"For example, this SystemTap script can be used to show the call/return "
"hierarchy of a Python script:"
msgstr ""
"Por exemplo, este script SystemTap pode ser usado para mostrar a hierarquia "
"de chamada/retorno de um script Python:"

msgid ""
"probe process(\"python\").mark(\"function__entry\") {\n"
"     filename = user_string($arg1);\n"
"     funcname = user_string($arg2);\n"
"     lineno = $arg3;\n"
"\n"
"     printf(\"%s => %s in %s:%d\\\\n\",\n"
"            thread_indent(1), funcname, filename, lineno);\n"
"}\n"
"\n"
"probe process(\"python\").mark(\"function__return\") {\n"
"    filename = user_string($arg1);\n"
"    funcname = user_string($arg2);\n"
"    lineno = $arg3;\n"
"\n"
"    printf(\"%s <= %s in %s:%d\\\\n\",\n"
"           thread_indent(-1), funcname, filename, lineno);\n"
"}"
msgstr ""

msgid ""
"$ stap \\\n"
"  show-call-hierarchy.stp \\\n"
"  -c \"./python test.py\""
msgstr ""

msgid ""
"11408 python(8274):        => __contains__ in Lib/_abcoll.py:362\n"
"11414 python(8274):         => __getitem__ in Lib/os.py:425\n"
"11418 python(8274):          => encode in Lib/os.py:490\n"
"11424 python(8274):          <= encode in Lib/os.py:493\n"
"11428 python(8274):         <= __getitem__ in Lib/os.py:426\n"
"11433 python(8274):        <= __contains__ in Lib/_abcoll.py:366"
msgstr ""

msgid "where the columns are:"
msgstr "onde as colunas são:"

msgid "time in microseconds since start of script"
msgstr "tempo em microssegundos desde o início do script"

msgid "name of executable"
msgstr "nome do executável"

msgid "PID of process"
msgstr "PID do processo"

msgid ""
"and the remainder indicates the call/return hierarchy as the script executes."
msgstr ""
"e o restante indica a hierarquia de chamada/retorno conforme o script é "
"executado."

msgid ""
"For a :option:`--enable-shared` build of CPython, the markers are contained "
"within the libpython shared library, and the probe's dotted path needs to "
"reflect this. For example, this line from the above example:"
msgstr ""
"Para uma build do CPython com :option:`--enable-shared`, os marcadores estão "
"contidos na biblioteca partilhada libpython, e o caminho pontuado da probe "
"precisa de refletir isso. Por exemplo, esta linha do exemplo acima:"

msgid "probe process(\"python\").mark(\"function__entry\") {"
msgstr ""

msgid "should instead read:"
msgstr "deveria, em vez disso, ser:"

msgid ""
"probe process(\"python\").library(\"libpython3.6dm.so.1.0\")."
"mark(\"function__entry\") {"
msgstr ""

msgid "(assuming a :ref:`debug build <debug-build>` of CPython 3.6)"
msgstr "(assumindo uma :ref:`debug build <debug-build>` do CPython 3.6)"

msgid "Available static markers"
msgstr "Marcadores estáticos disponíveis"

msgid ""
"This marker indicates that execution of a Python function has begun. It is "
"only triggered for pure-Python (bytecode) functions."
msgstr ""
"Este marcador indica que a execução de uma função Python começou. Só é "
"disparado para funções Python puras (bytecode)."

msgid ""
"The filename, function name, and line number are provided back to the "
"tracing script as positional arguments, which must be accessed using "
"``$arg1``, ``$arg2``, ``$arg3``:"
msgstr ""
"O nome do ficheiro, o nome da função e o número da linha são devolvidos ao "
"script de tracing como argumentos posicionais, que devem ser acedidos usando "
"``$arg1``, ``$arg2``, ``$arg3``:"

msgid ""
"``$arg1`` : ``(const char *)`` filename, accessible using "
"``user_string($arg1)``"
msgstr ""
"``$arg1`` : ``(const char *)`` nome do ficheiro, acedível usando "
"``user_string($arg1)``"

msgid ""
"``$arg2`` : ``(const char *)`` function name, accessible using "
"``user_string($arg2)``"
msgstr ""
"``$arg2`` : ``(const char *)`` nome da função, acedível usando "
"``user_string($arg2)``"

msgid "``$arg3`` : ``int`` line number"
msgstr "``$arg3`` : ``int`` número da linha"

msgid ""
"This marker is the converse of :c:func:`!function__entry`, and indicates "
"that execution of a Python function has ended (either via ``return``, or via "
"an exception).  It is only triggered for pure-Python (bytecode) functions."
msgstr ""
"Este marcador é o inverso de :c:func:`!function__entry`, e indica que a "
"execução de uma função Python terminou (seja via ``return`` ou via uma "
"exceção). Só é disparado para funções Python puras (bytecode)."

msgid "The arguments are the same as for :c:func:`!function__entry`"
msgstr "Os argumentos são os mesmos que para :c:func:`!function__entry`"

msgid ""
"This marker indicates a Python line is about to be executed.  It is the "
"equivalent of line-by-line tracing with a Python profiler.  It is not "
"triggered within C functions."
msgstr ""
"Este marcador indica que uma linha Python está prestes a ser executada. É o "
"equivalente ao tracing linha-a-linha com um profiler Python. Não é disparado "
"dentro de funções C."

msgid "The arguments are the same as for :c:func:`!function__entry`."
msgstr "Os argumentos são os mesmos que para :c:func:`!function__entry`."

msgid ""
"Fires when the Python interpreter starts a garbage collection cycle. "
"``arg0`` is the generation to scan, like :func:`gc.collect`."
msgstr ""
"Dispara quando o intérprete Python inicia um ciclo de recolha de lixo. "
"``arg0`` é a geração a verificar, como em :func:`gc.collect`."

msgid ""
"Fires when the Python interpreter finishes a garbage collection cycle. "
"``arg0`` is the number of collected objects."
msgstr ""
"Dispara quando o intérprete Python termina um ciclo de recolha de lixo. "
"``arg0`` é o número de objetos recolhidos."

msgid ""
"Fires before :mod:`importlib` attempts to find and load the module. ``arg0`` "
"is the module name."
msgstr ""
"Dispara antes do :mod:`importlib` tentar encontrar e carregar o módulo. "
"``arg0`` é o nome do módulo."

msgid ""
"Fires after :mod:`importlib`'s find_and_load function is called. ``arg0`` is "
"the module name, ``arg1`` indicates if module was successfully loaded."
msgstr ""
"Dispara após a função find_and_load do :mod:`importlib` ser chamada. "
"``arg0`` é o nome do módulo, ``arg1`` indica se o módulo foi carregado com "
"sucesso."

msgid ""
"Fires when :func:`sys.audit` or :c:func:`PySys_Audit` is called. ``arg0`` is "
"the event name as C string, ``arg1`` is a :c:type:`PyObject` pointer to a "
"tuple object."
msgstr ""
"Dispara quando :func:`sys.audit` ou :c:func:`PySys_Audit` é chamado. "
"``arg0`` é o nome do evento como string C, ``arg1`` é um ponteiro :c:type:"
"`PyObject` para um objeto tuplo."

msgid "SystemTap Tapsets"
msgstr "Tapsets SystemTap"

msgid ""
"The higher-level way to use the SystemTap integration is to use a "
"\"tapset\": SystemTap's equivalent of a library, which hides some of the "
"lower-level details of the static markers."
msgstr ""
"A forma de nível mais elevado de utilizar a integração com o SystemTap é "
"usar um \"tapset\": o equivalente do SystemTap a uma biblioteca, que esconde "
"alguns dos detalhes de nível mais baixo dos marcadores estáticos."

msgid "Here is a tapset file, based on a non-shared build of CPython:"
msgstr ""
"Aqui está um ficheiro tapset, baseado numa build do CPython não partilhada:"

msgid ""
"/*\n"
"   Provide a higher-level wrapping around the function__entry and\n"
"   function__return markers:\n"
" \\*/\n"
"probe python.function.entry = process(\"python\").mark(\"function__entry\")\n"
"{\n"
"    filename = user_string($arg1);\n"
"    funcname = user_string($arg2);\n"
"    lineno = $arg3;\n"
"    frameptr = $arg4\n"
"}\n"
"probe python.function.return = process(\"python\")."
"mark(\"function__return\")\n"
"{\n"
"    filename = user_string($arg1);\n"
"    funcname = user_string($arg2);\n"
"    lineno = $arg3;\n"
"    frameptr = $arg4\n"
"}"
msgstr ""

msgid ""
"If this file is installed in SystemTap's tapset directory (e.g. ``/usr/share/"
"systemtap/tapset``), then these additional probepoints become available:"
msgstr ""
"Se este ficheiro for instalado na diretoria de tapsets do SystemTap (ex: ``/"
"usr/share/systemtap/tapset``), então estes probepoints adicionais ficam "
"disponíveis:"

msgid ""
"This probe point indicates that execution of a Python function has begun. It "
"is only triggered for pure-Python (bytecode) functions."
msgstr ""
"Este probe point indica que a execução de uma função Python começou. Só é "
"disparado para funções Python puras (bytecode)."

msgid ""
"This probe point is the converse of ``python.function.return``, and "
"indicates that execution of a Python function has ended (either via "
"``return``, or via an exception).  It is only triggered for pure-Python "
"(bytecode) functions."
msgstr ""
"Este probe point é o inverso de ``python.function.return``, e indica que a "
"execução de uma função Python terminou (seja via ``return`` ou via uma "
"exceção). Só é disparado para funções Python puras (bytecode)."

msgid "Examples"
msgstr "Exemplos"

msgid ""
"This SystemTap script uses the tapset above to more cleanly implement the "
"example given above of tracing the Python function-call hierarchy, without "
"needing to directly name the static markers:"
msgstr ""
"Este script SystemTap usa o tapset acima para implementar de forma mais "
"limpa o exemplo dado anteriormente de rastrear a hierarquia de chamadas de "
"função Python, sem necessitar de nomear diretamente os marcadores estáticos:"

msgid ""
"probe python.function.entry\n"
"{\n"
"  printf(\"%s => %s in %s:%d\\n\",\n"
"         thread_indent(1), funcname, filename, lineno);\n"
"}\n"
"\n"
"probe python.function.return\n"
"{\n"
"  printf(\"%s <= %s in %s:%d\\n\",\n"
"         thread_indent(-1), funcname, filename, lineno);\n"
"}"
msgstr ""

msgid ""
"The following script uses the tapset above to provide a top-like view of all "
"running CPython code, showing the top 20 most frequently entered bytecode "
"frames, each second, across the whole system:"
msgstr ""
"O seguinte script utiliza o tapset acima para fornecer uma vista estilo "
"\"top\" de todo o código CPython em execução, mostrando as 20 frames de "
"bytecode em que se entrou mais frequentemente, a cada segundo, em todo o "
"sistema:"

msgid ""
"global fn_calls;\n"
"\n"
"probe python.function.entry\n"
"{\n"
"    fn_calls[pid(), filename, funcname, lineno] += 1;\n"
"}\n"
"\n"
"probe timer.ms(1000) {\n"
"    printf(\"\\033[2J\\033[1;1H\") /* clear screen \\*/\n"
"    printf(\"%6s %80s %6s %30s %6s\\n\",\n"
"           \"PID\", \"FILENAME\", \"LINE\", \"FUNCTION\", \"CALLS\")\n"
"    foreach ([pid, filename, funcname, lineno] in fn_calls- limit 20) {\n"
"        printf(\"%6d %80s %6d %30s %6d\\n\",\n"
"            pid, filename, lineno, funcname,\n"
"            fn_calls[pid, filename, funcname, lineno]);\n"
"    }\n"
"    delete fn_calls;\n"
"}"
msgstr ""
