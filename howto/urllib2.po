# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-05 14:39+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid "HOWTO Fetch Internet Resources Using The urllib Package"
msgstr "COMO Obter Recursos da Internet Usando o Pacote urllib"

msgid "Author"
msgstr "Autor"

msgid "`Michael Foord <https://agileabstractions.com/>`_"
msgstr "`Michael Foord <https://agileabstractions.com/>`_"

msgid "Introduction"
msgstr "Introdução"

msgid ""
"You may also find useful the following article on fetching web resources "
"with Python:"
msgstr ""
"Também pode encontrar útil o seguinte artigo sobre como obter recursos web "
"com Python:"

msgid ""
"`Basic Authentication <https://web.archive.org/web/20201215133350/http://www."
"voidspace.org.uk/python/articles/authentication.shtml>`__"
msgstr ""
"`Autenticação Básica <https://web.archive.org/web/20201215133350/http://www."
"voidspace.org.uk/python/articles/authentication.shtml>`__"

msgid "A tutorial on *Basic Authentication*, with examples in Python."
msgstr "Um tutorial sobre *Autenticação Básica*, com exemplos em Python."

msgid ""
"**urllib.request** is a Python module for fetching URLs (Uniform Resource "
"Locators). It offers a very simple interface, in the form of the *urlopen* "
"function. This is capable of fetching URLs using a variety of different "
"protocols. It also offers a slightly more complex interface for handling "
"common situations - like basic authentication, cookies, proxies and so on. "
"These are provided by objects called handlers and openers."
msgstr ""
"**urllib.request** é um módulo Python para obter URLs (Localizadores de "
"Recursos Uniformes). Oferece uma interface muito simples, na forma da função "
"*urlopen*. Esta é capaz de obter URLs usando uma variedade de protocolos "
"diferentes. Também oferece uma interface um pouco mais complexa para lidar "
"com situações comuns - como autenticação básica, cookies, proxies e assim "
"por diante. Estas são fornecidas por objetos chamados *handlers* e *openers*."

msgid ""
"urllib.request supports fetching URLs for many \"URL schemes\" (identified "
"by the string before the ``\":\"`` in URL - for example ``\"ftp\"`` is the "
"URL scheme of ``\"ftp://python.org/\"``) using their associated network "
"protocols (e.g. FTP, HTTP). This tutorial focuses on the most common case, "
"HTTP."
msgstr ""
"urllib.request suporta a obtenção de URLs para muitos \"esquemas de "
"URL\" (identificados pela string antes do ``\":\"`` na URL - por exemplo, "
"``\"ftp\"`` é o esquema de URL de ``\"ftp://python.org/\"``) usando os seus "
"protocolos de rede associados (por exemplo, FTP, HTTP). Este tutorial foca-"
"se no caso mais comum, HTTP."

msgid ""
"For straightforward situations *urlopen* is very easy to use. But as soon as "
"you encounter errors or non-trivial cases when opening HTTP URLs, you will "
"need some understanding of the HyperText Transfer Protocol. The most "
"comprehensive and authoritative reference to HTTP is :rfc:`2616`. This is a "
"technical document and not intended to be easy to read. This HOWTO aims to "
"illustrate using *urllib*, with enough detail about HTTP to help you "
"through. It is not intended to replace the :mod:`urllib.request` docs, but "
"is supplementary to them."
msgstr ""
"Para situações simples, *urlopen* é muito fácil de usar. Mas assim que "
"encontrar erros ou casos não triviais ao abrir URLs HTTP, precisará de "
"alguma compreensão do Protocolo de Transferência de Hipertexto. A referência "
"mais completa e autoritativa para HTTP é :rfc:`2616`. Este é um documento "
"técnico e não foi concebido para ser fácil de ler. Este HOWTO visa ilustrar "
"o uso de *urllib*, com detalhes suficientes sobre HTTP para o ajudar. Não se "
"destina a substituir a documentação de :mod:`urllib.request`, mas é "
"suplementar a esta."

msgid "Fetching URLs"
msgstr "Obter URLs"

msgid "The simplest way to use urllib.request is as follows::"
msgstr "A forma mais simples de usar urllib.request é a seguinte:"

msgid ""
"import urllib.request\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"   html = response.read()"
msgstr ""
"import urllib.request\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"   html = response.read()"

msgid ""
"If you wish to retrieve a resource via URL and store it in a temporary "
"location, you can do so via the :func:`shutil.copyfileobj` and :func:"
"`tempfile.NamedTemporaryFile` functions::"
msgstr ""
"Se desejar recuperar um recurso via URL e armazená-lo num local temporário, "
"pode fazê-lo através das funções :func:`shutil.copyfileobj` e :func:"
"`tempfile.NamedTemporaryFile`:"

msgid ""
"import shutil\n"
"import tempfile\n"
"import urllib.request\n"
"\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n"
"        shutil.copyfileobj(response, tmp_file)\n"
"\n"
"with open(tmp_file.name) as html:\n"
"    pass"
msgstr ""
"import shutil\n"
"import tempfile\n"
"import urllib.request\n"
"\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n"
"        shutil.copyfileobj(response, tmp_file)\n"
"\n"
"with open(tmp_file.name) as html:\n"
"    pass"

msgid ""
"Many uses of urllib will be that simple (note that instead of an 'http:' URL "
"we could have used a URL starting with 'ftp:', 'file:', etc.).  However, "
"it's the purpose of this tutorial to explain the more complicated cases, "
"concentrating on HTTP."
msgstr ""
"Muitos usos de urllib serão tão simples (note que em vez de uma URL 'http:' "
"poderíamos ter usado uma URL começando com 'ftp:', 'file:', etc.). No "
"entanto, o objetivo deste tutorial é explicar os casos mais complicados, "
"concentrando-se em HTTP."

msgid ""
"HTTP is based on requests and responses - the client makes requests and "
"servers send responses. urllib.request mirrors this with a ``Request`` "
"object which represents the HTTP request you are making. In its simplest "
"form you create a Request object that specifies the URL you want to fetch. "
"Calling ``urlopen`` with this Request object returns a response object for "
"the URL requested. This response is a file-like object, which means you can "
"for example call ``.read()`` on the response::"
msgstr ""
"O HTTP é baseado em pedidos e respostas - o cliente faz pedidos e os "
"servidores enviam respostas. O urllib.request reflete isto com um objeto "
"``Request`` que representa o pedido HTTP que está a fazer. Na sua forma mais "
"simples, cria um objeto Request que especifica a URL que deseja obter. "
"Chamar ``urlopen`` com este objeto Request devolve um objeto de resposta "
"para a URL solicitada. Esta resposta é um objeto semelhante a um ficheiro, o "
"que significa que pode, por exemplo, chamar ``.read()`` na resposta:"

msgid ""
"import urllib.request\n"
"\n"
"req = urllib.request.Request('http://python.org/')\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"
msgstr ""
"import urllib.request\n"
"\n"
"req = urllib.request.Request('http://python.org/')\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"

msgid ""
"Note that urllib.request makes use of the same Request interface to handle "
"all URL schemes.  For example, you can make an FTP request like so::"
msgstr ""
"Note que urllib.request usa a mesma interface Request para lidar com todos "
"os esquemas de URL. Por exemplo, pode fazer um pedido FTP assim:"

msgid "req = urllib.request.Request('ftp://example.com/')"
msgstr "req = urllib.request.Request('ftp://example.com/')"

msgid ""
"In the case of HTTP, there are two extra things that Request objects allow "
"you to do: First, you can pass data to be sent to the server.  Second, you "
"can pass extra information (\"metadata\") *about* the data or about the "
"request itself, to the server - this information is sent as HTTP "
"\"headers\".  Let's look at each of these in turn."
msgstr ""
"No caso do HTTP, há duas coisas extras que os objetos Request permitem "
"fazer: Primeiro, pode passar dados a serem enviados para o servidor. "
"Segundo, pode passar informações extras (\"metadados\") *sobre* os dados ou "
"sobre o próprio pedido, para o servidor - esta informação é enviada como "
"cabeçalhos HTTP. Vamos ver cada uma destas em detalhe."

msgid "Data"
msgstr "Dados"

msgid ""
"Sometimes you want to send data to a URL (often the URL will refer to a CGI "
"(Common Gateway Interface) script or other web application). With HTTP, this "
"is often done using what's known as a **POST** request. This is often what "
"your browser does when you submit a HTML form that you filled in on the web. "
"Not all POSTs have to come from forms: you can use a POST to transmit "
"arbitrary data to your own application. In the common case of HTML forms, "
"the data needs to be encoded in a standard way, and then passed to the "
"Request object as the ``data`` argument. The encoding is done using a "
"function from the :mod:`urllib.parse` library. ::"
msgstr ""
"Às vezes, deseja enviar dados para uma URL (muitas vezes a URL referir-se-á "
"a um script CGI (Common Gateway Interface) ou outra aplicação web). Com "
"HTTP, isto é frequentemente feito usando o que é conhecido como um pedido "
"**POST**. Isto é frequentemente o que o seu navegador faz quando submete um "
"formulário HTML que preencheu na web. Nem todos os POSTs têm de vir de "
"formulários: pode usar um POST para transmitir dados arbitrários para a sua "
"própria aplicação. No caso comum de formulários HTML, os dados precisam de "
"ser codificados de uma forma padrão, e depois passados ao objeto Request "
"como o argumento ``data``. A codificação é feita usando uma função da "
"biblioteca :mod:`urllib.parse`:"

msgid ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"values = {'name' : 'Michael Foord',\n"
"          'location' : 'Northampton',\n"
"          'language' : 'Python' }\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii') # data should be bytes\n"
"req = urllib.request.Request(url, data)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"
msgstr ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"values = {'name' : 'Michael Foord',\n"
"          'location' : 'Northampton',\n"
"          'language' : 'Python' }\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii') # os dados devem ser bytes\n"
"req = urllib.request.Request(url, data)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"

msgid ""
"Note that other encodings are sometimes required (e.g. for file upload from "
"HTML forms - see `HTML Specification, Form Submission <https://www.w3.org/TR/"
"REC-html40/interact/forms.html#h-17.13>`_ for more details)."
msgstr ""
"Note que outras codificações são por vezes necessárias (por exemplo, para o "
"carregamento de ficheiros a partir de formulários HTML - veja `Especificação "
"HTML, Submissão de Formulário <https://www.w3.org/TR/REC-html40/interact/"
"forms.html#h-17.13>`_ para mais detalhes)."

msgid ""
"If you do not pass the ``data`` argument, urllib uses a **GET** request. One "
"way in which GET and POST requests differ is that POST requests often have "
"\"side-effects\": they change the state of the system in some way (for "
"example by placing an order with the website for a hundredweight of tinned "
"spam to be delivered to your door).  Though the HTTP standard makes it clear "
"that POSTs are intended to *always* cause side-effects, and GET requests "
"*never* to cause side-effects, nothing prevents a GET request from having "
"side-effects, nor a POST requests from having no side-effects. Data can also "
"be passed in an HTTP GET request by encoding it in the URL itself."
msgstr ""
"Se não passar o argumento ``data``, o urllib usa um pedido **GET**. Uma "
"forma pela qual os pedidos GET e POST diferem é que os pedidos POST muitas "
"vezes têm \"efeitos secundários\": alteram o estado do sistema de alguma "
"forma (por exemplo, ao fazer um pedido no site para que uma centena de latas "
"de spam sejam entregues à sua porta). Embora o padrão HTTP deixe claro que "
"os POSTs devem *sempre* causar efeitos secundários, e os pedidos GET *nunca* "
"devem causar efeitos secundários, nada impede que um pedido GET tenha "
"efeitos secundários, nem que um pedido POST não tenha efeitos secundários. "
"Os dados também podem ser passados num pedido HTTP GET codificando-os na "
"própria URL."

msgid "This is done as follows::"
msgstr "Isto é feito da seguinte forma:"

msgid ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> data = {}\n"
">>> data['name'] = 'Somebody Here'\n"
">>> data['location'] = 'Northampton'\n"
">>> data['language'] = 'Python'\n"
">>> url_values = urllib.parse.urlencode(data)\n"
">>> print(url_values)  # The order may differ from below.\n"
"name=Somebody+Here&language=Python&location=Northampton\n"
">>> url = 'http://www.example.com/example.cgi'\n"
">>> full_url = url + '?' + url_values\n"
">>> data = urllib.request.urlopen(full_url)"
msgstr ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> data = {}\n"
">>> data['name'] = 'Somebody Here'\n"
">>> data['location'] = 'Northampton'\n"
">>> data['language'] = 'Python'\n"
">>> url_values = urllib.parse.urlencode(data)\n"
">>> print(url_values)  # A ordem pode diferir da abaixo.\n"
"name=Somebody+Here&language=Python&location=Northampton\n"
">>> url = 'http://www.example.com/example.cgi'\n"
">>> full_url = url + '?' + url_values\n"
">>> data = urllib.request.urlopen(full_url)"

msgid ""
"Notice that the full URL is created by adding a ``?`` to the URL, followed "
"by the encoded values."
msgstr ""
"Note que a URL completa é criada adicionando um ``?`` à URL, seguido pelos "
"valores codificados."

msgid "Headers"
msgstr "Cabeçalhos"

msgid ""
"We'll discuss here one particular HTTP header, to illustrate how to add "
"headers to your HTTP request."
msgstr ""
"Vamos discutir aqui um cabeçalho HTTP específico, para ilustrar como "
"adicionar cabeçalhos ao seu pedido HTTP."

msgid ""
"Some websites [#]_ dislike being browsed by programs, or send different "
"versions to different browsers [#]_. By default urllib identifies itself as "
"``Python-urllib/x.y`` (where ``x`` and ``y`` are the major and minor version "
"numbers of the Python release, e.g. ``Python-urllib/2.5``), which may "
"confuse the site, or just plain not work. The way a browser identifies "
"itself is through the ``User-Agent`` header [#]_. When you create a Request "
"object you can pass a dictionary of headers in. The following example makes "
"the same request as above, but identifies itself as a version of Internet "
"Explorer [#]_. ::"
msgstr ""
"Alguns sites [#]_ não gostam de ser navegados por programas, ou enviam "
"versões diferentes para navegadores diferentes [#]_. Por predefinição, o "
"urllib identifica-se como ``Python-urllib/x.y`` (onde ``x`` e ``y`` são os "
"números de versão principal e secundária da versão do Python, por exemplo, "
"``Python-urllib/2.5``), o que pode confundir o site, ou simplesmente não "
"funcionar. A forma como um navegador se identifica é através do cabeçalho "
"``User-Agent`` [#]_. Quando cria um objeto Request, pode passar um "
"dicionário de cabeçalhos. O exemplo seguinte faz o mesmo pedido que acima, "
"mas identifica-se como uma versão do Internet Explorer [#]_:"

msgid ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"user_agent = 'Mozilla/5.0 (Windows NT 6.1; Win64; x64)'\n"
"values = {'name': 'Michael Foord',\n"
"          'location': 'Northampton',\n"
"          'language': 'Python' }\n"
"headers = {'User-Agent': user_agent}\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii')\n"
"req = urllib.request.Request(url, data, headers)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"
msgstr ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"user_agent = 'Mozilla/5.0 (Windows NT 6.1; Win64; x64)'\n"
"values = {'name': 'Michael Foord',\n"
"          'location': 'Northampton',\n"
"          'language': 'Python' }\n"
"headers = {'User-Agent': user_agent}\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii')\n"
"req = urllib.request.Request(url, data, headers)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"

msgid ""
"The response also has two useful methods. See the section on `info and "
"geturl`_ which comes after we have a look at what happens when things go "
"wrong."
msgstr ""
"A resposta também tem dois métodos úteis. Veja a secção sobre `info e "
"geturl`_ que vem depois de vermos o que acontece quando as coisas correm mal."

msgid "Handling Exceptions"
msgstr "Tratamento de Exceções"

msgid ""
"*urlopen* raises :exc:`~urllib.error.URLError` when it cannot handle a "
"response (though as usual with Python APIs, built-in exceptions such as :exc:"
"`ValueError`, :exc:`TypeError` etc. may also be raised)."
msgstr ""
"*urlopen* lança :exc:`~urllib.error.URLError` quando não consegue lidar com "
"uma resposta (embora, como é habitual com as APIs Python, exceções "
"incorporadas como :exc:`ValueError`, :exc:`TypeError`, etc., também possam "
"ser lançadas)."

msgid ""
":exc:`~urllib.error.HTTPError` is the subclass of :exc:`~urllib.error."
"URLError` raised in the specific case of HTTP URLs."
msgstr ""
":exc:`~urllib.error.HTTPError` é a subclasse de :exc:`~urllib.error."
"URLError` lançada no caso específico de URLs HTTP."

msgid "The exception classes are exported from the :mod:`urllib.error` module."
msgstr "As classes de exceção são exportadas do módulo :mod:`urllib.error`."

msgid "URLError"
msgstr "URLError"

msgid ""
"Often, URLError is raised because there is no network connection (no route "
"to the specified server), or the specified server doesn't exist.  In this "
"case, the exception raised will have a 'reason' attribute, which is a tuple "
"containing an error code and a text error message."
msgstr ""
"Muitas vezes, URLError é lançada porque não há ligação à rede (sem rota para "
"o servidor especificado), ou o servidor especificado não existe. Neste caso, "
"a exceção lançada terá um atributo 'reason', que é um tuplo contendo um "
"código de erro e uma mensagem de erro em texto."

msgid "e.g. ::"
msgstr "por exemplo:"

msgid ""
">>> req = urllib.request.Request('http://www.pretend_server.org')\n"
">>> try: urllib.request.urlopen(req)\n"
"... except urllib.error.URLError as e:\n"
"...     print(e.reason)\n"
"...\n"
"(4, 'getaddrinfo failed')"
msgstr ""
">>> req = urllib.request.Request('http://www.pretend_server.org')\n"
">>> try: urllib.request.urlopen(req)\n"
"... except urllib.error.URLError as e:\n"
"...     print(e.reason)\n"
"...\n"
"(4, 'getaddrinfo falhou')"

msgid "HTTPError"
msgstr "HTTPError"

msgid ""
"Every HTTP response from the server contains a numeric \"status code\". "
"Sometimes the status code indicates that the server is unable to fulfil the "
"request. The default handlers will handle some of these responses for you "
"(for example, if the response is a \"redirection\" that requests the client "
"fetch the document from a different URL, urllib will handle that for you). "
"For those it can't handle, urlopen will raise an :exc:`~urllib.error."
"HTTPError`. Typical errors include '404' (page not found), '403' (request "
"forbidden), and '401' (authentication required)."
msgstr ""
"Toda a resposta HTTP do servidor contém um código de \"estado\" numérico. Às "
"vezes, o código de estado indica que o servidor não consegue satisfazer o "
"pedido. Os manipuladores predefinidos lidarão com algumas destas respostas "
"por si (por exemplo, se a resposta for uma \"redireção\" que solicita ao "
"cliente buscar o documento a partir de uma URL diferente, o urllib lidará "
"com isso por si). Para aquelas que não consegue lidar, o urlopen lançará "
"uma :exc:`~urllib.error.HTTPError`. Erros típicos incluem '404' (página não "
"encontrada), '403' (pedido proibido) e '401' (autenticação necessária)."

msgid ""
"See section 10 of :rfc:`2616` for a reference on all the HTTP error codes."
msgstr ""
"Veja a secção 10 da :rfc:`2616` para uma referência a todos os códigos de "
"erro HTTP."

msgid ""
"The :exc:`~urllib.error.HTTPError` instance raised will have an integer "
"'code' attribute, which corresponds to the error sent by the server."
msgstr ""
"A instância :exc:`~urllib.error.HTTPError` lançada terá um atributo inteiro "
"'code', que corresponde ao erro enviado pelo servidor."

msgid "Error Codes"
msgstr "Códigos de Erro"

msgid ""
"Because the default handlers handle redirects (codes in the 300 range), and "
"codes in the 100--299 range indicate success, you will usually only see "
"error codes in the 400--599 range."
msgstr ""
"Como os manipuladores predefinidos lidam com redirecionamentos (códigos na "
"gama dos 300), e os códigos na gama 100-299 indicam sucesso, normalmente só "
"verá códigos de erro na gama 400-599."

msgid ""
":attr:`http.server.BaseHTTPRequestHandler.responses` is a useful dictionary "
"of response codes that shows all the response codes used by :rfc:`2616`. An "
"excerpt from the dictionary is shown below ::"
msgstr ""
":attr:`http.server.BaseHTTPRequestHandler.responses` é um dicionário útil de "
"códigos de resposta que mostra todos os códigos de resposta usados pela :rfc:"
"`2616`. Um excerto do dicionário é mostrado abaixo:"

msgid ""
"responses = {\n"
"    ...\n"
"    <HTTPStatus.OK: 200>: ('OK', 'Request fulfilled, document follows'),\n"
"    ...\n"
"    <HTTPStatus.FORBIDDEN: 403>: ('Forbidden',\n"
"                                  'Request forbidden -- authorization will "
"'\n"
"                                  'not help'),\n"
"    <HTTPStatus.NOT_FOUND: 404>: ('Not Found',\n"
"                                  'Nothing matches the given URI'),\n"
"    ...\n"
"    <HTTPStatus.IM_A_TEAPOT: 418>: (\"I'm a Teapot\",\n"
"                                    'Server refuses to brew coffee because "
"'\n"
"                                    'it is a teapot'),\n"
"    ...\n"
"    <HTTPStatus.SERVICE_UNAVAILABLE: 503>: ('Service Unavailable',\n"
"                                            'The server cannot process the "
"'\n"
"                                            'request due to a high load'),\n"
"    ...\n"
"    }"
msgstr ""
"responses = {\n"
"    ...\n"
"    <HTTPStatus.OK: 200>: ('OK', 'Pedido cumprido, segue o documento'),\n"
"    ...\n"
"    <HTTPStatus.FORBIDDEN: 403>: ('Proibido',\n"
"                                  'Pedido proibido -- a autorização não '\n"
"                                  'ajudará'),\n"
"    <HTTPStatus.NOT_FOUND: 404>: ('Não Encontrado',\n"
"                                  'Nada corresponde ao URI dado'),\n"
"    ...\n"
"    <HTTPStatus.IM_A_TEAPOT: 418>: (\"Sou um Bule\",\n"
"                                    'O servidor recusa-se a fazer café "
"porque '\n"
"                                    'é um bule'),\n"
"    ...\n"
"    <HTTPStatus.SERVICE_UNAVAILABLE: 503>: ('Serviço Indisponível',\n"
"                                            'O servidor não pode processar o "
"'\n"
"                                            'pedido devido a uma carga "
"elevada'),\n"
"    ...\n"
"    }"

msgid ""
"When an error is raised the server responds by returning an HTTP error code "
"*and* an error page. You can use the :exc:`~urllib.error.HTTPError` instance "
"as a response on the page returned. This means that as well as the code "
"attribute, it also has read, geturl, and info, methods as returned by the "
"``urllib.response`` module::"
msgstr ""
"Quando um erro é lançado, o servidor responde devolvendo um código de erro "
"HTTP *e* uma página de erro. Pode usar a instância :exc:`~urllib.error."
"HTTPError` como uma resposta na página devolvida. Isto significa que, além "
"do atributo code, também tem os métodos read, geturl e info, como devolvidos "
"pelo módulo ``urllib.response``:"

msgid ""
">>> req = urllib.request.Request('http://www.python.org/fish.html')\n"
">>> try:\n"
"...     urllib.request.urlopen(req)\n"
"... except urllib.error.HTTPError as e:\n"
"...     print(e.code)\n"
"...     print(e.read())\n"
"...\n"
"404\n"
"b'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n"
"  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional."
"dtd\">\\n\\n\\n<html\n"
"  ...\n"
"  <title>Page Not Found</title>\\n\n"
"  ..."
msgstr ""
">>> req = urllib.request.Request('http://www.python.org/fish.html')\n"
">>> try:\n"
"...     urllib.request.urlopen(req)\n"
"... except urllib.error.HTTPError as e:\n"
"...     print(e.code)\n"
"...     print(e.read())\n"
"...\n"
"404\n"
"b'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n"
"  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional."
"dtd\">\\n\\n\\n<html\n"
"  ...\n"
"  <title>Página Não Encontrada</title>\\n\n"
"  ..."

msgid "Wrapping it Up"
msgstr "Resumo"

msgid ""
"So if you want to be prepared for :exc:`~urllib.error.HTTPError` *or* :exc:"
"`~urllib.error.URLError` there are two basic approaches. I prefer the second "
"approach."
msgstr ""
"Portanto, se deseja estar preparado para :exc:`~urllib.error.HTTPError` "
"*ou* :exc:`~urllib.error.URLError`, existem duas abordagens básicas. Eu "
"prefiro a segunda abordagem."

msgid "Number 1"
msgstr "Número 1"

msgid ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError, HTTPError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except HTTPError as e:\n"
"    print('The server couldn\\'t fulfill the request.')\n"
"    print('Error code: ', e.code)\n"
"except URLError as e:\n"
"    print('We failed to reach a server.')\n"
"    print('Reason: ', e.reason)\n"
"else:\n"
"    # everything is fine"
msgstr ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError, HTTPError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except HTTPError as e:\n"
"    print('O servidor não conseguiu satisfazer o pedido.')\n"
"    print('Código de erro: ', e.code)\n"
"except URLError as e:\n"
"    print('Não conseguimos contactar o servidor.')\n"
"    print('Razão: ', e.reason)\n"
"else:\n"
"    # tudo correu bem"

msgid ""
"The ``except HTTPError`` *must* come first, otherwise ``except URLError`` "
"will *also* catch an :exc:`~urllib.error.HTTPError`."
msgstr ""
"O ``except HTTPError`` *tem* de vir primeiro, caso contrário o ``except "
"URLError`` também capturará um :exc:`~urllib.error.HTTPError`."

msgid "Number 2"
msgstr "Número 2"

msgid ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except URLError as e:\n"
"    if hasattr(e, 'reason'):\n"
"        print('We failed to reach a server.')\n"
"        print('Reason: ', e.reason)\n"
"    elif hasattr(e, 'code'):\n"
"        print('The server couldn\\'t fulfill the request.')\n"
"        print('Error code: ', e.code)\n"
"else:\n"
"    # everything is fine"
msgstr ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except URLError as e:\n"
"    if hasattr(e, 'reason'):\n"
"        print('Não conseguimos contactar o servidor.')\n"
"        print('Razão: ', e.reason)\n"
"    elif hasattr(e, 'code'):\n"
"        print('O servidor não conseguiu satisfazer o pedido.')\n"
"        print('Código de erro: ', e.code)\n"
"else:\n"
"    # tudo correu bem"

msgid "info and geturl"
msgstr "info e geturl"

msgid ""
"The response returned by urlopen (or the :exc:`~urllib.error.HTTPError` "
"instance) has two useful methods :meth:`!info` and :meth:`!geturl` and is "
"defined in the module :mod:`urllib.response`."
msgstr ""
"A resposta devolvida pelo urlopen (ou a instância :exc:`~urllib.error."
"HTTPError`) tem dois métodos úteis :meth:`!info` e :meth:`!geturl` e está "
"definida no módulo :mod:`urllib.response`."

msgid ""
"**geturl** - this returns the real URL of the page fetched. This is useful "
"because ``urlopen`` (or the opener object used) may have followed a "
"redirect. The URL of the page fetched may not be the same as the URL "
"requested."
msgstr ""
"**geturl** - devolve a URL real da página obtida. Isto é útil porque o "
"``urlopen`` (ou o objeto opener utilizado) pode ter seguido um "
"redirecionamento. A URL da página obtida pode não ser a mesma que a URL "
"solicitada."

msgid ""
"**info** - this returns a dictionary-like object that describes the page "
"fetched, particularly the headers sent by the server. It is currently an :"
"class:`http.client.HTTPMessage` instance."
msgstr ""
"**info** - devolve um objeto semelhante a um dicionário que descreve a "
"página obtida, particularmente os cabeçalhos enviados pelo servidor. "
"Atualmente é uma instância de :class:`http.client.HTTPMessage`."

msgid ""
"Typical headers include 'Content-length', 'Content-type', and so on. See the "
"`Quick Reference to HTTP Headers <https://jkorpela.fi/http.html>`_ for a "
"useful listing of HTTP headers with brief explanations of their meaning and "
"use."
msgstr ""
"Os cabeçalhos típicos incluem 'Content-length', 'Content-type', e assim por "
"diante. Veja a `Referência Rápida para Cabeçalhos HTTP <https://jkorpela.fi/"
"http.html>`_ para uma lista útil de cabeçalhos HTTP com breves explicações "
"sobre o seu significado e uso."

msgid "Openers and Handlers"
msgstr "Openers e Handlers"

msgid ""
"When you fetch a URL you use an opener (an instance of the perhaps "
"confusingly named :class:`urllib.request.OpenerDirector`). Normally we have "
"been using the default opener - via ``urlopen`` - but you can create custom "
"openers. Openers use handlers. All the \"heavy lifting\" is done by the "
"handlers. Each handler knows how to open URLs for a particular URL scheme "
"(http, ftp, etc.), or how to handle an aspect of URL opening, for example "
"HTTP redirections or HTTP cookies."
msgstr ""
"Quando obtém uma URL, utiliza um opener (uma instância do possivelmente "
"confuso :class:`urllib.request.OpenerDirector`). Normalmente temos utilizado "
"o opener predefinido - via ``urlopen`` - mas pode criar openers "
"personalizados. Os openers utilizam handlers. Todo o \"trabalho pesado\" é "
"feito pelos handlers. Cada handler sabe como abrir URLs para um esquema de "
"URL específico (http, ftp, etc.), ou como lidar com um aspeto da abertura da "
"URL, por exemplo, redirecionamentos HTTP ou cookies HTTP."

msgid ""
"You will want to create openers if you want to fetch URLs with specific "
"handlers installed, for example to get an opener that handles cookies, or to "
"get an opener that does not handle redirections."
msgstr ""
"Desejará criar openers se quiser obter URLs com handlers específicos "
"instalados, por exemplo, para obter um opener que lide com cookies, ou para "
"obter um opener que não lide com redirecionamentos."

msgid ""
"To create an opener, instantiate an ``OpenerDirector``, and then call ``."
"add_handler(some_handler_instance)`` repeatedly."
msgstr ""
"Para criar um opener, instancie um ``OpenerDirector`` e, em seguida, chame "
"``.add_handler(instancia_de_algum_handler)`` repetidamente."

msgid ""
"Alternatively, you can use ``build_opener``, which is a convenience function "
"for creating opener objects with a single function call.  ``build_opener`` "
"adds several handlers by default, but provides a quick way to add more and/"
"or override the default handlers."
msgstr ""
"Alternativamente, pode usar o ``build_opener``, que é uma função de "
"conveniência para criar objetos opener com uma única chamada de função. O "
"``build_opener`` adiciona vários handlers por predefinição, mas fornece uma "
"forma rápida de adicionar mais e/ou substituir os handlers predefinidos."

msgid ""
"Other sorts of handlers you might want to can handle proxies, "
"authentication, and other common but slightly specialised situations."
msgstr ""
"Outros tipos de handlers que pode desejar podem lidar com proxies, "
"autenticação e outras situações comuns mas ligeiramente especializadas."

msgid ""
"``install_opener`` can be used to make an ``opener`` object the (global) "
"default opener. This means that calls to ``urlopen`` will use the opener you "
"have installed."
msgstr ""
"O ``install_opener`` pode ser usado para tornar um objeto ``opener`` no "
"opener predefinido (global). Isto significa que as chamadas para ``urlopen`` "
"usarão o opener que instalou."

msgid ""
"Opener objects have an ``open`` method, which can be called directly to "
"fetch urls in the same way as the ``urlopen`` function: there's no need to "
"call ``install_opener``, except as a convenience."
msgstr ""
"Os objetos Opener têm um método ``open``, que pode ser chamado diretamente "
"para obter URLs da mesma forma que a função ``urlopen``: não há necessidade "
"de chamar ``install_opener``, exceto por conveniência."

msgid "Basic Authentication"
msgstr "Autenticação Básica"

msgid ""
"To illustrate creating and installing a handler we will use the "
"``HTTPBasicAuthHandler``. For a more detailed discussion of this subject -- "
"including an explanation of how Basic Authentication works - see the `Basic "
"Authentication Tutorial <https://web.archive.org/web/20201215133350/http://"
"www.voidspace.org.uk/python/articles/authentication.shtml>`__."
msgstr ""
"Para ilustrar a criação e instalação de um manipulador, usaremos o "
"``HTTPBasicAuthHandler``. Para uma discussão mais detalhada sobre este "
"assunto, incluindo uma explicação sobre como funciona a autenticação básica, "
"consulte o `Tutorial de autenticação básica <https://web.archive.org/"
"web/20201215133350/http://www.voidspace.org.uk/python/articles/"
"authentication.shtml>`__."

msgid ""
"When authentication is required, the server sends a header (as well as the "
"401 error code) requesting authentication.  This specifies the "
"authentication scheme and a 'realm'. The header looks like: ``WWW-"
"Authenticate: SCHEME realm=\"REALM\"``."
msgstr ""

msgid "e.g."
msgstr ""

msgid "WWW-Authenticate: Basic realm=\"cPanel Users\""
msgstr ""

msgid ""
"The client should then retry the request with the appropriate name and "
"password for the realm included as a header in the request. This is 'basic "
"authentication'. In order to simplify this process we can create an instance "
"of ``HTTPBasicAuthHandler`` and an opener to use this handler."
msgstr ""

msgid ""
"The ``HTTPBasicAuthHandler`` uses an object called a password manager to "
"handle the mapping of URLs and realms to passwords and usernames. If you "
"know what the realm is (from the authentication header sent by the server), "
"then you can use a ``HTTPPasswordMgr``. Frequently one doesn't care what the "
"realm is. In that case, it is convenient to use "
"``HTTPPasswordMgrWithDefaultRealm``. This allows you to specify a default "
"username and password for a URL. This will be supplied in the absence of you "
"providing an alternative combination for a specific realm. We indicate this "
"by providing ``None`` as the realm argument to the ``add_password`` method."
msgstr ""

msgid ""
"The top-level URL is the first URL that requires authentication. URLs "
"\"deeper\" than the URL you pass to .add_password() will also match. ::"
msgstr ""

msgid ""
"# create a password manager\n"
"password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()\n"
"\n"
"# Add the username and password.\n"
"# If we knew the realm, we could use it instead of None.\n"
"top_level_url = \"http://example.com/foo/\"\n"
"password_mgr.add_password(None, top_level_url, username, password)\n"
"\n"
"handler = urllib.request.HTTPBasicAuthHandler(password_mgr)\n"
"\n"
"# create \"opener\" (OpenerDirector instance)\n"
"opener = urllib.request.build_opener(handler)\n"
"\n"
"# use the opener to fetch a URL\n"
"opener.open(a_url)\n"
"\n"
"# Install the opener.\n"
"# Now all calls to urllib.request.urlopen use our opener.\n"
"urllib.request.install_opener(opener)"
msgstr ""

msgid ""
"In the above example we only supplied our ``HTTPBasicAuthHandler`` to "
"``build_opener``. By default openers have the handlers for normal situations "
"-- ``ProxyHandler`` (if a proxy setting such as an :envvar:`!http_proxy` "
"environment variable is set), ``UnknownHandler``, ``HTTPHandler``, "
"``HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, ``FTPHandler``, "
"``FileHandler``, ``DataHandler``, ``HTTPErrorProcessor``."
msgstr ""

msgid ""
"``top_level_url`` is in fact *either* a full URL (including the 'http:' "
"scheme component and the hostname and optionally the port number) e.g. "
"``\"http://example.com/\"`` *or* an \"authority\" (i.e. the hostname, "
"optionally including the port number) e.g. ``\"example.com\"`` or "
"``\"example.com:8080\"`` (the latter example includes a port number).  The "
"authority, if present, must NOT contain the \"userinfo\" component - for "
"example ``\"joe:password@example.com\"`` is not correct."
msgstr ""

msgid "Proxies"
msgstr "Proxies"

msgid ""
"**urllib** will auto-detect your proxy settings and use those. This is "
"through the ``ProxyHandler``, which is part of the normal handler chain when "
"a proxy setting is detected.  Normally that's a good thing, but there are "
"occasions when it may not be helpful [#]_. One way to do this is to setup "
"our own ``ProxyHandler``, with no proxies defined. This is done using "
"similar steps to setting up a `Basic Authentication`_ handler: ::"
msgstr ""

msgid ""
">>> proxy_support = urllib.request.ProxyHandler({})\n"
">>> opener = urllib.request.build_opener(proxy_support)\n"
">>> urllib.request.install_opener(opener)"
msgstr ""

msgid ""
"Currently ``urllib.request`` *does not* support fetching of ``https`` "
"locations through a proxy.  However, this can be enabled by extending urllib."
"request as shown in the recipe [#]_."
msgstr ""

msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; see "
"the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"``HTTP_PROXY`` será ignorado se uma variável ``REQUEST_METHOD`` estiver "
"definida; veja a documentação em :func:`~urllib.request.getproxies`."

msgid "Sockets and Layers"
msgstr "Sockets e Camadas"

msgid ""
"The Python support for fetching resources from the web is layered.  urllib "
"uses the :mod:`http.client` library, which in turn uses the socket library."
msgstr ""

msgid ""
"As of Python 2.3 you can specify how long a socket should wait for a "
"response before timing out. This can be useful in applications which have to "
"fetch web pages. By default the socket module has *no timeout* and can hang. "
"Currently, the socket timeout is not exposed at the http.client or urllib."
"request levels. However, you can set the default timeout globally for all "
"sockets using ::"
msgstr ""

msgid ""
"import socket\n"
"import urllib.request\n"
"\n"
"# timeout in seconds\n"
"timeout = 10\n"
"socket.setdefaulttimeout(timeout)\n"
"\n"
"# this call to urllib.request.urlopen now uses the default timeout\n"
"# we have set in the socket module\n"
"req = urllib.request.Request('http://www.voidspace.org.uk')\n"
"response = urllib.request.urlopen(req)"
msgstr ""
"import socket\n"
"import urllib.request\n"
"\n"
"# timeout em segundos\n"
"timeout = 10\n"
"socket.setdefaulttimeout(timeout)\n"
"\n"
"# esta chamada a urllib.request.urlopen usa agora o timeout predefinido\n"
"# que configurámos no módulo socket\n"
"req = urllib.request.Request('http://www.voidspace.org.uk')\n"
"response = urllib.request.urlopen(req)"

msgid "Footnotes"
msgstr "Notas de Rodapé"

msgid "This document was reviewed and revised by John Lee."
msgstr ""

msgid "Google for example."
msgstr ""

msgid ""
"Browser sniffing is a very bad practice for website design - building sites "
"using web standards is much more sensible. Unfortunately a lot of sites "
"still send different versions to different browsers."
msgstr ""

msgid ""
"The user agent for MSIE 6 is *'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT "
"5.1; SV1; .NET CLR 1.1.4322)'*"
msgstr ""

msgid ""
"For details of more HTTP request headers, see `Quick Reference to HTTP "
"Headers`_."
msgstr ""

msgid ""
"In my case I have to use a proxy to access the internet at work. If you "
"attempt to fetch *localhost* URLs through this proxy it blocks them. IE is "
"set to use the proxy, which urllib picks up on. In order to test scripts "
"with a localhost server, I have to prevent urllib from using the proxy."
msgstr ""

msgid ""
"urllib opener for SSL proxy (CONNECT method): `ASPN Cookbook Recipe <https://"
"code.activestate.com/recipes/456195-urrlib2-opener-for-ssl-proxy-connect-"
"method/>`_."
msgstr ""
