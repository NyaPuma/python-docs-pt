# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-07 14:20+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!__main__` --- Top-level code environment"
msgstr ":mod:`!__main__` --- Ambiente de código de nível superior"

msgid ""
"In Python, the special name ``__main__`` is used for two important "
"constructs:"
msgstr ""
"Em Python, o nome especial ``__main__`` é utilizado para duas construções "
"importantes:"

msgid ""
"the name of the top-level environment of the program, which can be checked "
"using the ``__name__ == '__main__'`` expression; and"
msgstr ""
"o nome do ambiente de nível superior do programa, que pode ser verificado "
"utilizando a expressão ``__name__ == '__main__'``; e"

msgid "the ``__main__.py`` file in Python packages."
msgstr "o ficheiro ``__main__.py`` em pacotes Python."

msgid ""
"Both of these mechanisms are related to Python modules; how users interact "
"with them and how they interact with each other.  They are explained in "
"detail below.  If you're new to Python modules, see the tutorial section :"
"ref:`tut-modules` for an introduction."
msgstr ""
"Ambos os mecanismos estão relacionados com módulos Python; como os "
"utilizadores interagem com eles e como eles interagem entre si. São "
"explicados detalhadamente abaixo. Se é novo nos módulos Python, consulte a "
"secção :ref:`tut-modules` do tutorial para uma introdução."

msgid "``__name__ == '__main__'``"
msgstr "``__name__ == '__main__'``"

msgid ""
"When a Python module or package is imported, ``__name__`` is set to the "
"module's name.  Usually, this is the name of the Python file itself without "
"the ``.py`` extension::"
msgstr ""
"Quando um módulo ou pacote Python é importado, o ``__name__`` é definido com "
"o nome do módulo. Geralmente, este é o próprio nome do ficheiro Python sem a "
"extensão ``.py``::"

msgid ""
">>> import configparser\n"
">>> configparser.__name__\n"
"'configparser'"
msgstr ""
">>> import configparser\n"
">>> configparser.__name__\n"
"'configparser'"

msgid ""
"If the file is part of a package, ``__name__`` will also include the parent "
"package's path::"
msgstr ""
"Se o ficheiro fizer parte de um pacote, o ``__name__`` incluirá também o "
"caminho do pacote pai::"

msgid ""
">>> from concurrent.futures import process\n"
">>> process.__name__\n"
"'concurrent.futures.process'"
msgstr ""
">>> from concurrent.futures import process\n"
">>> process.__name__\n"
"'concurrent.futures.process'"

msgid ""
"However, if the module is executed in the top-level code environment, its "
"``__name__`` is set to the string ``'__main__'``."
msgstr ""
"No entanto, se o módulo for executado no ambiente de código de nível "
"superior, o seu ``__name__`` é definido para a string ``'__main__'``."

msgid "What is the \"top-level code environment\"?"
msgstr "O que é o \"ambiente de código de nível superior\"?"

msgid ""
"``__main__`` is the name of the environment where top-level code is run. "
"\"Top-level code\" is the first user-specified Python module that starts "
"running. It's \"top-level\" because it imports all other modules that the "
"program needs. Sometimes \"top-level code\" is called an *entry point* to "
"the application."
msgstr ""
"``__main__`` é o nome do ambiente onde o código de nível superior é "
"executado. \"Código de nível superior\" é o primeiro módulo Python "
"especificado pelo utilizador que começa a correr. É de \"nível superior\" "
"porque importa todos os outros módulos de que o programa necessita. Por "
"vezes, o \"código de nível superior\" é chamado de *ponto de entrada* (entry "
"point) da aplicação."

msgid "The top-level code environment can be:"
msgstr "O ambiente de código de nível superior pode ser:"

msgid "the scope of an interactive prompt::"
msgstr "o âmbito de uma consola interativa::"

msgid ""
">>> __name__\n"
"'__main__'"
msgstr ""
">>> __name__\n"
"'__main__'"

msgid "the Python module passed to the Python interpreter as a file argument:"
msgstr ""
"o módulo Python passado ao intérprete Python como um argumento de ficheiro:"

msgid ""
"$ python helloworld.py\n"
"Hello, world!"
msgstr ""
"$ python helloworld.py\n"
"Hello, world!"

msgid ""
"the Python module or package passed to the Python interpreter with the :"
"option:`-m` argument:"
msgstr ""
"o módulo ou pacote Python passado ao intérprete Python com o argumento :"
"option:`-m`:"

msgid ""
"$ python -m tarfile\n"
"usage: tarfile.py [-h] [-v] (...)"
msgstr ""
"$ python -m tarfile\n"
"usage: tarfile.py [-h] [-v] (...)"

msgid "Python code read by the Python interpreter from standard input:"
msgstr ""
"código Python lido pelo intérprete Python a partir da entrada padrão (stdin):"

msgid ""
"$ echo \"import this\" | python\n"
"The Zen of Python, by Tim Peters\n"
"\n"
"Beautiful is better than ugly.\n"
"Explicit is better than implicit.\n"
"..."
msgstr ""
"$ echo \"import this\" | python\n"
"O Zen do Python, por Tim Peters\n"
"\n"
"Bonito é melhor do que feio. \n"
"Explícito é melhor do que implícito.\n"
"..."

msgid ""
"Python code passed to the Python interpreter with the :option:`-c` argument:"
msgstr ""
"código Python passado ao intérprete Python com o argumento :option:`-c`:"

msgid ""
"$ python -c \"import this\"\n"
"The Zen of Python, by Tim Peters\n"
"\n"
"Beautiful is better than ugly.\n"
"Explicit is better than implicit.\n"
"..."
msgstr ""
"$ python -c \"import this\"\n"
"O Zen do Python, por Tim Peters\n"
"\n"
"Bonito é melhor do que feio. \n"
"Explícito é melhor do que implícito.\n"
"..."

msgid ""
"In each of these situations, the top-level module's ``__name__`` is set to "
"``'__main__'``."
msgstr ""
"Em cada uma destas situações, o ``__name__`` do módulo de nível superior é "
"definido para ``'__main__'``."

msgid ""
"As a result, a module can discover whether or not it is running in the top-"
"level environment by checking its own ``__name__``, which allows a common "
"idiom for conditionally executing code when the module is not initialized "
"from an import statement::"
msgstr ""
"Como resultado, um módulo pode descobrir se está ou não a ser executado no "
"ambiente de nível superior verificando o seu próprio ``__name__``, o que "
"permite um idioma comum para executar código condicionalmente quando o "
"módulo não é inicializado a partir de uma instrução import::"

msgid ""
"if __name__ == '__main__':\n"
"    # Execute when the module is not initialized from an import statement.\n"
"    ..."
msgstr ""
"if __name__ == '__main__':\n"
"    # Executa quando o módulo não é inicializado a partir de uma instrução "
"import.\n"
"    ..."

msgid ""
"For a more detailed look at how ``__name__`` is set in all situations, see "
"the tutorial section :ref:`tut-modules`."
msgstr ""
"Para uma análise mais detalhada de como o ``__name__`` é definido em todas "
"as situações, consulte a secção :ref:`tut-modules` do tutorial."

msgid "Idiomatic Usage"
msgstr "Utilização Idiomática"

msgid ""
"Some modules contain code that is intended for script use only, like parsing "
"command-line arguments or fetching data from standard input.  If a module "
"like this was imported from a different module, for example to unit test it, "
"the script code would unintentionally execute as well."
msgstr ""
"Alguns módulos contêm código destinado apenas a utilização como script, como "
"a análise de argumentos da linha de comandos ou a obtenção de dados da "
"entrada padrão. Se um módulo deste tipo fosse importado de um módulo "
"diferente, por exemplo para testes unitários, o código do script seria "
"executado involuntariamente."

msgid ""
"This is where using the ``if __name__ == '__main__'`` code block comes in "
"handy. Code within this block won't run unless the module is executed in the "
"top-level environment."
msgstr ""
"É aqui que a utilização do bloco de código ``if __name__ == '__main__'`` é "
"útil. O código dentro deste bloco não será executado a menos que o módulo "
"seja executado no ambiente de nível superior."

msgid ""
"Putting as few statements as possible in the block below ``if __name__ == "
"'__main__'`` can improve code clarity and correctness. Most often, a "
"function named ``main`` encapsulates the program's primary behavior::"
msgstr ""
"Colocar o menor número possível de instruções no bloco abaixo de ``if "
"__name__ == '__main__'`` pode melhorar a clareza e a correção do código. Na "
"maioria das vezes, uma função chamada ``main`` encapsula o comportamento "
"principal do programa::"

msgid ""
"# echo.py\n"
"\n"
"import shlex\n"
"import sys\n"
"\n"
"def echo(phrase: str) -> None:\n"
"   \"\"\"A dummy wrapper around print.\"\"\"\n"
"   # for demonstration purposes, you can imagine that there is some\n"
"   # valuable and reusable logic inside this function\n"
"   print(phrase)\n"
"\n"
"def main() -> int:\n"
"    \"\"\"Echo the input arguments to standard output\"\"\"\n"
"    phrase = shlex.join(sys.argv)\n"
"    echo(phrase)\n"
"    return 0\n"
"\n"
"if __name__ == '__main__':\n"
"    sys.exit(main())  # next section explains the use of sys.exit"
msgstr ""
"# echo.py\n"
"\n"
"import shlex\n"
"import sys\n"
"\n"
"def echo(phrase: str) -> None:\n"
"   \"\"\"Um wrapper fictício em torno do print.\"\"\"\n"
"   # para fins de demonstração, pode imaginar que existe alguma\n"
"   # lógica valiosa e reutilizável dentro desta função\n"
"   print(phrase)\n"
"\n"
"def main() -> int:\n"
"    \"\"\"Ecoa os argumentos de entrada para a saída padrão\"\"\"\n"
"    phrase = shlex.join(sys.argv)\n"
"    echo(phrase)\n"
"    return 0\n"
"\n"
"if __name__ == '__main__':\n"
"    sys.exit(main())  # a próxima secção explica o uso de sys.exit"

msgid ""
"Note that if the module didn't encapsulate code inside the ``main`` function "
"but instead put it directly within the ``if __name__ == '__main__'`` block, "
"the ``phrase`` variable would be global to the entire module.  This is error-"
"prone as other functions within the module could be unintentionally using "
"the global variable instead of a local name.  A ``main`` function solves "
"this problem."
msgstr ""
"Note que se o módulo não encapsulasse o código dentro da função ``main``, "
"mas o colocasse diretamente dentro do bloco ``if __name__ == '__main__'``, a "
"variável ``phrase`` seria global para todo o módulo. Isto é propenso a "
"erros, pois outras funções dentro do módulo poderiam estar a utilizar "
"involuntariamente a variável global em vez de um nome local. Uma função "
"``main`` resolve este problema."

msgid ""
"Using a ``main`` function has the added benefit of the ``echo`` function "
"itself being isolated and importable elsewhere. When ``echo.py`` is "
"imported, the ``echo`` and ``main`` functions will be defined, but neither "
"of them will be called, because ``__name__ != '__main__'``."
msgstr ""
"A utilização de uma função ``main`` tem o benefício adicional de a própria "
"função ``echo`` ser isolada e importável noutro local. Quando o ``echo.py`` "
"é importado, as funções ``echo`` e ``main`` serão definidas, mas nenhuma "
"delas será chamada, porque ``__name__ != '__main__'``."

msgid "Packaging Considerations"
msgstr "Considerações sobre Empacotamento"

msgid ""
"``main`` functions are often used to create command-line tools by specifying "
"them as entry points for console scripts.  When this is done, `pip <https://"
"pip.pypa.io/>`_ inserts the function call into a template script, where the "
"return value of ``main`` is passed into :func:`sys.exit`. For example::"
msgstr ""
"As funções ``main`` são frequentemente utilizadas para criar ferramentas de "
"linha de comandos, especificando-as como pontos de entrada para scripts de "
"consola. Quando isto é feito, o `pip <https://pip.pypa.io/>`_ insere a "
"chamada da função num script de modelo, onde o valor de retorno de ``main`` "
"é passado para :func:`sys.exit`. Por exemplo::"

msgid "sys.exit(main())"
msgstr "sys.exit(main())"

msgid ""
"Since the call to ``main`` is wrapped in :func:`sys.exit`, the expectation "
"is that your function will return some value acceptable as an input to :func:"
"`sys.exit`; typically, an integer or ``None`` (which is implicitly returned "
"if your function does not have a return statement)."
msgstr ""
"Como a chamada a ``main`` é envolvida em :func:`sys.exit`, a expectativa é "
"que a sua função retorne algum valor aceitável como entrada para :func:`sys."
"exit`; normalmente, um número inteiro ou ``None`` (que é implicitamente "
"retornado se a sua função não tiver uma instrução return)."

msgid ""
"By proactively following this convention ourselves, our module will have the "
"same behavior when run directly (i.e. ``python echo.py``) as it will have if "
"we later package it as a console script entry-point in a pip-installable "
"package."
msgstr ""
"Ao seguirmos proativamente esta convenção, o nosso módulo terá o mesmo "
"comportamento quando executado diretamente (ou seja, ``python echo.py``) que "
"terá se mais tarde o empacotarmos como um ponto de entrada de script de "
"consola num pacote instalável via pip."

msgid ""
"In particular, be careful about returning strings from your ``main`` "
"function. :func:`sys.exit` will interpret a string argument as a failure "
"message, so your program will have an exit code of ``1``, indicating "
"failure, and the string will be written to :data:`sys.stderr`.  The ``echo."
"py`` example from earlier exemplifies using the ``sys.exit(main())`` "
"convention."
msgstr ""
"Em particular, tenha cuidado ao retornar strings da sua função ``main``. :"
"func:`sys.exit` interpretará um argumento de string como uma mensagem de "
"erro, pelo que o seu programa terá um código de saída de ``1``, indicando "
"falha, e a string será escrita em :data:`sys.stderr`. O exemplo ``echo.py`` "
"anterior exemplifica a utilização da convenção ``sys.exit(main())``."

msgid ""
"`Python Packaging User Guide <https://packaging.python.org/>`_ contains a "
"collection of tutorials and references on how to distribute and install "
"Python packages with modern tools."
msgstr ""
"O `Python Packaging User Guide <https://packaging.python.org/>`_ contém uma "
"coleção de tutoriais e referências sobre como distribuir e instalar pacotes "
"Python com ferramentas modernas."

msgid "``__main__.py`` in Python Packages"
msgstr "``__main__.py`` em Pacotes Python"

msgid ""
"If you are not familiar with Python packages, see section :ref:`tut-"
"packages` of the tutorial.  Most commonly, the ``__main__.py`` file is used "
"to provide a command-line interface for a package. Consider the following "
"hypothetical package, \"bandclass\":"
msgstr ""
"Se não está familiarizado com pacotes Python, consulte a secção :ref:`tut-"
"packages` do tutorial. Mais comummente, o ficheiro ``__main__.py`` é "
"utilizado para fornecer uma interface de linha de comandos para um pacote. "
"Considere o seguinte pacote hipotético, \"bandclass\":"

msgid ""
"bandclass\n"
"  ├── __init__.py\n"
"  ├── __main__.py\n"
"  └── student.py"
msgstr ""
"bandclass\n"
"  ├── __init__.py\n"
"  ├── __main__.py\n"
"  └── student.py"

msgid ""
"``__main__.py`` will be executed when the package itself is invoked directly "
"from the command line using the :option:`-m` flag. For example:"
msgstr ""
"O ``__main__.py`` será executado quando o próprio pacote for invocado "
"diretamente da linha de comandos utilizando a flag :option:`-m`. Por exemplo:"

msgid "$ python -m bandclass"
msgstr "$ python -m bandclass"

msgid ""
"This command will cause ``__main__.py`` to run. How you utilize this "
"mechanism will depend on the nature of the package you are writing, but in "
"this hypothetical case, it might make sense to allow the teacher to search "
"for students::"
msgstr ""
"Este comando fará com que o ``__main__.py`` seja executado. A forma como "
"utiliza este mecanismo dependerá da natureza do pacote que está a escrever, "
"mas neste caso hipotético, poderia fazer sentido permitir ao professor "
"procurar alunos::"

msgid ""
"# bandclass/__main__.py\n"
"\n"
"import sys\n"
"from .student import search_students\n"
"\n"
"student_name = sys.argv[1] if len(sys.argv) >= 2 else ''\n"
"print(f'Found student: {search_students(student_name)}')"
msgstr ""
"# bandclass/__main__.py\n"
"\n"
"import sys\n"
"from .student import search_students\n"
"\n"
"student_name = sys.argv[1] if len(sys.argv) >= 2 else ''\n"
"print(f'Aluno encontrado: {search_students(student_name)}')"

msgid ""
"Note that ``from .student import search_students`` is an example of a "
"relative import.  This import style can be used when referencing modules "
"within a package.  For more details, see :ref:`intra-package-references` in "
"the :ref:`tut-modules` section of the tutorial."
msgstr ""
"Note que ``from .student import search_students`` é um exemplo de uma "
"importação relativa. Este estilo de importação pode ser usado ao referenciar "
"módulos dentro de um pacote. Para mais detalhes, consulte :ref:`intra-"
"package-references` na secção :ref:`tut-modules` do tutorial."

msgid ""
"The content of ``__main__.py`` typically isn't fenced with an ``if __name__ "
"== '__main__'`` block.  Instead, those files are kept short and import "
"functions to execute from other modules.  Those other modules can then be "
"easily unit-tested and are properly reusable."
msgstr ""
"O conteúdo de ``__main__.py`` normalmente não é protegido com um bloco ``if "
"__name__ == '__main__'``. Em vez disso, esses ficheiros são mantidos curtos "
"e importam funções de outros módulos para execução. Esses outros módulos "
"podem então ser facilmente testados unitariamente e são devidamente "
"reutilizáveis."

msgid ""
"If used, an ``if __name__ == '__main__'`` block will still work as expected "
"for a ``__main__.py`` file within a package, because its ``__name__`` "
"attribute will include the package's path if imported::"
msgstr ""
"Se utilizado, um bloco ``if __name__ == '__main__'`` continuará a funcionar "
"conforme esperado para um ficheiro ``__main__.py`` dentro de um pacote, "
"porque o seu atributo ``__name__`` incluirá o caminho do pacote se for "
"importado::"

msgid ""
">>> import asyncio.__main__\n"
">>> asyncio.__main__.__name__\n"
"'asyncio.__main__'"
msgstr ""
">>> import asyncio.__main__\n"
">>> asyncio.__main__.__name__\n"
"'asyncio.__main__'"

msgid ""
"This won't work for ``__main__.py`` files in the root directory of a ``."
"zip`` file though.  Hence, for consistency, a minimal ``__main__.py`` "
"without a ``__name__`` check is preferred."
msgstr ""
"No entanto, isto não funcionará para ficheiros ``__main__.py`` no diretório "
"raiz de um ficheiro ``.zip``. Por isso, por consistência, é preferível um "
"``__main__.py`` minimalista sem uma verificação de ``__name__``."

msgid ""
"See :mod:`venv` for an example of a package with a minimal ``__main__.py`` "
"in the standard library. It doesn't contain a ``if __name__ == '__main__'`` "
"block. You can invoke it with ``python -m venv [directory]``."
msgstr ""
"Consulte :mod:`venv` para um exemplo de um pacote com um ``__main__.py`` "
"minimalista na biblioteca padrão. Não contém um bloco ``if __name__ == "
"'__main__'``. Pode invocá-lo com ``python -m venv [directory]``."

msgid ""
"See :mod:`runpy` for more details on the :option:`-m` flag to the "
"interpreter executable."
msgstr ""
"Consulte :mod:`runpy` para mais detalhes sobre a flag :option:`-m` para o "
"executável do intérprete."

msgid ""
"See :mod:`zipapp` for how to run applications packaged as *.zip* files. In "
"this case Python looks for a ``__main__.py`` file in the root directory of "
"the archive."
msgstr ""
"Consulte :mod:`zipapp` sobre como executar aplicações empacotadas como "
"ficheiros *.zip*. Neste caso, o Python procura um ficheiro ``__main__.py`` "
"no diretório raiz do arquivo."

msgid "``import __main__``"
msgstr "``import __main__``"

msgid ""
"Regardless of which module a Python program was started with, other modules "
"running within that same program can import the top-level environment's "
"scope (:term:`namespace`) by importing the ``__main__`` module.  This "
"doesn't import a ``__main__.py`` file but rather whichever module that "
"received the special name ``'__main__'``."
msgstr ""
"Independentemente do módulo com que um programa Python foi iniciado, outros "
"módulos em execução dentro desse mesmo programa podem importar o âmbito (:"
"term:`namespace`) do ambiente de nível superior importando o módulo "
"``__main__``. Isto não importa um ficheiro ``__main__.py``, mas sim qualquer "
"módulo que tenha recebido o nome especial ``'__main__'``."

msgid "Here is an example module that consumes the ``__main__`` namespace::"
msgstr "Aqui está um exemplo de módulo que consome o namespace ``__main__``::"

msgid ""
"# namely.py\n"
"\n"
"import __main__\n"
"\n"
"def did_user_define_their_name():\n"
"    return 'my_name' in dir(__main__)\n"
"\n"
"def print_user_name():\n"
"    if not did_user_define_their_name():\n"
"        raise ValueError('Define the variable `my_name`!')\n"
"\n"
"    print(__main__.my_name)"
msgstr ""
"# namely.py\n"
"\n"
"import __main__\n"
"\n"
"def did_user_define_their_name():\n"
"    return 'my_name' in dir(__main__)\n"
"\n"
"def print_user_name():\n"
"    if not did_user_define_their_name():\n"
"        raise ValueError('Define the variable `my_name`!')\n"
"\n"
"    print(__main__.my_name)"

msgid "Example usage of this module could be as follows::"
msgstr "Um exemplo de utilização deste módulo poderia ser o seguinte::"

msgid ""
"# start.py\n"
"\n"
"import sys\n"
"\n"
"from namely import print_user_name\n"
"\n"
"# my_name = \"Dinsdale\"\n"
"\n"
"def main():\n"
"    try:\n"
"        print_user_name()\n"
"    except ValueError as ve:\n"
"        return str(ve)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    sys.exit(main())"
msgstr ""
"# start.py\n"
"\n"
"import sys\n"
"\n"
"from namely import print_user_name\n"
"\n"
"# my_name = \"Dinsdale\"\n"
"\n"
"def main():\n"
"    try:\n"
"        print_user_name()\n"
"    except ValueError as ve:\n"
"        return str(ve)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    sys.exit(main())"

msgid "Now, if we started our program, the result would look like this:"
msgstr "Agora, se iniciássemos o nosso programa, o resultado seria este:"

msgid ""
"$ python start.py\n"
"Define the variable `my_name`!"
msgstr ""
"$ python start.py\n"
"Defina a variável `meu_nome`!"

msgid ""
"The exit code of the program would be 1, indicating an error. Uncommenting "
"the line with ``my_name = \"Dinsdale\"`` fixes the program and now it exits "
"with status code 0, indicating success:"
msgstr ""
"O código de saída do programa seria 1, indicando um erro. Descomentar a "
"linha com ``meu_nome = \"Dinsdale\"`` corrige o programa e agora ele sai com "
"o código de estado 0, indicando sucesso:"

msgid ""
"$ python start.py\n"
"Dinsdale"
msgstr ""
"$ python start.py\n"
"Dinsdale"

msgid ""
"Note that importing ``__main__`` doesn't cause any issues with "
"unintentionally running top-level code meant for script use which is put in "
"the ``if __name__ == \"__main__\"`` block of the ``start`` module. Why does "
"this work?"
msgstr ""
"Note que importar ``__main__`` não causa quaisquer problemas de execução "
"involuntária de código de nível superior destinado a script que esteja "
"colocado no bloco ``if __name__ == \"__main__\"`` do módulo ``start``. "
"Porque é que isto funciona?"

msgid ""
"Python inserts an empty ``__main__`` module in :data:`sys.modules` at "
"interpreter startup, and populates it by running top-level code. In our "
"example this is the ``start`` module which runs line by line and imports "
"``namely``. In turn, ``namely`` imports ``__main__`` (which is really "
"``start``). That's an import cycle! Fortunately, since the partially "
"populated ``__main__`` module is present in :data:`sys.modules`, Python "
"passes that to ``namely``. See :ref:`Special considerations for __main__ "
"<import-dunder-main>` in the import system's reference for details on how "
"this works."
msgstr ""
"O Python insere um módulo ``__main__`` vazio em :data:`sys.modules` no "
"arranque do intérprete, e povoa-o executando o código de nível superior. No "
"nosso exemplo, este é o módulo ``start`` que corre linha a linha e importa o "
"``namely``. Por sua vez, o ``namely`` importa o ``__main__`` (que é, na "
"verdade, o ``start``). Isso é um ciclo de importação! Felizmente, como o "
"módulo ``__main__`` parcialmente povoado está presente em :data:`sys."
"modules`, o Python passa-o ao ``namely``. Consulte :ref:`Considerações "
"especiais para __main__ <import-dunder-main>` na referência do sistema de "
"importação para detalhes sobre como isto funciona."

msgid ""
"The Python REPL is another example of a \"top-level environment\", so "
"anything defined in the REPL becomes part of the ``__main__`` scope::"
msgstr ""
"O REPL do Python é outro exemplo de um \"ambiente de nível superior\", pelo "
"que qualquer coisa definida no REPL torna-se parte do âmbito ``__main__``::"

msgid ""
">>> import namely\n"
">>> namely.did_user_define_their_name()\n"
"False\n"
">>> namely.print_user_name()\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Define the variable `my_name`!\n"
">>> my_name = 'Jabberwocky'\n"
">>> namely.did_user_define_their_name()\n"
"True\n"
">>> namely.print_user_name()\n"
"Jabberwocky"
msgstr ""
">>> import namely\n"
">>> namely.did_user_define_their_name()\n"
"False\n"
">>> namely.print_user_name()\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Define the variable `my_name`!\n"
">>> my_name = 'Jabberwocky'\n"
">>> namely.did_user_define_their_name()\n"
"True\n"
">>> namely.print_user_name()\n"
"Jabberwocky"

msgid ""
"The ``__main__`` scope is used in the implementation of :mod:`pdb` and :mod:"
"`rlcompleter`."
msgstr ""
"O âmbito ``__main__`` é utilizado na implementação de :mod:`pdb` e :mod:"
"`rlcompleter`."
