# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-03 14:40+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!abc` --- Abstract Base Classes"
msgstr ":mod:`!abc` --- Classes de Base Abstratas (ABCs)"

msgid "**Source code:** :source:`Lib/abc.py`"
msgstr "**Código-fonte:** :source:`Lib/abc.py`"

msgid ""
"This module provides the infrastructure for defining :term:`abstract base "
"classes <abstract base class>` (ABCs) in Python, as outlined in :pep:`3119`; "
"see the PEP for why this was added to Python. (See also :pep:`3141` and the :"
"mod:`numbers` module regarding a type hierarchy for numbers based on ABCs.)"
msgstr ""
"Este módulo fornece a infraestrutura para definir :term:`classes de base "
"abstratas <abstract base class>` (ABCs) em Python, conforme descrito na :pep:"
"`3119`; consulte a PEP para entender por que isto foi adicionado ao Python. "
"(Consulte também a :pep:`3141` e o módulo :mod:`numbers` relativamente a uma "
"hierarquia de tipos para números baseada em ABCs.)"

msgid ""
"The :mod:`collections` module has some concrete classes that derive from "
"ABCs; these can, of course, be further derived. In addition, the :mod:"
"`collections.abc` submodule has some ABCs that can be used to test whether a "
"class or instance provides a particular interface, for example, if it is :"
"term:`hashable` or if it is a :term:`mapping`."
msgstr ""
"O módulo :mod:`collections` possui algumas classes concretas que derivam de "
"ABCs; estas podem, naturalmente, ser novamente derivadas. Além disso, o "
"submódulo :mod:`collections.abc` possui algumas ABCs que podem ser usadas "
"para testar se uma classe ou instância fornece uma interface específica, por "
"exemplo, se é :term:`hashable` (dispersável) ou se é um :term:`mapping` "
"(mapeamento)."

msgid ""
"This module provides the metaclass :class:`ABCMeta` for defining ABCs and a "
"helper class :class:`ABC` to alternatively define ABCs through inheritance:"
msgstr ""
"Este módulo fornece a metaclasse :class:`ABCMeta` para definir ABCs e uma "
"classe auxiliar :class:`ABC` para definir ABCs alternativamente através de "
"herança:"

msgid ""
"A helper class that has :class:`ABCMeta` as its metaclass.  With this class, "
"an abstract base class can be created by simply deriving from :class:`!ABC` "
"avoiding sometimes confusing metaclass usage, for example::"
msgstr ""
"Uma classe auxiliar que tem :class:`ABCMeta` como sua metaclasse. Com esta "
"classe, uma classe de base abstrata pode ser criada simplesmente derivando "
"de :class:`!ABC`, evitando o uso por vezes confuso de metaclasses, por "
"exemplo::"

msgid ""
"from abc import ABC\n"
"\n"
"class MyABC(ABC):\n"
"    pass"
msgstr ""
"from abc import ABC\n"
"\n"
"class MyABC(ABC):\n"
"    pass"

msgid ""
"Note that the type of :class:`!ABC` is still :class:`ABCMeta`, therefore "
"inheriting from :class:`!ABC` requires the usual precautions regarding "
"metaclass usage, as multiple inheritance may lead to metaclass conflicts. "
"One may also define an abstract base class by passing the metaclass keyword "
"and using :class:`!ABCMeta` directly, for example::"
msgstr ""
"Note que o tipo de :class:`!ABC` ainda é :class:`ABCMeta`, portanto, herdar "
"de :class:`!ABC` requer as precauções habituais relativas ao uso de "
"metaclasses, uma vez que a herança múltipla pode levar a conflitos de "
"metaclasses. Também se pode definir uma classe de base abstrata passando a "
"palavra-chave metaclass e usando :class:`!ABCMeta` diretamente, por exemplo::"

msgid ""
"from abc import ABCMeta\n"
"\n"
"class MyABC(metaclass=ABCMeta):\n"
"    pass"
msgstr ""
"from abc import ABCMeta\n"
"\n"
"class MyABC(metaclass=ABCMeta):\n"
"    pass"

msgid "Metaclass for defining Abstract Base Classes (ABCs)."
msgstr "Metaclasse para definir Classes de Base Abstratas (ABCs)."

msgid ""
"Use this metaclass to create an ABC.  An ABC can be subclassed directly, and "
"then acts as a mix-in class.  You can also register unrelated concrete "
"classes (even built-in classes) and unrelated ABCs as \"virtual subclasses\" "
"-- these and their descendants will be considered subclasses of the "
"registering ABC by the built-in :func:`issubclass` function, but the "
"registering ABC won't show up in their MRO (Method Resolution Order) nor "
"will method implementations defined by the registering ABC be callable (not "
"even via :func:`super`). [#]_"
msgstr ""
"Use esta metaclasse para criar uma ABC. Uma ABC pode ser diretamente herdada "
"por subclasses, atuando então como uma classe mix-in. Também pode registar "
"classes concretas não relacionadas (mesmo classes integradas) e ABCs não "
"relacionadas como \"subclasses virtuais\" -- estas e os seus descendentes "
"serão considerados subclasses da ABC de registo pela função integrada :func:"
"`issubclass`, mas a ABC de registo não aparecerá na MRO (Method Resolution "
"Order) das mesmas, nem as implementações de métodos definidas pela ABC de "
"registo serão chamáveis (nem mesmo via :func:`super`). [#]_"

msgid ""
"Classes created with a metaclass of :class:`!ABCMeta` have the following "
"method:"
msgstr ""
"As classes criadas com a metaclasse :class:`!ABCMeta` possuem o seguinte "
"método:"

msgid ""
"Register *subclass* as a \"virtual subclass\" of this ABC. For example::"
msgstr ""
"Regista *subclass* como uma \"subclasse virtual\" desta ABC. Por exemplo::"

msgid ""
"from abc import ABC\n"
"\n"
"class MyABC(ABC):\n"
"    pass\n"
"\n"
"MyABC.register(tuple)\n"
"\n"
"assert issubclass(tuple, MyABC)\n"
"assert isinstance((), MyABC)"
msgstr ""
"from abc import ABC\n"
"\n"
"class MyABC(ABC):\n"
"    pass\n"
"\n"
"MyABC.register(tuple)\n"
"\n"
"assert issubclass(tuple, MyABC)\n"
"assert isinstance((), MyABC)"

msgid "Returns the registered subclass, to allow usage as a class decorator."
msgstr ""
"Retorna a subclasse registada, para permitir a utilização como decorador de "
"classe."

msgid ""
"To detect calls to :meth:`!register`, you can use the :func:"
"`get_cache_token` function."
msgstr ""
"Para detetar chamadas a :meth:`!register`, pode usar a função :func:"
"`get_cache_token`."

msgid "You can also override this method in an abstract base class:"
msgstr "Também pode sobrepor este método numa classe de base abstrata:"

msgid "(Must be defined as a class method.)"
msgstr "(Deve ser definido como um método de classe.)"

msgid ""
"Check whether *subclass* is considered a subclass of this ABC.  This means "
"that you can customize the behavior of :func:`issubclass` further without "
"the need to call :meth:`register` on every class you want to consider a "
"subclass of the ABC.  (This class method is called from the :meth:`~type."
"__subclasscheck__` method of the ABC.)"
msgstr ""
"Verifica se *subclass* é considerada uma subclasse desta ABC. Isto significa "
"que pode personalizar ainda mais o comportamento de :func:`issubclass` sem a "
"necessidade de chamar :meth:`register` em cada classe que queira considerar "
"como subclasse da ABC. (Este método de classe é chamado a partir do método :"
"meth:`~type.__subclasscheck__` da ABC.)"

msgid ""
"This method should return ``True``, ``False`` or :data:`NotImplemented`.  If "
"it returns ``True``, the *subclass* is considered a subclass of this ABC. If "
"it returns ``False``, the *subclass* is not considered a subclass of this "
"ABC, even if it would normally be one.  If it returns :data:`!"
"NotImplemented`, the subclass check is continued with the usual mechanism."
msgstr ""
"Este método deve retornar ``True``, ``False`` ou :data:`NotImplemented`. Se "
"retornar ``True``, a *subclass* é considerada uma subclasse desta ABC. Se "
"retornar ``False``, a *subclass* não é considerada uma subclasse desta ABC, "
"mesmo que normalmente o fosse. Se retornar :data:`!NotImplemented`, a "
"verificação de subclasse continua com o mecanismo habitual."

msgid ""
"For a demonstration of these concepts, look at this example ABC definition::"
msgstr ""
"Para uma demonstração destes conceitos, veja este exemplo de definição de "
"ABC::"

msgid ""
"class Foo:\n"
"    def __getitem__(self, index):\n"
"        ...\n"
"    def __len__(self):\n"
"        ...\n"
"    def get_iterator(self):\n"
"        return iter(self)\n"
"\n"
"class MyIterable(ABC):\n"
"\n"
"    @abstractmethod\n"
"    def __iter__(self):\n"
"        while False:\n"
"            yield None\n"
"\n"
"    def get_iterator(self):\n"
"        return self.__iter__()\n"
"\n"
"    @classmethod\n"
"    def __subclasshook__(cls, C):\n"
"        if cls is MyIterable:\n"
"            if any(\"__iter__\" in B.__dict__ for B in C.__mro__):\n"
"                return True\n"
"        return NotImplemented\n"
"\n"
"MyIterable.register(Foo)"
msgstr ""
"class Foo:\n"
"    def __getitem__(self, index):\n"
"        ...\n"
"    def __len__(self):\n"
"        ...\n"
"    def get_iterator(self):\n"
"        return iter(self)\n"
"\n"
"class MyIterable(ABC):\n"
"\n"
"    @abstractmethod\n"
"    def __iter__(self):\n"
"        while False:\n"
"            yield None\n"
"\n"
"    def get_iterator(self):\n"
"        return self.__iter__()\n"
"\n"
"    @classmethod\n"
"    def __subclasshook__(cls, C):\n"
"        if cls is MyIterable:\n"
"            if any(\"__iter__\" in B.__dict__ for B in C.__mro__):\n"
"                return True\n"
"        return NotImplemented\n"
"\n"
"MyIterable.register(Foo)"

msgid ""
"The ABC ``MyIterable`` defines the standard iterable method, :meth:`~object."
"__iter__`, as an abstract method.  The implementation given here can still "
"be called from subclasses.  The :meth:`!get_iterator` method is also part of "
"the ``MyIterable`` abstract base class, but it does not have to be "
"overridden in non-abstract derived classes."
msgstr ""
"A ABC ``MyIterable`` define o método iterável padrão, :meth:`~object."
"__iter__`, como um método abstrato. A implementação aqui fornecida ainda "
"pode ser chamada por subclasses. O método :meth:`!get_iterator` também faz "
"parte da classe de base abstrata ``MyIterable``, mas não tem de ser "
"sobreposto em classes derivadas não abstratas."

msgid ""
"The :meth:`__subclasshook__` class method defined here says that any class "
"that has an :meth:`~object.__iter__` method in its :attr:`~object.__dict__` "
"(or in that of one of its base classes, accessed via the :attr:`~type."
"__mro__` list) is considered a ``MyIterable`` too."
msgstr ""
"O método de classe :meth:`__subclasshook__` aqui definido estabelece que "
"qualquer classe que tenha um método :meth:`~object.__iter__` no seu :attr:"
"`~object.__dict__` (ou no de uma das suas classes base, acedido através da "
"lista :attr:`~type.__mro__`) é também considerada uma ``MyIterable``."

msgid ""
"Finally, the last line makes ``Foo`` a virtual subclass of ``MyIterable``, "
"even though it does not define an :meth:`~object.__iter__` method (it uses "
"the old-style iterable protocol, defined in terms of :meth:`~object.__len__` "
"and :meth:`~object.__getitem__`).  Note that this will not make "
"``get_iterator`` available as a method of ``Foo``, so it is provided "
"separately."
msgstr ""
"Finalmente, a última linha torna ``Foo`` uma subclasse virtual de "
"``MyIterable``, mesmo que não defina um método :meth:`~object.__iter__` "
"(utiliza o protocolo iterável de estilo antigo, definido em termos de :meth:"
"`~object.__len__` e :meth:`~object.__getitem__`). Note que isto não tornará "
"o método ``get_iterator`` disponível em ``Foo``, por isso este é fornecido "
"separadamente."

msgid "The :mod:`!abc` module also provides the following decorator:"
msgstr "O módulo :mod:`!abc` também fornece o seguinte decorador:"

msgid "A decorator indicating abstract methods."
msgstr "Um decorador que indica métodos abstratos."

msgid ""
"Using this decorator requires that the class's metaclass is :class:`ABCMeta` "
"or is derived from it.  A class that has a metaclass derived from :class:`!"
"ABCMeta` cannot be instantiated unless all of its abstract methods and "
"properties are overridden.  The abstract methods can be called using any of "
"the normal 'super' call mechanisms.  :func:`!abstractmethod` may be used to "
"declare abstract methods for properties and descriptors."
msgstr ""
"O uso deste decorador requer que a metaclasse da classe seja :class:"
"`ABCMeta` ou seja derivada desta. Uma classe que tenha uma metaclasse "
"derivada de :class:`!ABCMeta` não pode ser instanciada a menos que todos os "
"seus métodos e propriedades abstratos sejam sobrepostos. Os métodos "
"abstratos podem ser chamados usando qualquer um dos mecanismos normais de "
"chamada 'super'. :func:`!abstractmethod` pode ser usado para declarar "
"métodos abstratos para propriedades e descritores."

msgid ""
"Dynamically adding abstract methods to a class, or attempting to modify the "
"abstraction status of a method or class once it is created, are only "
"supported using the :func:`update_abstractmethods` function.  The :func:`!"
"abstractmethod` only affects subclasses derived using regular inheritance; "
"\"virtual subclasses\" registered with the ABC's :meth:`~ABCMeta.register` "
"method are not affected."
msgstr ""
"A adição dinâmica de métodos abstratos a uma classe, ou a tentativa de "
"modificar o estado de abstração de um método ou classe após a sua criação, "
"só é suportada usando a função :func:`update_abstractmethods`. O decorador :"
"func:`!abstractmethod` apenas afeta subclasses derivadas por herança "
"regular; as \"subclasses virtuais\" registadas com o método :meth:`~ABCMeta."
"register` da ABC não são afetadas."

msgid ""
"When :func:`!abstractmethod` is applied in combination with other method "
"descriptors, it should be applied as the innermost decorator, as shown in "
"the following usage examples::"
msgstr ""
"Quando :func:`!abstractmethod` é aplicado em combinação com outros "
"descritores de método, deve ser aplicado como o decorador mais interno, "
"conforme mostrado nos seguintes exemplos de utilização::"

msgid ""
"class C(ABC):\n"
"    @abstractmethod\n"
"    def my_abstract_method(self, arg1):\n"
"        ...\n"
"    @classmethod\n"
"    @abstractmethod\n"
"    def my_abstract_classmethod(cls, arg2):\n"
"        ...\n"
"    @staticmethod\n"
"    @abstractmethod\n"
"    def my_abstract_staticmethod(arg3):\n"
"        ...\n"
"\n"
"    @property\n"
"    @abstractmethod\n"
"    def my_abstract_property(self):\n"
"        ...\n"
"    @my_abstract_property.setter\n"
"    @abstractmethod\n"
"    def my_abstract_property(self, val):\n"
"        ...\n"
"\n"
"    @abstractmethod\n"
"    def _get_x(self):\n"
"        ...\n"
"    @abstractmethod\n"
"    def _set_x(self, val):\n"
"        ...\n"
"    x = property(_get_x, _set_x)"
msgstr ""
"class C(ABC):\n"
"    @abstractmethod\n"
"    def my_abstract_method(self, arg1):\n"
"        ...\n"
"    @classmethod\n"
"    @abstractmethod\n"
"    def my_abstract_classmethod(cls, arg2):\n"
"        ...\n"
"    @staticmethod\n"
"    @abstractmethod\n"
"    def my_abstract_staticmethod(arg3):\n"
"        ...\n"
"\n"
"    @property\n"
"    @abstractmethod\n"
"    def my_abstract_property(self):\n"
"        ...\n"
"    @my_abstract_property.setter\n"
"    @abstractmethod\n"
"    def my_abstract_property(self, val):\n"
"        ...\n"
"\n"
"    @abstractmethod\n"
"    def _get_x(self):\n"
"        ...\n"
"    @abstractmethod\n"
"    def _set_x(self, val):\n"
"        ...\n"
"    x = property(_get_x, _set_x)"

msgid ""
"In order to correctly interoperate with the abstract base class machinery, "
"the descriptor must identify itself as abstract using :attr:`!"
"__isabstractmethod__`. In general, this attribute should be ``True`` if any "
"of the methods used to compose the descriptor are abstract. For example, "
"Python's built-in :class:`property` does the equivalent of::"
msgstr ""
"Para interoperar corretamente com o mecanismo de classes de base abstratas, "
"o descritor deve identificar-se como abstrato usando :attr:`!"
"__isabstractmethod__`. Em geral, este atributo deve ser ``True`` se algum "
"dos métodos usados para compor o descritor for abstrato. Por exemplo, a :"
"class:`property` integrada do Python faz o equivalente a::"

msgid ""
"class Descriptor:\n"
"    ...\n"
"    @property\n"
"    def __isabstractmethod__(self):\n"
"        return any(getattr(f, '__isabstractmethod__', False) for\n"
"                   f in (self._fget, self._fset, self._fdel))"
msgstr ""
"class Descriptor:\n"
"    ...\n"
"    @property\n"
"    def __isabstractmethod__(self):\n"
"        return any(getattr(f, '__isabstractmethod__', False) for\n"
"                   f in (self._fget, self._fset, self._fdel))"

msgid ""
"Unlike Java abstract methods, these abstract methods may have an "
"implementation. This implementation can be called via the :func:`super` "
"mechanism from the class that overrides it.  This could be useful as an end-"
"point for a super-call in a framework that uses cooperative multiple-"
"inheritance."
msgstr ""
"Ao contrário dos métodos abstratos em Java, estes métodos abstratos podem "
"ter uma implementação. Esta implementação pode ser chamada via mecanismo :"
"func:`super` a partir da classe que o sobrepõe. Isto pode ser útil como um "
"ponto final para uma chamada super numa arquitetura que utilize herança "
"múltipla cooperativa."

msgid "The :mod:`!abc` module also supports the following legacy decorators:"
msgstr "O módulo :mod:`!abc` também suporta os seguintes decoradores legados:"

msgid ""
"It is now possible to use :class:`classmethod` with :func:`abstractmethod`, "
"making this decorator redundant."
msgstr ""
"Agora é possível usar :class:`classmethod` com :func:`abstractmethod`, "
"tornando este decorador redundante."

msgid ""
"A subclass of the built-in :func:`classmethod`, indicating an abstract "
"classmethod. Otherwise it is similar to :func:`abstractmethod`."
msgstr ""
"Uma subclasse do :func:`classmethod` integrado, indicando um método de "
"classe abstrato. De resto, é semelhante ao :func:`abstractmethod`."

msgid ""
"This special case is deprecated, as the :func:`classmethod` decorator is now "
"correctly identified as abstract when applied to an abstract method::"
msgstr ""
"Este caso especial foi descontinuado (deprecated), uma vez que o decorador :"
"func:`classmethod` é agora corretamente identificado como abstrato quando "
"aplicado a um método abstrato::"

msgid ""
"class C(ABC):\n"
"    @classmethod\n"
"    @abstractmethod\n"
"    def my_abstract_classmethod(cls, arg):\n"
"        ..."
msgstr ""
"class C(ABC):\n"
"    @classmethod\n"
"    @abstractmethod\n"
"    def my_abstract_classmethod(cls, arg):\n"
"        ..."

msgid ""
"It is now possible to use :class:`staticmethod` with :func:`abstractmethod`, "
"making this decorator redundant."
msgstr ""
"Agora é possível usar :class:`staticmethod` com :func:`abstractmethod`, "
"tornando este decorador redundante."

msgid ""
"A subclass of the built-in :func:`staticmethod`, indicating an abstract "
"staticmethod. Otherwise it is similar to :func:`abstractmethod`."
msgstr ""
"Uma subclasse do :func:`staticmethod` integrado, indicando um método "
"estático abstrato. De resto, é semelhante ao :func:`abstractmethod`."

msgid ""
"This special case is deprecated, as the :func:`staticmethod` decorator is "
"now correctly identified as abstract when applied to an abstract method::"
msgstr ""
"Este caso especial foi descontinuado, uma vez que o decorador :func:"
"`staticmethod` é agora corretamente identificado como abstrato quando "
"aplicado a um método abstrato::"

msgid ""
"class C(ABC):\n"
"    @staticmethod\n"
"    @abstractmethod\n"
"    def my_abstract_staticmethod(arg):\n"
"        ..."
msgstr ""
"class C(ABC):\n"
"    @staticmethod\n"
"    @abstractmethod\n"
"    def my_abstract_staticmethod(arg):\n"
"        ..."

msgid ""
"It is now possible to use :class:`property`, :meth:`property.getter`, :meth:"
"`property.setter` and :meth:`property.deleter` with :func:`abstractmethod`, "
"making this decorator redundant."
msgstr ""
"Agora é possível usar :class:`property`, :meth:`property.getter`, :meth:"
"`property.setter` e :meth:`property.deleter` com :func:`abstractmethod`, "
"tornando este decorador redundante."

msgid ""
"A subclass of the built-in :func:`property`, indicating an abstract property."
msgstr ""
"Uma subclasse da :func:`property` integrada, indicando uma propriedade "
"abstrata."

msgid ""
"This special case is deprecated, as the :func:`property` decorator is now "
"correctly identified as abstract when applied to an abstract method::"
msgstr ""
"Este caso especial foi descontinuado, uma vez que o decorador :func:"
"`property` é agora corretamente identificado como abstrato quando aplicado a "
"um método abstrato::"

msgid ""
"class C(ABC):\n"
"    @property\n"
"    @abstractmethod\n"
"    def my_abstract_property(self):\n"
"        ..."
msgstr ""
"class C(ABC):\n"
"    @property\n"
"    @abstractmethod\n"
"    def my_abstract_property(self):\n"
"        ..."

msgid ""
"The above example defines a read-only property; you can also define a read-"
"write abstract property by appropriately marking one or more of the "
"underlying methods as abstract::"
msgstr ""
"O exemplo acima define uma propriedade de apenas leitura; também pode "
"definir uma propriedade abstrata de leitura e escrita marcando "
"apropriadamente um ou mais dos métodos subjacentes como abstratos::"

msgid ""
"class C(ABC):\n"
"    @property\n"
"    def x(self):\n"
"        ...\n"
"\n"
"    @x.setter\n"
"    @abstractmethod\n"
"    def x(self, val):\n"
"        ..."
msgstr ""
"class C(ABC):\n"
"    @property\n"
"    def x(self):\n"
"        ...\n"
"\n"
"    @x.setter\n"
"    @abstractmethod\n"
"    def x(self, val):\n"
"        ..."

msgid ""
"If only some components are abstract, only those components need to be "
"updated to create a concrete property in a subclass::"
msgstr ""
"Se apenas alguns componentes forem abstratos, apenas esses componentes "
"precisam de ser atualizados para criar uma propriedade concreta numa "
"subclasse::"

msgid ""
"class D(C):\n"
"    @C.x.setter\n"
"    def x(self, val):\n"
"        ..."
msgstr ""
"class D(C):\n"
"    @C.x.setter\n"
"    def x(self, val):\n"
"        ..."

msgid "The :mod:`!abc` module also provides the following functions:"
msgstr "O módulo :mod:`!abc` também fornece as seguintes funções:"

msgid "Returns the current abstract base class cache token."
msgstr "Retorna o *token* de cache atual da classe de base abstrata."

msgid ""
"The token is an opaque object (that supports equality testing) identifying "
"the current version of the abstract base class cache for virtual subclasses. "
"The token changes with every call to :meth:`ABCMeta.register` on any ABC."
msgstr ""
"O token é um objeto opaco (que suporta testes de igualdade) que identifica a "
"versão atual da cache da classe de base abstrata para subclasses virtuais. O "
"token muda a cada chamada a :meth:`ABCMeta.register` em qualquer ABC."

msgid ""
"A function to recalculate an abstract class's abstraction status. This "
"function should be called if a class's abstract methods have been "
"implemented or changed after it was created. Usually, this function should "
"be called from within a class decorator."
msgstr ""
"Uma função para recalcular o estado de abstração de uma classe abstrata. "
"Esta função deve ser chamada se os métodos abstratos de uma classe foram "
"implementados ou alterados após a sua criação. Geralmente, esta função deve "
"ser chamada de dentro de um decorador de classe."

msgid "Returns *cls*, to allow usage as a class decorator."
msgstr "Retorna *cls*, para permitir a utilização como decorador de classe."

msgid "If *cls* is not an instance of :class:`ABCMeta`, does nothing."
msgstr "Se *cls* não for uma instância de :class:`ABCMeta`, não faz nada."

msgid ""
"This function assumes that *cls*'s superclasses are already updated. It does "
"not update any subclasses."
msgstr ""
"Esta função assume que as superclasses de *cls* já estão atualizadas. Não "
"atualiza nenhuma subclasse."

msgid "Footnotes"
msgstr "Notas de rodapé"

msgid ""
"C++ programmers should note that Python's virtual base class concept is not "
"the same as C++'s."
msgstr ""
"Programadores de C++ devem notar que o conceito de classe base virtual do "
"Python não é o mesmo que o do C++."
