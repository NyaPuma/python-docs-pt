# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-07 14:20+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!array` --- Efficient arrays of numeric values"
msgstr ":mod:`!array` --- Arrays eficientes de valores numéricos"

msgid ""
"This module defines an object type which can compactly represent an array of "
"basic values: characters, integers, floating-point numbers.  Arrays are "
"mutable :term:`sequence` types and behave very much like lists, except that "
"the type of objects stored in them is constrained.  The type is specified at "
"object creation time by using a :dfn:`type code`, which is a single "
"character.  The following type codes are defined:"
msgstr ""
"Este módulo define um tipo de objeto que pode representar de forma compacta "
"um array de valores básicos: caracteres, inteiros, números de ponto "
"flutuante. Os arrays são tipos de :term:`sequência` mutáveis e comportam-se "
"de forma muito semelhante às listas, exceto que o tipo de objetos "
"armazenados neles é restrito. O tipo é especificado no momento da criação do "
"objeto usando um :dfn:`código de tipo`, que é um único carácter. São "
"definidos os seguintes códigos de tipo:"

msgid "Type code"
msgstr "Código de tipo"

msgid "C Type"
msgstr "Tipo C"

msgid "Python Type"
msgstr "Tipo Python"

msgid "Minimum size in bytes"
msgstr "Tamanho mínimo em bytes"

msgid "Notes"
msgstr "Notas"

msgid "``'b'``"
msgstr "``'b'``"

msgid "signed char"
msgstr "signed char"

msgid "int"
msgstr "int"

msgid "1"
msgstr "1"

msgid "``'B'``"
msgstr "``'B'``"

msgid "unsigned char"
msgstr "unsigned char"

msgid "``'u'``"
msgstr "``'u'``"

msgid "wchar_t"
msgstr "wchar_t"

msgid "Unicode character"
msgstr "Carácter Unicode"

msgid "2"
msgstr "2"

msgid "\\(1)"
msgstr "(1)"

msgid "``'w'``"
msgstr "``'w'``"

msgid "Py_UCS4"
msgstr "Py_UCS4"

msgid "4"
msgstr "4"

msgid "\\(2)"
msgstr "(2)"

msgid "``'h'``"
msgstr "``'h'``"

msgid "signed short"
msgstr "signed short"

msgid "``'H'``"
msgstr "``'H'``"

msgid "unsigned short"
msgstr "unsigned short"

msgid "``'i'``"
msgstr "``'i'``"

msgid "signed int"
msgstr "signed int"

msgid "``'I'``"
msgstr "``'I'``"

msgid "unsigned int"
msgstr "unsigned int"

msgid "``'l'``"
msgstr "``'l'``"

msgid "signed long"
msgstr "signed long"

msgid "``'L'``"
msgstr "``'L'``"

msgid "unsigned long"
msgstr "unsigned long"

msgid "``'q'``"
msgstr "``'q'``"

msgid "signed long long"
msgstr "signed long long"

msgid "8"
msgstr "8"

msgid "``'Q'``"
msgstr "``'Q'``"

msgid "unsigned long long"
msgstr "unsigned long long"

msgid "``'f'``"
msgstr "``'f'``"

msgid "float"
msgstr "float"

msgid "``'d'``"
msgstr "``'d'``"

msgid "double"
msgstr "double"

msgid "Notes:"
msgstr "Notas:"

msgid "It can be 16 bits or 32 bits depending on the platform."
msgstr "Pode ser de 16 bits ou 32 bits dependendo da plataforma."

msgid ""
"``array('u')`` now uses :c:type:`wchar_t` as C type instead of deprecated "
"``Py_UNICODE``. This change doesn't affect its behavior because "
"``Py_UNICODE`` is alias of :c:type:`wchar_t` since Python 3.3."
msgstr ""
"``array('u')`` agora usa :c:type:`wchar_t` como tipo C em vez do obsoleto "
"``Py_UNICODE``. Esta alteração não afeta o seu comportamento porque "
"``Py_UNICODE`` é um alias de :c:type:`wchar_t` desde o Python 3.3."

msgid "Please migrate to ``'w'`` typecode."
msgstr "Por favor, migre para o código de tipo ``'w'``."

msgid ""
"The actual representation of values is determined by the machine "
"architecture (strictly speaking, by the C implementation).  The actual size "
"can be accessed through the :attr:`array.itemsize` attribute."
msgstr ""
"A representação real dos valores é determinada pela arquitetura da máquina "
"(estritamente falando, pela implementação em C). O tamanho real pode ser "
"acedido através do atributo :attr:`array.itemsize`."

msgid "The module defines the following item:"
msgstr "O módulo define o seguinte item:"

msgid "A string with all available type codes."
msgstr "Uma string com todos os códigos de tipo disponíveis."

msgid "The module defines the following type:"
msgstr "O módulo define o seguinte tipo:"

msgid ""
"A new array whose items are restricted by *typecode*, and initialized from "
"the optional *initializer* value, which must be a :class:`bytes` or :class:"
"`bytearray` object, a Unicode string, or iterable over elements of the "
"appropriate type."
msgstr ""
"Um novo array cujos itens são restritos pelo *typecode*, e inicializado a "
"partir do valor opcional *initializer*, que deve ser um objeto :class:"
"`bytes` ou :class:`bytearray`, uma string Unicode ou um iterável sobre "
"elementos do tipo apropriado."

msgid ""
"If given a :class:`bytes` or :class:`bytearray` object, the initializer is "
"passed to the new array's :meth:`frombytes` method; if given a Unicode "
"string, the initializer is passed to the :meth:`fromunicode` method; "
"otherwise, the initializer's iterator is passed to the :meth:`extend` method "
"to add initial items to the array."
msgstr ""
"Se for fornecido um objeto :class:`bytes` ou :class:`bytearray`, o "
"inicializador é passado ao método :meth:`frombytes` do novo array; se for "
"fornecida uma string Unicode, o inicializador é passado ao método :meth:"
"`fromunicode`; caso contrário, o iterador do inicializador é passado ao "
"método :meth:`extend` para adicionar itens iniciais ao array."

msgid ""
"Array objects support the ordinary :ref:`mutable <typesseq-mutable>` :term:"
"`sequence` operations of indexing, slicing, concatenation, and "
"multiplication.  When using slice assignment, the assigned value must be an "
"array object with the same type code; in all other cases, :exc:`TypeError` "
"is raised. Array objects also implement the buffer interface, and may be "
"used wherever :term:`bytes-like objects <bytes-like object>` are supported."
msgstr ""
"Os objetos array suportam as operações comuns de :term:`sequência` :ref:"
"`mutável <typesseq-mutable>` como indexação, fatiamento (slicing), "
"concatenação e multiplicação. Ao usar atribuição de fatias, o valor "
"atribuído deve ser um objeto array com o mesmo código de tipo; em todos os "
"outros casos, é levantado :exc:`TypeError`. Os objetos array também "
"implementam a interface de buffer, e podem ser usados onde quer que :term:"
"`objetos do tipo bytes <bytes-like object>` sejam suportados."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``array.__new__`` with arguments "
"``typecode``, ``initializer``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``array.__new__`` com os "
"argumentos ``typecode``, ``initializer``."

msgid "The typecode character used to create the array."
msgstr "O carácter do código de tipo usado para criar o array."

msgid "The length in bytes of one array item in the internal representation."
msgstr "O comprimento em bytes de um item do array na representação interna."

msgid "Append a new item with value *x* to the end of the array."
msgstr "Anexa um novo item com o valor *x* ao final do array."

msgid ""
"Return a tuple ``(address, length)`` giving the current memory address and "
"the length in elements of the buffer used to hold array's contents.  The "
"size of the memory buffer in bytes can be computed as ``array.buffer_info()"
"[1] * array.itemsize``.  This is occasionally useful when working with low-"
"level (and inherently unsafe) I/O interfaces that require memory addresses, "
"such as certain :c:func:`!ioctl` operations.  The returned numbers are valid "
"as long as the array exists and no length-changing operations are applied to "
"it."
msgstr ""
"Devolve um tuplo ``(address, length)`` fornecendo o endereço de memória "
"atual e o comprimento em elementos do buffer usado para conter o conteúdo do "
"array. O tamanho do buffer de memória em bytes pode ser calculado como "
"``array.buffer_info()[1] * array.itemsize``. Isto é ocasionalmente útil ao "
"trabalhar com interfaces de E/S de baixo nível (e inerentemente inseguras) "
"que requerem endereços de memória, como certas operações :c:func:`!ioctl`. "
"Os números devolvidos são válidos enquanto o array existir e não lhe forem "
"aplicadas operações que alterem o seu comprimento."

msgid ""
"When using array objects from code written in C or C++ (the only way to "
"effectively make use of this information), it makes more sense to use the "
"buffer interface supported by array objects.  This method is maintained for "
"backward compatibility and should be avoided in new code.  The buffer "
"interface is documented in :ref:`bufferobjects`."
msgstr ""
"Ao utilizar objetos de array a partir de código escrito em C ou C++ (a única "
"maneira de utilizar efetivamente essas informações), faz mais sentido "
"utilizar a interface de buffer suportada por objetos de array. Este método é "
"mantido para compatibilidade com versões anteriores e deve ser evitado em "
"código novo. A interface de buffer está documentada em :ref:`bufferobjects`."

msgid ""
"\"Byteswap\" all items of the array.  This is only supported for values "
"which are 1, 2, 4, or 8 bytes in size; for other types of values, :exc:"
"`RuntimeError` is raised.  It is useful when reading data from a file "
"written on a machine with a different byte order."
msgstr ""
"Faz o \"Byteswap\" (inversão da ordem dos bytes) de todos os itens do array. "
"Isto é suportado apenas para valores com 1, 2, 4 ou 8 bytes de tamanho; para "
"outros tipos de valores, é levantado :exc:`RuntimeError`. É útil ao ler "
"dados de um ficheiro escrito numa máquina com uma ordem de bytes diferente."

msgid "Return the number of occurrences of *x* in the array."
msgstr "Retorna o número de ocorrências de *x* no array."

msgid ""
"Append items from *iterable* to the end of the array.  If *iterable* is "
"another array, it must have *exactly* the same type code; if not, :exc:"
"`TypeError` will be raised.  If *iterable* is not an array, it must be "
"iterable and its elements must be the right type to be appended to the array."
msgstr ""
"Anexa itens de *iterable* ao final do array. Se *iterable* for outro array, "
"deve ter *exatamente* o mesmo código de tipo; caso contrário, será "
"levantado :exc:`TypeError`. Se *iterable* não for um array, deve ser "
"iterável e os seus elementos devem ser do tipo correto para serem anexados "
"ao array."

msgid ""
"Appends items from the :term:`bytes-like object`, interpreting its content "
"as an array of machine values (as if it had been read from a file using the :"
"meth:`fromfile` method)."
msgstr ""
"Anexa itens do :term:`objeto do tipo bytes <bytes-like object>`, "
"interpretando o seu conteúdo como um array de valores de máquina (como se "
"tivessem sido lidos de um ficheiro usando o método :meth:`fromfile`)."

msgid ":meth:`!fromstring` is renamed to :meth:`frombytes` for clarity."
msgstr ":meth:`!fromstring` foi renomeado para :meth:`frombytes` por clareza."

msgid ""
"Read *n* items (as machine values) from the :term:`file object` *f* and "
"append them to the end of the array.  If less than *n* items are available, :"
"exc:`EOFError` is raised, but the items that were available are still "
"inserted into the array."
msgstr ""
"Lê *n* itens (como valores de máquina) do :term:`objeto ficheiro` *f* e "
"acrescenta-os ao final do array. Se houver menos de *n* itens disponíveis, é "
"gerado um :exc:`EOFError`, mas os itens que estavam disponíveis continuam a "
"ser inseridos no array."

msgid ""
"Append items from the list.  This is equivalent to ``for x in list: a."
"append(x)`` except that if there is a type error, the array is unchanged."
msgstr ""
"Anexa itens da lista. Isto é equivalente a ``for x in list: a.append(x)`` "
"exceto que, se houver um erro de tipo, o array permanece inalterado."

msgid ""
"Extends this array with data from the given Unicode string. The array must "
"have type code ``'u'`` or ``'w'``; otherwise a :exc:`ValueError` is raised. "
"Use ``array.frombytes(unicodestring.encode(enc))`` to append Unicode data to "
"an array of some other type."
msgstr ""
"Estende este array com dados da string Unicode fornecida. O array deve ter o "
"tipo de código ``'u'`` ou ``'w'``; caso contrário, é gerado um :exc:"
"`ValueError`. Use ``array.frombytes(unicodestring.encode(enc))`` para anexar "
"dados Unicode a um array de outro tipo."

msgid ""
"Return the smallest *i* such that *i* is the index of the first occurrence "
"of *x* in the array.  The optional arguments *start* and *stop* can be "
"specified to search for *x* within a subsection of the array.  Raise :exc:"
"`ValueError` if *x* is not found."
msgstr ""
"Devolve o menor *i* tal que *i* é o índice da primeira ocorrência de *x* no "
"array. Os argumentos opcionais *start* e *stop* podem ser especificados para "
"procurar *x* dentro de uma subsecção do array. Levanta :exc:`ValueError` se "
"*x* não for encontrado."

msgid "Added optional *start* and *stop* parameters."
msgstr "Adicionados os parâmetros opcionais *start* e *stop*."

msgid ""
"Insert a new item with value *x* in the array before position *i*. Negative "
"values are treated as being relative to the end of the array."
msgstr ""
"Insira um novo item com valor *x* no array antes da posição *i*. Os valores "
"negativos são tratados como relativos ao final do array."

msgid ""
"Removes the item with the index *i* from the array and returns it. The "
"optional argument defaults to ``-1``, so that by default the last item is "
"removed and returned."
msgstr ""
"Remove o item com o índice *i* do array e devolve-o. O argumento opcional "
"tem como padrão ``-1``, para que, por defeito, o último item seja removido e "
"devolvido."

msgid "Remove the first occurrence of *x* from the array."
msgstr "Remove a primeira ocorrência de *x* do array."

msgid "Remove all elements from the array."
msgstr "Remove todos os elementos do array."

msgid "Reverse the order of the items in the array."
msgstr "Inverte a ordem dos itens no array."

msgid ""
"Convert the array to an array of machine values and return the bytes "
"representation (the same sequence of bytes that would be written to a file "
"by the :meth:`tofile` method.)"
msgstr ""
"Converte o array num array de valores de máquina e devolve a representação "
"em bytes (a mesma sequência de bytes que seria escrita num ficheiro pelo "
"método :meth:`tofile`)."

msgid ":meth:`!tostring` is renamed to :meth:`tobytes` for clarity."
msgstr ":meth:`!tostring` foi renomeado para :meth:`tobytes` por clareza."

msgid "Write all items (as machine values) to the :term:`file object` *f*."
msgstr ""
"Escreve todos os itens (como valores de máquina) no :term:`objeto de "
"ficheiro <file object>` *f*."

msgid "Convert the array to an ordinary list with the same items."
msgstr "Converte o array numa lista comum com os mesmos itens."

msgid ""
"Convert the array to a Unicode string.  The array must have a type ``'u'`` "
"or ``'w'``; otherwise a :exc:`ValueError` is raised. Use ``array.tobytes()."
"decode(enc)`` to obtain a Unicode string from an array of some other type."
msgstr ""
"Converta o array para uma string Unicode. O array deve ter um tipo ``'u'`` "
"ou ``'w'``; caso contrário, será gerado um :exc:`ValueError`. Use ``array."
"tobytes().decode(enc)`` para obter uma string Unicode a partir de um array "
"de outro tipo."

msgid ""
"The string representation of array objects has the form ``array(typecode, "
"initializer)``. The *initializer* is omitted if the array is empty, "
"otherwise it is a Unicode string if the *typecode* is ``'u'`` or ``'w'``, "
"otherwise it is a list of numbers. The string representation is guaranteed "
"to be able to be converted back to an array with the same type and value "
"using :func:`eval`, so long as the :class:`~array.array` class has been "
"imported using ``from array import array``. Variables ``inf`` and ``nan`` "
"must also be defined if it contains corresponding floating-point values. "
"Examples::"
msgstr ""
"A representação em string dos objetos array tem a forma ``array(typecode, "
"initializer)``. O *initializer* é omitido se o array estiver vazio, caso "
"contrário, é uma string Unicode se o *typecode* for ``'u'`` ou ``'w'``, ou "
"uma lista de números nos outros casos. A representação em string garante a "
"possibilidade de ser convertida de volta para um array com o mesmo tipo e "
"valor usando :func:`eval`, desde que a classe :class:`~array.array` tenha "
"sido importada usando ``from array import array``. As variáveis ``inf`` e "
"``nan`` também devem estar definidas se o array contiver valores de vírgula "
"flutuante correspondentes. Exemplos::"

msgid ""
"array('l')\n"
"array('w', 'hello \\u2641')\n"
"array('l', [1, 2, 3, 4, 5])\n"
"array('d', [1.0, 2.0, 3.14, -inf, nan])"
msgstr ""
"array('l')\n"
"array('w', 'hello \\u2641')\n"
"array('l', [1, 2, 3, 4, 5])\n"
"array('d', [1.0, 2.0, 3.14, -inf, nan])"

msgid "Module :mod:`struct`"
msgstr "Módulo :mod:`struct`"

msgid "Packing and unpacking of heterogeneous binary data."
msgstr "Empacotamento e desempacotamento de dados binários heterogéneos."

msgid "`NumPy <https://numpy.org/>`_"
msgstr "`NumPy <https://numpy.org/>`_"

msgid "The NumPy package defines another array type."
msgstr "O pacote NumPy define outro tipo de array."

msgid "arrays"
msgstr "arrays"
