# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-07 14:20+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid "Developing with asyncio"
msgstr "Desenvolver com asyncio"

msgid ""
"Asynchronous programming is different from classic \"sequential\" "
"programming."
msgstr ""
"A programação assíncrona é diferente da programação \"sequencial\" clássica."

msgid ""
"This page lists common mistakes and traps and explains how to avoid them."
msgstr "Esta página lista erros e armadilhas comuns e explica como evitá-los."

msgid "Debug Mode"
msgstr "Modo de Depuração"

msgid ""
"By default asyncio runs in production mode.  In order to ease the "
"development asyncio has a *debug mode*."
msgstr ""
"Por predefinição, o asyncio corre em modo de produção. Para facilitar o "
"desenvolvimento, o asyncio possui um *modo de depuração* (debug mode)."

msgid "There are several ways to enable asyncio debug mode:"
msgstr "Existem várias formas de ativar o modo de depuração do asyncio:"

msgid "Setting the :envvar:`PYTHONASYNCIODEBUG` environment variable to ``1``."
msgstr ""
"Definir a variável de ambiente :envvar:`PYTHONASYNCIODEBUG` para ``1``."

msgid "Using the :ref:`Python Development Mode <devmode>`."
msgstr "Usar o :ref:`Modo de Desenvolvimento do Python <devmode>`."

msgid "Passing ``debug=True`` to :func:`asyncio.run`."
msgstr "Passar ``debug=True`` para :func:`asyncio.run`."

msgid "Calling :meth:`loop.set_debug`."
msgstr "Chamar :meth:`loop.set_debug`."

msgid "In addition to enabling the debug mode, consider also:"
msgstr "Além de ativar o modo de depuração, considere também:"

msgid ""
"setting the log level of the :ref:`asyncio logger <asyncio-logger>` to :py:"
"const:`logging.DEBUG`, for example the following snippet of code can be run "
"at startup of the application::"
msgstr ""
"definir o nível de log do :ref:`asyncio logger <asyncio-logger>` para :py:"
"const:`logging.DEBUG`; por exemplo, o seguinte snippet de código pode ser "
"executado no arranque da aplicação::"

msgid "logging.basicConfig(level=logging.DEBUG)"
msgstr "logging.basicConfig(level=logging.DEBUG)"

msgid ""
"configuring the :mod:`warnings` module to display :exc:`ResourceWarning` "
"warnings.  One way of doing that is by using the :option:`-W` ``default`` "
"command line option."
msgstr ""
"configurar o módulo :mod:`warnings` para exibir avisos :exc:"
"`ResourceWarning`. Uma forma de o fazer é utilizando a opção de linha de "
"comandos :option:`-W` ``default``."

msgid "When the debug mode is enabled:"
msgstr "Quando o modo de depuração está ativado:"

msgid ""
"Many non-threadsafe asyncio APIs (such as :meth:`loop.call_soon` and :meth:"
"`loop.call_at` methods) raise an exception if they are called from a wrong "
"thread."
msgstr ""
"Muitas APIs do asyncio que não são seguras para threads (como os métodos :"
"meth:`loop.call_soon` e :meth:`loop.call_at`) lançam uma exceção se forem "
"chamadas a partir da thread errada."

msgid ""
"The execution time of the I/O selector is logged if it takes too long to "
"perform an I/O operation."
msgstr ""
"O tempo de execução do seletor de I/O é registado se demorar demasiado tempo "
"a realizar uma operação de I/O."

msgid ""
"Callbacks taking longer than 100 milliseconds are logged.  The :attr:`loop."
"slow_callback_duration` attribute can be used to set the minimum execution "
"duration in seconds that is considered \"slow\"."
msgstr ""
"Callbacks que demorem mais de 100 milissegundos são registados. O atributo :"
"attr:`loop.slow_callback_duration` pode ser usado para definir a duração "
"mínima de execução em segundos que é considerada \"lenta\"."

msgid "Concurrency and Multithreading"
msgstr "Concorrência e Multithreading"

msgid ""
"An event loop runs in a thread (typically the main thread) and executes all "
"callbacks and Tasks in its thread.  While a Task is running in the event "
"loop, no other Tasks can run in the same thread.  When a Task executes an "
"``await`` expression, the running Task gets suspended, and the event loop "
"executes the next Task."
msgstr ""
"Um loop de eventos (event loop) corre numa thread (tipicamente a thread "
"principal) e executa todos os callbacks e Tarefas (Tasks) na sua thread. "
"Enquanto uma Task está a correr no event loop, nenhuma outra Task pode "
"correr na mesma thread. Quando uma Task executa uma expressão ``await``, a "
"Task em execução é suspensa e o event loop executa a próxima Task."

msgid ""
"To schedule a :term:`callback` from another OS thread, the :meth:`loop."
"call_soon_threadsafe` method should be used. Example::"
msgstr ""
"Para agendar um :term:`callback` a partir de outra thread do SO, deve ser "
"usado o método :meth:`loop.call_soon_threadsafe`. Exemplo::"

msgid "loop.call_soon_threadsafe(callback, *args)"
msgstr "loop.call_soon_threadsafe(callback, *args)"

msgid ""
"Almost all asyncio objects are not thread safe, which is typically not a "
"problem unless there is code that works with them from outside of a Task or "
"a callback.  If there's a need for such code to call a low-level asyncio "
"API, the :meth:`loop.call_soon_threadsafe` method should be used, e.g.::"
msgstr ""
"Quase todos os objetos asyncio não são seguros para threads, o que "
"normalmente não é um problema, a menos que haja código que trabalhe com eles "
"fora de uma Task ou de um callback. Se houver necessidade de tal código "
"chamar uma API de baixo nível do asyncio, deve ser usado o método :meth:"
"`loop.call_soon_threadsafe`, por ex.::"

msgid "loop.call_soon_threadsafe(fut.cancel)"
msgstr "loop.call_soon_threadsafe(fut.cancel)"

msgid ""
"To schedule a coroutine object from a different OS thread, the :func:"
"`run_coroutine_threadsafe` function should be used. It returns a :class:"
"`concurrent.futures.Future` to access the result::"
msgstr ""
"Para agendar um objeto corrotina a partir de uma thread do SO diferente, "
"deve ser usada a função :func:`run_coroutine_threadsafe`. Esta retorna um :"
"class:`concurrent.futures.Future` para aceder ao resultado::"

msgid ""
"async def coro_func():\n"
"     return await asyncio.sleep(1, 42)\n"
"\n"
"# Later in another OS thread:\n"
"\n"
"future = asyncio.run_coroutine_threadsafe(coro_func(), loop)\n"
"# Wait for the result:\n"
"result = future.result()"
msgstr ""
"async def coro_func():\n"
"     return await asyncio.sleep(1, 42)\n"
"\n"
"# Mais tarde, noutro tópico do SO:\n"
"\n"
"future = asyncio.run_coroutine_threadsafe(coro_func(), loop)\n"
"# Aguarde o resultado:\n"
"result = future.result()"

msgid "To handle signals the event loop must be run in the main thread."
msgstr ""
"Para lidar com sinais, o event loop deve ser executado na thread principal."

msgid ""
"The :meth:`loop.run_in_executor` method can be used with a :class:"
"`concurrent.futures.ThreadPoolExecutor` or :class:`~concurrent.futures."
"InterpreterPoolExecutor` to execute blocking code in a different OS thread "
"without blocking the OS thread that the event loop runs in."
msgstr ""
"O método :meth:`loop.run_in_executor` pode ser usado com um :class:"
"`concurrent.futures.ThreadPoolExecutor` ou :class:`~concurrent.futures."
"InterpreterPoolExecutor` para executar código bloqueante numa thread do SO "
"diferente sem bloquear a thread onde o event loop corre."

msgid ""
"There is currently no way to schedule coroutines or callbacks directly from "
"a different process (such as one started with :mod:`multiprocessing`). The :"
"ref:`asyncio-event-loop-methods` section lists APIs that can read from pipes "
"and watch file descriptors without blocking the event loop. In addition, "
"asyncio's :ref:`Subprocess <asyncio-subprocess>` APIs provide a way to start "
"a process and communicate with it from the event loop. Lastly, the "
"aforementioned :meth:`loop.run_in_executor` method can also be used with a :"
"class:`concurrent.futures.ProcessPoolExecutor` to execute code in a "
"different process."
msgstr ""
"Atualmente não existe forma de agendar corrotinas ou callbacks diretamente "
"de um processo diferente (como um iniciado com :mod:`multiprocessing`). A "
"secção :ref:`asyncio-event-loop-methods` lista APIs que podem ler de pipes e "
"monitorizar descritores de ficheiros sem bloquear o event loop. Além disso, "
"as APIs de :ref:`Subprocess <asyncio-subprocess>` do asyncio fornecem uma "
"forma de iniciar um processo e comunicar com ele a partir do event loop. "
"Finalmente, o já mencionado método :meth:`loop.run_in_executor` também pode "
"ser usado com um :class:`concurrent.futures.ProcessPoolExecutor` para "
"executar código num processo diferente."

msgid "Running Blocking Code"
msgstr "Executar Código Bloqueante"

msgid ""
"Blocking (CPU-bound) code should not be called directly.  For example, if a "
"function performs a CPU-intensive calculation for 1 second, all concurrent "
"asyncio Tasks and IO operations would be delayed by 1 second."
msgstr ""
"Código bloqueante (CPU-bound) não deve ser chamado diretamente. Por exemplo, "
"se uma função realizar um cálculo intensivo de CPU durante 1 segundo, todas "
"as Tasks e operações de IO assíncronas concorrentes seriam atrasadas em 1 "
"segundo."

msgid ""
"An executor can be used to run a task in a different thread, including in a "
"different interpreter, or even in a different process to avoid blocking the "
"OS thread with the event loop.  See the :meth:`loop.run_in_executor` method "
"for more details."
msgstr ""
"Um executor pode ser usado para correr uma tarefa numa thread diferente, "
"incluindo num intérprete diferente, ou até num processo diferente para "
"evitar bloquear a thread do SO com o event loop. Consulte o método :meth:"
"`loop.run_in_executor` para mais detalhes."

msgid "Logging"
msgstr "Registo (Logging)"

msgid ""
"asyncio uses the :mod:`logging` module and all logging is performed via the "
"``\"asyncio\"`` logger."
msgstr ""
"O asyncio utiliza o módulo :mod:`logging` e todo o registo é efetuado "
"através do logger ``\"asyncio\"``."

msgid ""
"The default log level is :py:const:`logging.INFO`, which can be easily "
"adjusted::"
msgstr ""
"O nível de log predefinido é :py:const:`logging.INFO`, que pode ser "
"facilmente ajustado::"

msgid "logging.getLogger(\"asyncio\").setLevel(logging.WARNING)"
msgstr "logging.getLogger(\"asyncio\").setLevel(logging.WARNING)"

msgid ""
"Network logging can block the event loop. It is recommended to use a "
"separate thread for handling logs or use non-blocking IO. For example, see :"
"ref:`blocking-handlers`."
msgstr ""
"O registo de logs via rede pode bloquear o event loop. Recomenda-se o uso de "
"uma thread separada para lidar com logs ou o uso de IO não bloqueante. Por "
"exemplo, veja :ref:`blocking-handlers`."

msgid "Detect never-awaited coroutines"
msgstr "Detetar corrotinas nunca aguardadas (never-awaited)"

msgid ""
"When a coroutine function is called, but not awaited (e.g. ``coro()`` "
"instead of ``await coro()``) or the coroutine is not scheduled with :meth:"
"`asyncio.create_task`, asyncio will emit a :exc:`RuntimeWarning`::"
msgstr ""
"Quando uma função corrotina é chamada, mas não aguardada (ex: ``coro()`` em "
"vez de ``await coro()``) ou a corrotina não é agendada com :meth:`asyncio."
"create_task`, o asyncio emitirá um :exc:`RuntimeWarning`::"

msgid ""
"import asyncio\n"
"\n"
"async def test():\n"
"    print(\"never scheduled\")\n"
"\n"
"async def main():\n"
"    test()\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def test():\n"
"    print(\"nunca agendada\")\n"
"\n"
"async def main():\n"
"    test()\n"
"\n"
"asyncio.run(main())"

msgid "Output::"
msgstr "Saída::"

msgid ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"  test()"
msgstr ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"  test()"

msgid "Output in debug mode::"
msgstr "Saída em modo de depuração::"

msgid ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"Coroutine created at (most recent call last)\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"  < .. >\n"
"\n"
"  File \"../t.py\", line 7, in main\n"
"    test()\n"
"  test()"
msgstr ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"Coroutine created at (most recent call last)\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"  < .. >\n"
"\n"
"  File \"../t.py\", line 7, in main\n"
"    test()\n"
"  test()"

msgid ""
"The usual fix is to either await the coroutine or call the :meth:`asyncio."
"create_task` function::"
msgstr ""
"A correção habitual é aguardar pela corrotina ou chamar a função :meth:"
"`asyncio.create_task`::"

msgid ""
"async def main():\n"
"    await test()"
msgstr ""
"async def main():\n"
"    await test()"

msgid "Detect never-retrieved exceptions"
msgstr "Detetar exceções nunca recuperadas"

msgid ""
"If a :meth:`Future.set_exception` is called but the Future object is never "
"awaited on, the exception would never be propagated to the user code.  In "
"this case, asyncio would emit a log message when the Future object is "
"garbage collected."
msgstr ""
"Se um :meth:`Future.set_exception` for chamado mas o objeto Future nunca for "
"aguardado, a exceção nunca seria propagada para o código do utilizador. "
"Neste caso, o asyncio emitiria uma mensagem de log quando o objeto Future "
"fosse recolhido pelo garbage collector."

msgid "Example of an unhandled exception::"
msgstr "Exemplo de uma exceção não tratada::"

msgid ""
"import asyncio\n"
"\n"
"async def bug():\n"
"    raise Exception(\"not consumed\")\n"
"\n"
"async def main():\n"
"    asyncio.create_task(bug())\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def bug():\n"
"    raise Exception(\"não consumida\")\n"
"\n"
"async def main():\n"
"    asyncio.create_task(bug())\n"
"\n"
"asyncio.run(main())"

msgid ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"  exception=Exception('not consumed')>\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"test.py\", line 4, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"
msgstr ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"  exception=Exception('não consumida')>\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"test.py\", line 4, in bug\n"
"    raise Exception(\"não consumida\")\n"
"Exception: não consumida"

msgid ""
":ref:`Enable the debug mode <asyncio-debug-mode>` to get the traceback where "
"the task was created::"
msgstr ""
":ref:`Ative o modo de depuração <asyncio-debug-mode>` para obter o traceback "
"de onde a tarefa foi criada::"

msgid "asyncio.run(main(), debug=True)"
msgstr "asyncio.run(main(), debug=True)"

msgid ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"    exception=Exception('not consumed') created at asyncio/tasks.py:321>\n"
"\n"
"source_traceback: Object created at (most recent call last):\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"< .. >\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"../t.py\", line 4, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"
msgstr ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"    exception=Exception('não consumida') created at asyncio/tasks.py:321>\n"
"\n"
"source_traceback: Object created at (most recent call last):\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"< .. >\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"../t.py\", line 4, in bug\n"
"    raise Exception(\"não consumida\")\n"
"Exception: não consumida"
