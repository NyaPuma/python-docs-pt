# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-05 14:39+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid "Futures"
msgstr "Futures"

msgid ""
"**Source code:** :source:`Lib/asyncio/futures.py`, :source:`Lib/asyncio/"
"base_futures.py`"
msgstr ""
"**Código-fonte:** :source:`Lib/asyncio/futures.py`, :source:`Lib/asyncio/"
"base_futures.py`"

msgid ""
"*Future* objects are used to bridge **low-level callback-based code** with "
"high-level async/await code."
msgstr ""
"Os objetos *Future* são utilizados para ligar **código de baixo nível "
"baseado em callbacks** com código de alto nível async/await."

msgid "Future Functions"
msgstr "Funções de Future"

msgid "Return ``True`` if *obj* is either of:"
msgstr "Devolve ``True`` se *obj* for um dos seguintes:"

msgid "an instance of :class:`asyncio.Future`,"
msgstr "uma instância de :class:`asyncio.Future`,"

msgid "an instance of :class:`asyncio.Task`,"
msgstr "uma instância de :class:`asyncio.Task`,"

msgid "a Future-like object with a ``_asyncio_future_blocking`` attribute."
msgstr "um objeto tipo Future com um atributo ``_asyncio_future_blocking``."

msgid "Return:"
msgstr "Devolve:"

msgid ""
"*obj* argument as is, if *obj* is a :class:`Future`, a :class:`Task`, or a "
"Future-like object (:func:`isfuture` is used for the test.)"
msgstr ""
"o argumento *obj* tal como está, se *obj* for um :class:`Future`, uma :class:"
"`Task`, ou um objeto tipo Future (é utilizada a função :func:`isfuture` para "
"o teste.)"

msgid ""
"a :class:`Task` object wrapping *obj*, if *obj* is a coroutine (:func:"
"`iscoroutine` is used for the test); in this case the coroutine will be "
"scheduled by ``ensure_future()``."
msgstr ""
"um objeto :class:`Task` que envolve *obj*, se *obj* for uma corrotina (:func:"
"`iscoroutine` é utilizada para o teste); neste caso, a corrotina será "
"agendada por ``ensure_future()``."

msgid ""
"a :class:`Task` object that would await on *obj*, if *obj* is an awaitable (:"
"func:`inspect.isawaitable` is used for the test.)"
msgstr ""
"um objeto :class:`Task` que aguardaria por *obj*, se *obj* for um awaitable "
"(:func:`inspect.isawaitable` é utilizada para o teste.)"

msgid "If *obj* is neither of the above a :exc:`TypeError` is raised."
msgstr ""
"Se *obj* não for nenhum dos anteriores, é lançada uma :exc:`TypeError`."

msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid-execution."
msgstr ""
"Guarde uma referência ao resultado desta função, para evitar que uma tarefa "
"desapareça a meio da execução."

msgid ""
"See also the :func:`create_task` function which is the preferred way for "
"creating new tasks or use :class:`asyncio.TaskGroup` which keeps reference "
"to the task internally."
msgstr ""
"Consulte também a função :func:`create_task`, que é a forma preferencial "
"para criar novas tarefas, ou utilize :class:`asyncio.TaskGroup`, que mantém "
"a referência à tarefa internamente."

msgid "The function accepts any :term:`awaitable` object."
msgstr "A função aceita qualquer objeto :term:`awaitable`."

msgid ""
"Deprecation warning is emitted if *obj* is not a Future-like object and "
"*loop* is not specified and there is no running event loop."
msgstr ""
"Um aviso de descontinuação é emitido se *obj* não for um objeto tipo Future "
"e *loop* não for especificado e não houver um loop de eventos em execução."

msgid ""
"Wrap a :class:`concurrent.futures.Future` object in a :class:`asyncio."
"Future` object."
msgstr ""
"Envolve um objeto :class:`concurrent.futures.Future` num objeto :class:"
"`asyncio.Future`."

msgid ""
"Deprecation warning is emitted if *future* is not a Future-like object and "
"*loop* is not specified and there is no running event loop."
msgstr ""
"Um aviso de descontinuação é emitido se *future* não for um objeto tipo "
"Future e *loop* não for especificado e não houver um loop de eventos em "
"execução."

msgid "Future Object"
msgstr "Objeto Future"

msgid ""
"A Future represents an eventual result of an asynchronous operation.  Not "
"thread-safe."
msgstr ""
"Um Future representa um resultado eventual de uma operação assíncrona. Não é "
"seguro para threads (*thread-safe*)."

msgid ""
"Future is an :term:`awaitable` object.  Coroutines can await on Future "
"objects until they either have a result or an exception set, or until they "
"are cancelled. A Future can be awaited multiple times and the result is same."
msgstr ""
"Um Future é um objeto :term:`awaitable`. As corrotinas podem aguardar "
"(*await*) por objetos Future até que estes tenham um resultado ou uma "
"exceção definida, ou até que sejam cancelados. Um Future pode ser aguardado "
"várias vezes e o resultado é o mesmo."

msgid ""
"Typically Futures are used to enable low-level callback-based code (e.g. in "
"protocols implemented using asyncio :ref:`transports <asyncio-transports-"
"protocols>`) to interoperate with high-level async/await code."
msgstr ""
"Tipicamente, os Futures são utilizados para permitir que código de baixo "
"nível baseado em callbacks (por exemplo, em protocolos implementados usando :"
"ref:`transportes asyncio <asyncio-transports-protocols>`) interopere com "
"código de alto nível async/await."

msgid ""
"The rule of thumb is to never expose Future objects in user-facing APIs, and "
"the recommended way to create a Future object is to call :meth:`loop."
"create_future`.  This way alternative event loop implementations can inject "
"their own optimized implementations of a Future object."
msgstr ""
"A regra de ouro é nunca expor objetos Future em APIs voltadas para o "
"utilizador, e a forma recomendada de criar um objeto Future é chamar :meth:"
"`loop.create_future`. Desta forma, implementações alternativas de loops de "
"eventos podem injetar as suas próprias implementações otimizadas de um "
"objeto Future."

msgid "Added support for the :mod:`contextvars` module."
msgstr "Adicionado suporte para o módulo :mod:`contextvars`."

msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no "
"running event loop."
msgstr ""
"É emitido um aviso de descontinuação se *loop* não for especificado e não "
"houver um loop de eventos em execução."

msgid "Return the result of the Future."
msgstr "Devolve o resultado do Future."

msgid ""
"If the Future is *done* and has a result set by the :meth:`set_result` "
"method, the result value is returned."
msgstr ""
"Se o Future estiver concluído (*done*) e tiver um resultado definido pelo "
"método :meth:`set_result`, o valor do resultado é devolvido."

msgid ""
"If the Future is *done* and has an exception set by the :meth:"
"`set_exception` method, this method raises the exception."
msgstr ""
"Se o Future estiver concluído (*done*) e tiver uma exceção definida pelo "
"método :meth:`set_exception`, este método lança a exceção."

msgid ""
"If the Future has been *cancelled*, this method raises a :exc:"
"`CancelledError` exception."
msgstr ""
"Se o Future tiver sido cancelado (*cancelled*), este método lança uma "
"exceção :exc:`CancelledError`."

msgid ""
"If the Future's result isn't yet available, this method raises an :exc:"
"`InvalidStateError` exception."
msgstr ""
"Se o resultado do Future ainda não estiver disponível, este método lança uma "
"exceção :exc:`InvalidStateError`."

msgid "Mark the Future as *done* and set its result."
msgstr "Marca o Future como concluído (*done*) e define o seu resultado."

msgid ""
"Raises an :exc:`InvalidStateError` error if the Future is already *done*."
msgstr ""
"Lança um erro :exc:`InvalidStateError` se o Future já estiver concluído "
"(*done*)."

msgid "Mark the Future as *done* and set an exception."
msgstr "Marca o Future como concluído (*done*) e define uma exceção."

msgid "Return ``True`` if the Future is *done*."
msgstr "Devolve ``True`` se o Future estiver concluído (*done*)."

msgid ""
"A Future is *done* if it was *cancelled* or if it has a result or an "
"exception set with :meth:`set_result` or :meth:`set_exception` calls."
msgstr ""
"Um Future está concluído (*done*) se tiver sido cancelado ou se tiver um "
"resultado ou uma exceção definida com chamadas a :meth:`set_result` ou :meth:"
"`set_exception`."

msgid "Return ``True`` if the Future was *cancelled*."
msgstr "Devolve ``True`` se o Future tiver sido cancelado (*cancelled*)."

msgid ""
"The method is usually used to check if a Future is not *cancelled* before "
"setting a result or an exception for it::"
msgstr ""
"O método é geralmente utilizado para verificar se um Future não está "
"cancelado antes de definir um resultado ou uma exceção para o mesmo::"

msgid ""
"if not fut.cancelled():\n"
"    fut.set_result(42)"
msgstr ""
"if not fut.cancelled():\n"
"    fut.set_result(42)"

msgid "Add a callback to be run when the Future is *done*."
msgstr ""
"Adiciona uma callback para ser executada quando o Future estiver concluído "
"(*done*)."

msgid "The *callback* is called with the Future object as its only argument."
msgstr "A *callback* é chamada com o objeto Future como o seu único argumento."

msgid ""
"If the Future is already *done* when this method is called, the callback is "
"scheduled with :meth:`loop.call_soon`."
msgstr ""
"Se o Future já estiver concluído (*done*) quando este método é chamado, a "
"callback é agendada com :meth:`loop.call_soon`."

msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"Um argumento opcional apenas por palavra-chave *context* permite especificar "
"um :class:`contextvars.Context` personalizado para a *callback* ser "
"executada. O contexto atual é utilizado quando nenhum *context* é fornecido."

msgid ""
":func:`functools.partial` can be used to pass parameters to the callback, e."
"g.::"
msgstr ""
":func:`functools.partial` pode ser utilizada para passar parâmetros à "
"callback, por exemplo::"

msgid ""
"# Call 'print(\"Future:\", fut)' when \"fut\" is done.\n"
"fut.add_done_callback(\n"
"    functools.partial(print, \"Future:\"))"
msgstr ""
"# Chamar 'print(\"Future:\", fut)' quando \"fut\" estiver concluído.\n"
"fut.add_done_callback(\n"
"    functools.partial(print, \"Future:\"))"

msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr ""
"O parâmetro apenas por palavra-chave *context* foi adicionado. Consulte a :"
"pep:`567` para mais detalhes."

msgid "Remove *callback* from the callbacks list."
msgstr "Remove *callback* da lista de callbacks."

msgid ""
"Returns the number of callbacks removed, which is typically 1, unless a "
"callback was added more than once."
msgstr ""
"Devolve o número de callbacks removidas, que é tipicamente 1, a menos que "
"uma callback tenha sido adicionada mais do que uma vez."

msgid "Cancel the Future and schedule callbacks."
msgstr "Cancela o Future e agenda as callbacks."

msgid ""
"If the Future is already *done* or *cancelled*, return ``False``. Otherwise, "
"change the Future's state to *cancelled*, schedule the callbacks, and return "
"``True``."
msgstr ""
"Se o Future já estiver concluído (*done*) ou cancelado (*cancelled*), "
"devolve ``False``. Caso contrário, altera o estado do Future para cancelado, "
"agenda as callbacks e devolve ``True``."

msgid "Added the *msg* parameter."
msgstr "Adicionado o parâmetro *msg*."

msgid "Return the exception that was set on this Future."
msgstr "Devolve a exceção que foi definida neste Future."

msgid ""
"The exception (or ``None`` if no exception was set) is returned only if the "
"Future is *done*."
msgstr ""
"A exceção (ou ``None`` se nenhuma exceção tiver sido definida) é devolvida "
"apenas se o Future estiver concluído (*done*)."

msgid ""
"If the Future isn't *done* yet, this method raises an :exc:"
"`InvalidStateError` exception."
msgstr ""
"Se o Future ainda não estiver concluído (*done*), este método lança uma "
"exceção :exc:`InvalidStateError`."

msgid "Return the event loop the Future object is bound to."
msgstr "Devolve o loop de eventos ao qual o objeto Future está vinculado."

msgid ""
"This example creates a Future object, creates and schedules an asynchronous "
"Task to set result for the Future, and waits until the Future has a result::"
msgstr ""
"Este exemplo cria um objeto Future, cria e agenda uma Tarefa (Task) "
"assíncrona para definir o resultado do Future, e aguarda até que o Future "
"tenha um resultado::"

msgid ""
"async def set_after(fut, delay, value):\n"
"    # Sleep for *delay* seconds.\n"
"    await asyncio.sleep(delay)\n"
"\n"
"    # Set *value* as a result of *fut* Future.\n"
"    fut.set_result(value)\n"
"\n"
"async def main():\n"
"    # Get the current event loop.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # Create a new Future object.\n"
"    fut = loop.create_future()\n"
"\n"
"    # Run \"set_after()\" coroutine in a parallel Task.\n"
"    # We are using the low-level \"loop.create_task()\" API here because\n"
"    # we already have a reference to the event loop at hand.\n"
"    # Otherwise we could have just used \"asyncio.create_task()\".\n"
"    loop.create_task(\n"
"        set_after(fut, 1, '... world'))\n"
"\n"
"    print('hello ...')\n"
"\n"
"    # Wait until *fut* has a result (1 second) and print it.\n"
"    print(await fut)\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def set_after(fut, delay, value):\n"
"    # Dormir durante *delay* segundos.\n"
"    await asyncio.sleep(delay)\n"
"\n"
"    # Definir *value* como resultado do Future *fut*.\n"
"    fut.set_result(value)\n"
"\n"
"async def main():\n"
"    # Obter o loop de eventos atual.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # Criar um novo objeto Future.\n"
"    fut = loop.create_future()\n"
"\n"
"    # Executar a corrotina \"set_after()\" numa Tarefa paralela.\n"
"    # Estamos a utilizar a API de baixo nível \"loop.create_task()\" aqui "
"porque\n"
"    # já temos uma referência ao loop de eventos à mão.\n"
"    # Caso contrário, poderíamos simplesmente ter utilizado \"asyncio."
"create_task()\".\n"
"    loop.create_task(\n"
"        set_after(fut, 1, '... world'))\n"
"\n"
"    print('hello ...')\n"
"\n"
"    # Aguardar até que *fut* tenha um resultado (1 segundo) e imprimi-lo.\n"
"    print(await fut)\n"
"\n"
"asyncio.run(main())"

msgid ""
"The Future object was designed to mimic :class:`concurrent.futures.Future`.  "
"Key differences include:"
msgstr ""
"O objeto Future foi desenhado para imitar :class:`concurrent.futures."
"Future`. As principais diferenças incluem:"

msgid ""
"unlike asyncio Futures, :class:`concurrent.futures.Future` instances cannot "
"be awaited."
msgstr ""
"ao contrário dos Futures de asyncio, as instâncias de :class:`concurrent."
"futures.Future` não podem ser aguardadas (*awaited*)."

msgid ""
":meth:`asyncio.Future.result` and :meth:`asyncio.Future.exception` do not "
"accept the *timeout* argument."
msgstr ""
":meth:`asyncio.Future.result` e :meth:`asyncio.Future.exception` não aceitam "
"o argumento *timeout*."

msgid ""
":meth:`asyncio.Future.result` and :meth:`asyncio.Future.exception` raise an :"
"exc:`InvalidStateError` exception when the Future is not *done*."
msgstr ""
":meth:`asyncio.Future.result` e :meth:`asyncio.Future.exception` lançam uma "
"exceção :exc:`InvalidStateError` quando o Future não está concluído (*done*)."

msgid ""
"Callbacks registered with :meth:`asyncio.Future.add_done_callback` are not "
"called immediately.  They are scheduled with :meth:`loop.call_soon` instead."
msgstr ""
"As callbacks registadas com :meth:`asyncio.Future.add_done_callback` não são "
"chamadas imediatamente. Em vez disso, são agendadas com :meth:`loop."
"call_soon`."

msgid ""
"asyncio Future is not compatible with the :func:`concurrent.futures.wait` "
"and :func:`concurrent.futures.as_completed` functions."
msgstr ""
"O Future de asyncio não é compatível com as funções :func:`concurrent."
"futures.wait` e :func:`concurrent.futures.as_completed`."

msgid ""
":meth:`asyncio.Future.cancel` accepts an optional ``msg`` argument, but :"
"meth:`concurrent.futures.Future.cancel` does not."
msgstr ""
":meth:`asyncio.Future.cancel` aceita um argumento opcional ``msg``, mas :"
"meth:`concurrent.futures.Future.cancel` não."
