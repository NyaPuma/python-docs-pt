# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-05 14:39+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid "Runners"
msgstr "Runners"

msgid "**Source code:** :source:`Lib/asyncio/runners.py`"
msgstr "**Código-fonte:** :source:`Lib/asyncio/runners.py`"

msgid ""
"This section outlines high-level asyncio primitives to run asyncio code."
msgstr ""
"Esta secção descreve as primitivas de alto nível do asyncio para executar "
"código asyncio."

msgid ""
"They are built on top of an :ref:`event loop <asyncio-event-loop>` with the "
"aim to simplify async code usage for common wide-spread scenarios."
msgstr ""
"Estas são construídas sobre um :ref:`ciclo de eventos (event loop) <asyncio-"
"event-loop>` com o objetivo de simplificar o uso de código assíncrono em "
"cenários comuns e generalizados."

msgid "Running an asyncio Program"
msgstr "Executar um Programa asyncio"

msgid "Execute *coro* in an asyncio event loop and return the result."
msgstr "Executa *coro* num ciclo de eventos asyncio e devolve o resultado."

msgid "The argument can be any awaitable object."
msgstr "O argumento pode ser qualquer objeto awaitable."

msgid ""
"This function runs the awaitable, taking care of managing the asyncio event "
"loop, *finalizing asynchronous generators*, and closing the executor."
msgstr ""
"Esta função executa o awaitable, encarregando-se de gerir o ciclo de eventos "
"do asyncio, *finalizar geradores assíncronos* e fechar o executor."

msgid ""
"This function cannot be called when another asyncio event loop is running in "
"the same thread."
msgstr ""
"Esta função não pode ser chamada quando outro ciclo de eventos asyncio "
"estiver a ser executado na mesma thread."

msgid ""
"If *debug* is ``True``, the event loop will be run in debug mode. ``False`` "
"disables debug mode explicitly. ``None`` is used to respect the global :ref:"
"`asyncio-debug-mode` settings."
msgstr ""
"Se *debug* for ``True``, o ciclo de eventos será executado em modo de "
"depuração. ``False`` desativa o modo de depuração explicitamente. ``None`` é "
"usado para respeitar as configurações globais de :ref:`asyncio-debug-mode`."

msgid ""
"If *loop_factory* is not ``None``, it is used to create a new event loop; "
"otherwise :func:`asyncio.new_event_loop` is used. The loop is closed at the "
"end. This function should be used as a main entry point for asyncio "
"programs, and should ideally only be called once. It is recommended to use "
"*loop_factory* to configure the event loop instead of policies. Passing :"
"class:`asyncio.EventLoop` allows running asyncio without the policy system."
msgstr ""
"Se *loop_factory* não for ``None``, este é usado para criar um novo ciclo de "
"eventos; caso contrário, usa-se :func:`asyncio.new_event_loop`. O ciclo é "
"fechado no final. Esta função deve ser usada como o ponto de entrada "
"principal para programas asyncio, e idealmente deve ser chamada apenas uma "
"vez. Recomenda-se o uso de *loop_factory* para configurar o ciclo de eventos "
"em vez de políticas. Passar :class:`asyncio.EventLoop` permite executar o "
"asyncio sem o sistema de políticas."

msgid ""
"The executor is given a timeout duration of 5 minutes to shutdown. If the "
"executor hasn't finished within that duration, a warning is emitted and the "
"executor is closed."
msgstr ""
"Ao executor é atribuída uma duração de tempo limite (timeout) de 5 minutos "
"para encerrar. Se o executor não terminar dentro desse período, é emitido um "
"aviso e o executor é fechado."

msgid "Example::"
msgstr "Exemplo::"

msgid ""
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    print('hello')\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    print('olá')\n"
"\n"
"asyncio.run(main())"

msgid "Updated to use :meth:`loop.shutdown_default_executor`."
msgstr "Atualizado para usar :meth:`loop.shutdown_default_executor`."

msgid ""
"*debug* is ``None`` by default to respect the global debug mode settings."
msgstr ""
"*debug* é ``None`` por predefinição para respeitar as configurações globais "
"do modo de depuração."

msgid "Added *loop_factory* parameter."
msgstr "Adicionado o parâmetro *loop_factory*."

msgid "*coro* can be any awaitable object."
msgstr "*coro* pode ser qualquer objeto awaitable."

msgid ""
"The :mod:`!asyncio` policy system is deprecated and will be removed in "
"Python 3.16; from there on, an explicit *loop_factory* is needed to "
"configure the event loop."
msgstr ""
"O sistema de políticas do :mod:`!asyncio` foi descontinuado e será removido "
"no Python 3.16; a partir daí, será necessário um *loop_factory* explícito "
"para configurar o ciclo de eventos."

msgid "Runner context manager"
msgstr "Gestor de contexto Runner"

msgid ""
"A context manager that simplifies *multiple* async function calls in the "
"same context."
msgstr ""
"Um gestor de contexto que simplifica *múltiplas* chamadas de funções "
"assíncronas no mesmo contexto."

msgid ""
"Sometimes several top-level async functions should be called in the same :"
"ref:`event loop <asyncio-event-loop>` and :class:`contextvars.Context`."
msgstr ""
"Por vezes, várias funções assíncronas de alto nível devem ser chamadas no "
"mesmo :ref:`ciclo de eventos <asyncio-event-loop>` e :class:`contextvars."
"Context`."

msgid ""
"*loop_factory* could be used for overriding the loop creation. It is the "
"responsibility of the *loop_factory* to set the created loop as the current "
"one. By default :func:`asyncio.new_event_loop` is used and set as current "
"event loop with :func:`asyncio.set_event_loop` if *loop_factory* is ``None``."
msgstr ""
"*loop_factory* pode ser usado para sobrepor a criação do ciclo. É da "
"responsabilidade do *loop_factory* definir o ciclo criado como o atual. Por "
"predefinição, :func:`asyncio.new_event_loop` é usado e definido como o ciclo "
"de eventos atual com :func:`asyncio.set_event_loop` se o *loop_factory* for "
"``None``."

msgid ""
"Basically, :func:`asyncio.run` example can be rewritten with the runner "
"usage::"
msgstr ""
"Basicamente, o exemplo do :func:`asyncio.run` pode ser reescrito com o uso "
"do runner::"

msgid ""
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    print('hello')\n"
"\n"
"with asyncio.Runner() as runner:\n"
"    runner.run(main())"
msgstr ""
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    print('olá')\n"
"\n"
"with asyncio.Runner() as runner:\n"
"    runner.run(main())"

msgid "Execute *coro* in the embedded event loop."
msgstr "Executa *coro* no ciclo de eventos incorporado."

msgid "If the argument is a coroutine, it is wrapped in a Task."
msgstr "Se o argumento for uma corrotina, esta é envolvida numa Task."

msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the code to run in. The runner's default "
"context is used if context is ``None``."
msgstr ""
"Um argumento opcional *context* (apenas por palavra-chave) permite "
"especificar um :class:`contextvars.Context` personalizado para a execução do "
"código. O contexto predefinido do runner é usado se o contexto for ``None``."

msgid "Returns the awaitable's result or raises an exception."
msgstr "Devolve o resultado do awaitable ou levanta uma exceção."

msgid "Close the runner."
msgstr "Fecha o runner."

msgid ""
"Finalize asynchronous generators, shutdown default executor, close the event "
"loop and release embedded :class:`contextvars.Context`."
msgstr ""
"Finaliza geradores assíncronos, encerra o executor predefinido, fecha o "
"ciclo de eventos e liberta o :class:`contextvars.Context` incorporado."

msgid "Return the event loop associated with the runner instance."
msgstr "Devolve o ciclo de eventos associado à instância do runner."

msgid ""
":class:`Runner` uses the lazy initialization strategy, its constructor "
"doesn't initialize underlying low-level structures."
msgstr ""
"A :class:`Runner` utiliza a estratégia de inicialização diferida (lazy), "
"pelo que o seu construtor não inicializa as estruturas de baixo nível "
"subjacentes."

msgid ""
"Embedded *loop* and *context* are created at the :keyword:`with` body "
"entering or the first call of :meth:`run` or :meth:`get_loop`."
msgstr ""
"O *loop* e o *context* incorporados são criados ao entrar no corpo do :"
"keyword:`with` ou na primeira chamada a :meth:`run` ou :meth:`get_loop`."

msgid "Handling Keyboard Interruption"
msgstr "Tratamento de Interrupção de Teclado"

msgid ""
"When :const:`signal.SIGINT` is raised by :kbd:`Ctrl-C`, :exc:"
"`KeyboardInterrupt` exception is raised in the main thread by default. "
"However this doesn't work with :mod:`asyncio` because it can interrupt "
"asyncio internals and can hang the program from exiting."
msgstr ""
"Quando :const:`signal.SIGINT` é gerado por :kbd:`Ctrl-C`, a exceção :exc:"
"`KeyboardInterrupt` é levantada na thread principal por predefinição. No "
"entanto, isto não funciona bem com o :mod:`asyncio` porque pode interromper "
"mecanismos internos do asyncio e impedir o programa de encerrar."

msgid ""
"To mitigate this issue, :mod:`asyncio` handles :const:`signal.SIGINT` as "
"follows:"
msgstr ""
"Para mitigar este problema, o :mod:`asyncio` trata o :const:`signal.SIGINT` "
"da seguinte forma:"

msgid ""
":meth:`asyncio.Runner.run` installs a custom :const:`signal.SIGINT` handler "
"before any user code is executed and removes it when exiting from the "
"function."
msgstr ""
":meth:`asyncio.Runner.run` instala um manipulador (handler) de :const:"
"`signal.SIGINT` personalizado antes de qualquer código do utilizador ser "
"executado e remove-o ao sair da função."

msgid ""
"The :class:`~asyncio.Runner` creates the main task for the passed coroutine "
"for its execution."
msgstr ""
"O :class:`~asyncio.Runner` cria a tarefa principal para a corrotina passada "
"para a sua execução."

msgid ""
"When :const:`signal.SIGINT` is raised by :kbd:`Ctrl-C`, the custom signal "
"handler cancels the main task by calling :meth:`asyncio.Task.cancel` which "
"raises :exc:`asyncio.CancelledError` inside the main task.  This causes the "
"Python stack to unwind, ``try/except`` and ``try/finally`` blocks can be "
"used for resource cleanup.  After the main task is cancelled, :meth:`asyncio."
"Runner.run` raises :exc:`KeyboardInterrupt`."
msgstr ""
"Quando :const:`signal.SIGINT` é gerado por :kbd:`Ctrl-C`, o manipulador de "
"sinal personalizado cancela a tarefa principal chamando :meth:`asyncio.Task."
"cancel`, o que levanta :exc:`asyncio.CancelledError` dentro da tarefa "
"principal. Isto faz com que a stack do Python se desenrole, permitindo o uso "
"de blocos ``try/except`` e ``try/finally`` para a limpeza de recursos. Após "
"a tarefa principal ser cancelada, :meth:`asyncio.Runner.run` levanta :exc:"
"`KeyboardInterrupt`."

msgid ""
"A user could write a tight loop which cannot be interrupted by :meth:"
"`asyncio.Task.cancel`, in which case the second following :kbd:`Ctrl-C` "
"immediately raises the :exc:`KeyboardInterrupt` without cancelling the main "
"task."
msgstr ""
"Um utilizador poderia escrever um ciclo fechado (tight loop) que não pode "
"ser interrompido por :meth:`asyncio.Task.cancel`, caso em que um segundo :"
"kbd:`Ctrl-C` subsequente levanta imediatamente :exc:`KeyboardInterrupt` sem "
"cancelar a tarefa principal."
