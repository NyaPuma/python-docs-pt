# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-01 14:20+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid "Subprocesses"
msgstr "Subprocessos"

msgid ""
"**Source code:** :source:`Lib/asyncio/subprocess.py`, :source:`Lib/asyncio/"
"base_subprocess.py`"
msgstr ""
"**Código-fonte:** :source:`Lib/asyncio/subprocess.py`, :source:`Lib/asyncio/"
"base_subprocess.py`"

msgid ""
"This section describes high-level async/await asyncio APIs to create and "
"manage subprocesses."
msgstr ""
"Esta secção descreve as APIs de alto nível async/await do asyncio para criar "
"e gerir subprocessos."

msgid ""
"Here's an example of how asyncio can run a shell command and obtain its "
"result::"
msgstr ""
"Eis um exemplo de como o asyncio pode executar um comando shell e obter o "
"seu resultado::"

msgid ""
"import asyncio\n"
"\n"
"async def run(cmd):\n"
"    proc = await asyncio.create_subprocess_shell(\n"
"        cmd,\n"
"        stdout=asyncio.subprocess.PIPE,\n"
"        stderr=asyncio.subprocess.PIPE)\n"
"\n"
"    stdout, stderr = await proc.communicate()\n"
"\n"
"    print(f'[{cmd!r} exited with {proc.returncode}]')\n"
"    if stdout:\n"
"        print(f'[stdout]\\n{stdout.decode()}')\n"
"    if stderr:\n"
"        print(f'[stderr]\\n{stderr.decode()}')\n"
"\n"
"asyncio.run(run('ls /zzz'))"
msgstr ""
"import asyncio\n"
"\n"
"async def run(cmd):\n"
"    proc = await asyncio.create_subprocess_shell(\n"
"        cmd,\n"
"        stdout=asyncio.subprocess.PIPE,\n"
"        stderr=asyncio.subprocess.PIPE)\n"
"\n"
"    stdout, stderr = await proc.communicate()\n"
"\n"
"    print(f'[{cmd!r} terminou com {proc.returncode}]')\n"
"    if stdout:\n"
"        print(f'[stdout]\\n{stdout.decode()}')\n"
"    if stderr:\n"
"        print(f'[stderr]\\n{stderr.decode()}')\n"
"\n"
"asyncio.run(run('ls /zzz'))"

msgid "will print::"
msgstr "imprimirá::"

msgid ""
"['ls /zzz' exited with 1]\n"
"[stderr]\n"
"ls: /zzz: No such file or directory"
msgstr ""
"['ls /zzz' terminou com 1]\n"
"[stderr]\n"
"ls: /zzz: Ficheiro ou diretório inexistente"

msgid ""
"Because all asyncio subprocess functions are asynchronous and asyncio "
"provides many tools to work with such functions, it is easy to execute and "
"monitor multiple subprocesses in parallel.  It is indeed trivial to modify "
"the above example to run several commands simultaneously::"
msgstr ""
"Dado que todas as funções de subprocesso do asyncio são assíncronas e o "
"asyncio fornece várias ferramentas para trabalhar com tais funções, é fácil "
"executar e monitorizar múltiplos subprocessos em paralelo. É, de facto, "
"trivial modificar o exemplo acima para executar vários comandos "
"simultaneamente::"

msgid ""
"async def main():\n"
"    await asyncio.gather(\n"
"        run('ls /zzz'),\n"
"        run('sleep 1; echo \"hello\"'))\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def main():\n"
"    await asyncio.gather(\n"
"        run('ls /zzz'),\n"
"        run('sleep 1; echo \"olá\"'))\n"
"\n"
"asyncio.run(main())"

msgid "See also the `Examples`_ subsection."
msgstr "Consulte também a subsecção `Examples`_."

msgid "Creating Subprocesses"
msgstr "Criar Subprocessos"

msgid "Create a subprocess."
msgstr "Cria um subprocesso."

msgid ""
"The *limit* argument sets the buffer limit for :class:`StreamReader` "
"wrappers for :attr:`~asyncio.subprocess.Process.stdout` and :attr:`~asyncio."
"subprocess.Process.stderr` (if :const:`subprocess.PIPE` is passed to "
"*stdout* and *stderr* arguments)."
msgstr ""
"O argumento *limit* define o limite do buffer para os wrappers :class:"
"`StreamReader` de :attr:`~asyncio.subprocess.Process.stdout` e :attr:"
"`~asyncio.subprocess.Process.stderr` (se :const:`subprocess.PIPE` for "
"passado para os argumentos *stdout* e *stderr*)."

msgid "Return a :class:`~asyncio.subprocess.Process` instance."
msgstr "Retorna uma instância de :class:`~asyncio.subprocess.Process`."

msgid ""
"See the documentation of :meth:`loop.subprocess_exec` for other parameters."
msgstr ""
"Consulte a documentação de :meth:`loop.subprocess_exec` para outros "
"parâmetros."

msgid ""
"If the process object is garbage collected while the process is still "
"running, the child process will be killed."
msgstr ""
"Se o objeto do processo for recolhido pelo garbage collector enquanto o "
"processo ainda estiver a decorrer, o processo filho será terminado (killed)."

msgid "Removed the *loop* parameter."
msgstr "Removido o parâmetro *loop*."

msgid "Run the *cmd* shell command."
msgstr "Executa o comando shell *cmd*."

msgid ""
"See the documentation of :meth:`loop.subprocess_shell` for other parameters."
msgstr ""
"Consulte a documentação de :meth:`loop.subprocess_shell` para outros "
"parâmetros."

msgid ""
"It is the application's responsibility to ensure that all whitespace and "
"special characters are quoted appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. The :func:`shlex.quote` function can be used to properly "
"escape whitespace and special shell characters in strings that are going to "
"be used to construct shell commands."
msgstr ""
"É responsabilidade da aplicação garantir que todos os espaços em branco e "
"caracteres especiais sejam devidamente protegidos por aspas para evitar "
"vulnerabilidades de `injeção de shell <https://en.wikipedia.org/wiki/"
"Shell_injection#Shell_injection>`_. A função :func:`shlex.quote` pode ser "
"utilizada para escapar corretamente espaços e caracteres especiais em "
"strings que serão usadas para construir comandos shell."

msgid ""
"Subprocesses are available for Windows if a :class:`ProactorEventLoop` is "
"used. See :ref:`Subprocess Support on Windows <asyncio-windows-subprocess>` "
"for details."
msgstr ""
"Os subprocessos estão disponíveis em Windows se for utilizado um :class:"
"`ProactorEventLoop`. Consulte :ref:`Suporte a Subprocessos em Windows "
"<asyncio-windows-subprocess>` para detalhes."

msgid ""
"asyncio also has the following *low-level* APIs to work with subprocesses: :"
"meth:`loop.subprocess_exec`, :meth:`loop.subprocess_shell`, :meth:`loop."
"connect_read_pipe`, :meth:`loop.connect_write_pipe`, as well as the :ref:"
"`Subprocess Transports <asyncio-subprocess-transports>` and :ref:`Subprocess "
"Protocols <asyncio-subprocess-protocols>`."
msgstr ""
"O asyncio também possui as seguintes APIs de *baixo nível* para trabalhar "
"com subprocessos: :meth:`loop.subprocess_exec`, :meth:`loop."
"subprocess_shell`, :meth:`loop.connect_read_pipe`, :meth:`loop."
"connect_write_pipe`, bem como os :ref:`Transportes de Subprocesso <asyncio-"
"subprocess-transports>` e :ref:`Protocolos de Subprocesso <asyncio-"
"subprocess-protocols>`."

msgid "Constants"
msgstr "Constantes"

msgid "Can be passed to the *stdin*, *stdout* or *stderr* parameters."
msgstr "Pode ser passado aos parâmetros *stdin*, *stdout* ou *stderr*."

msgid ""
"If *PIPE* is passed to *stdin* argument, the :attr:`Process.stdin <asyncio."
"subprocess.Process.stdin>` attribute will point to a :class:`~asyncio."
"StreamWriter` instance."
msgstr ""
"Se *PIPE* for passado ao argumento *stdin*, o atributo :attr:`Process.stdin "
"<asyncio.subprocess.Process.stdin>` apontará para uma instância de :class:"
"`~asyncio.StreamWriter`."

msgid ""
"If *PIPE* is passed to *stdout* or *stderr* arguments, the :attr:`Process."
"stdout <asyncio.subprocess.Process.stdout>` and :attr:`Process.stderr "
"<asyncio.subprocess.Process.stderr>` attributes will point to :class:"
"`~asyncio.StreamReader` instances."
msgstr ""
"Se *PIPE* for passado aos argumentos *stdout* ou *stderr*, os atributos :"
"attr:`Process.stdout <asyncio.subprocess.Process.stdout>` e :attr:`Process."
"stderr <asyncio.subprocess.Process.stderr>` apontarão para instâncias de :"
"class:`~asyncio.StreamReader`."

msgid ""
"Special value that can be used as the *stderr* argument and indicates that "
"standard error should be redirected into standard output."
msgstr ""
"Valor especial que pode ser usado como argumento *stderr* e indica que o "
"erro padrão deve ser redirecionado para a saída padrão."

msgid ""
"Special value that can be used as the *stdin*, *stdout* or *stderr* argument "
"to process creation functions.  It indicates that the special file :data:`os."
"devnull` will be used for the corresponding subprocess stream."
msgstr ""
"Valor especial que pode ser usado como argumento *stdin*, *stdout* ou "
"*stderr* nas funções de criação de processos. Indica que o ficheiro "
"especial :data:`os.devnull` será utilizado para o fluxo correspondente do "
"subprocesso."

msgid "Interacting with Subprocesses"
msgstr "Interagir com Subprocessos"

msgid ""
"Both :func:`create_subprocess_exec` and :func:`create_subprocess_shell` "
"functions return instances of the *Process* class.  *Process* is a high-"
"level wrapper that allows communicating with subprocesses and watching for "
"their completion."
msgstr ""
"Ambas as funções :func:`create_subprocess_exec` e :func:"
"`create_subprocess_shell` retornam instâncias da classe *Process*. *Process* "
"é um wrapper de alto nível que permite comunicar com subprocessos e aguardar "
"pela sua conclusão."

msgid ""
"An object that wraps OS processes created by the :func:`~asyncio."
"create_subprocess_exec` and :func:`~asyncio.create_subprocess_shell` "
"functions."
msgstr ""
"Um objeto que envolve processos do SO criados pelas funções :func:`~asyncio."
"create_subprocess_exec` e :func:`~asyncio.create_subprocess_shell`."

msgid ""
"This class is designed to have a similar API to the :class:`subprocess."
"Popen` class, but there are some notable differences:"
msgstr ""
"Esta classe foi desenhada para ter uma API semelhante à classe :class:"
"`subprocess.Popen`, mas existem algumas diferenças notáveis:"

msgid ""
"unlike Popen, Process instances do not have an equivalent to the :meth:"
"`~subprocess.Popen.poll` method;"
msgstr ""
"ao contrário de Popen, instâncias de Process não têm um equivalente ao "
"método :meth:`~subprocess.Popen.poll`;"

msgid ""
"the :meth:`~asyncio.subprocess.Process.communicate` and :meth:`~asyncio."
"subprocess.Process.wait` methods don't have a *timeout* parameter: use the :"
"func:`~asyncio.wait_for` function;"
msgstr ""
"os métodos :meth:`~asyncio.subprocess.Process.communicate` e :meth:`~asyncio."
"subprocess.Process.wait` não têm um parâmetro *timeout*: utilize a função :"
"func:`~asyncio.wait_for`;"

msgid ""
"the :meth:`Process.wait() <asyncio.subprocess.Process.wait>` method is "
"asynchronous, whereas :meth:`subprocess.Popen.wait` method is implemented as "
"a blocking busy loop;"
msgstr ""
"o método :meth:`Process.wait() <asyncio.subprocess.Process.wait>` é "
"assíncrono, enquanto o método :meth:`subprocess.Popen.wait` é implementado "
"como um loop de espera bloqueante (busy loop);"

msgid "the *universal_newlines* parameter is not supported."
msgstr "o parâmetro *universal_newlines* não é suportado."

msgid "This class is :ref:`not thread safe <asyncio-multithreading>`."
msgstr "Esta classe :ref:`não é segura para threads <asyncio-multithreading>`."

msgid ""
"See also the :ref:`Subprocess and Threads <asyncio-subprocess-threads>` "
"section."
msgstr ""
"Consulte também a secção :ref:`Subprocessos e Threads <asyncio-subprocess-"
"threads>`."

msgid "Wait for the child process to terminate."
msgstr "Aguarda que o processo filho termine."

msgid "Set and return the :attr:`returncode` attribute."
msgstr "Define e retorna o atributo :attr:`returncode`."

msgid ""
"This method can deadlock when using ``stdout=PIPE`` or ``stderr=PIPE`` and "
"the child process generates so much output that it blocks waiting for the OS "
"pipe buffer to accept more data. Use the :meth:`communicate` method when "
"using pipes to avoid this condition."
msgstr ""
"Este método pode causar um deadlock ao usar ``stdout=PIPE`` ou "
"``stderr=PIPE`` e o processo filho gerar tanta saída que fica bloqueado à "
"espera que o buffer de pipe do SO aceite mais dados. Utilize o método :meth:"
"`communicate` ao usar pipes para evitar esta condição."

msgid "Interact with process:"
msgstr "Interage com o processo:"

msgid "send data to *stdin* (if *input* is not ``None``);"
msgstr "envia dados para *stdin* (se *input* não for ``None``);"

msgid "closes *stdin*;"
msgstr "fecha o *stdin*;"

msgid "read data from *stdout* and *stderr*, until EOF is reached;"
msgstr "lê dados de *stdout* e *stderr*, até que o EOF seja atingido;"

msgid "wait for process to terminate."
msgstr "aguarda que o processo termine."

msgid ""
"The optional *input* argument is the data (:class:`bytes` object) that will "
"be sent to the child process."
msgstr ""
"O argumento opcional *input* são os dados (objeto :class:`bytes`) que serão "
"enviados para o processo filho."

msgid "Return a tuple ``(stdout_data, stderr_data)``."
msgstr "Retorna um tuplo ``(stdout_data, stderr_data)``."

msgid ""
"If either :exc:`BrokenPipeError` or :exc:`ConnectionResetError` exception is "
"raised when writing *input* into *stdin*, the exception is ignored.  This "
"condition occurs when the process exits before all data are written into "
"*stdin*."
msgstr ""
"Se a exceção :exc:`BrokenPipeError` ou :exc:`ConnectionResetError` for "
"lançada ao escrever *input* no *stdin*, a exceção é ignorada. Esta condição "
"ocorre quando o processo sai antes de todos os dados serem escritos no "
"*stdin*."

msgid ""
"If it is desired to send data to the process' *stdin*, the process needs to "
"be created with ``stdin=PIPE``.  Similarly, to get anything other than "
"``None`` in the result tuple, the process has to be created with "
"``stdout=PIPE`` and/or ``stderr=PIPE`` arguments."
msgstr ""
"Se se desejar enviar dados para o *stdin* do processo, o processo deve ser "
"criado com ``stdin=PIPE``. Da mesma forma, para obter algo diferente de "
"``None`` no tuplo de resultado, o processo tem de ser criado com os "
"argumentos ``stdout=PIPE`` e/ou ``stderr=PIPE``."

msgid ""
"Note, that the data read is buffered in memory, so do not use this method if "
"the data size is large or unlimited."
msgstr ""
"Note que os dados lidos são armazenados num buffer em memória, por isso não "
"utilize este método se o tamanho dos dados for grande ou ilimitado."

msgid "*stdin* gets closed when ``input=None`` too."
msgstr "O *stdin* também é fechado quando ``input=None``."

msgid "Sends the signal *signal* to the child process."
msgstr "Envia o sinal *signal* para o processo filho."

msgid ""
"On Windows, :py:const:`~signal.SIGTERM` is an alias for :meth:`terminate`. "
"``CTRL_C_EVENT`` and ``CTRL_BREAK_EVENT`` can be sent to processes started "
"with a *creationflags* parameter which includes ``CREATE_NEW_PROCESS_GROUP``."
msgstr ""
"Em Windows, :py:const:`~signal.SIGTERM` é um alias para :meth:`terminate`. "
"``CTRL_C_EVENT`` e ``CTRL_BREAK_EVENT`` podem ser enviados para processos "
"iniciados com um parâmetro *creationflags* que inclua "
"``CREATE_NEW_PROCESS_GROUP``."

msgid "Stop the child process."
msgstr "Para o processo filho."

msgid ""
"On POSIX systems this method sends :py:const:`~signal.SIGTERM` to the child "
"process."
msgstr ""
"Em sistemas POSIX, este método envia :py:const:`~signal.SIGTERM` para o "
"processo filho."

msgid ""
"On Windows the Win32 API function :c:func:`!TerminateProcess` is called to "
"stop the child process."
msgstr ""
"Em Windows, a função da API Win32 :c:func:`!TerminateProcess` é chamada para "
"parar o processo filho."

msgid "Kill the child process."
msgstr "Termina forçadamente (kill) o processo filho."

msgid ""
"On POSIX systems this method sends :py:data:`~signal.SIGKILL` to the child "
"process."
msgstr ""
"Em sistemas POSIX, este método envia :py:data:`~signal.SIGKILL` para o "
"processo filho."

msgid "On Windows this method is an alias for :meth:`terminate`."
msgstr "Em Windows, este método é um alias para :meth:`terminate`."

msgid ""
"Standard input stream (:class:`~asyncio.StreamWriter`) or ``None`` if the "
"process was created with ``stdin=None``."
msgstr ""
"Fluxo de entrada padrão (:class:`~asyncio.StreamWriter`) ou ``None`` se o "
"processo foi criado com ``stdin=None``."

msgid ""
"Standard output stream (:class:`~asyncio.StreamReader`) or ``None`` if the "
"process was created with ``stdout=None``."
msgstr ""
"Fluxo de saída padrão (:class:`~asyncio.StreamReader`) ou ``None`` se o "
"processo foi criado com ``stdout=None``."

msgid ""
"Standard error stream (:class:`~asyncio.StreamReader`) or ``None`` if the "
"process was created with ``stderr=None``."
msgstr ""
"Fluxo de erro padrão (:class:`~asyncio.StreamReader`) ou ``None`` se o "
"processo foi criado com ``stderr=None``."

msgid ""
"Use the :meth:`communicate` method rather than :attr:`process.stdin.write() "
"<stdin>`, :attr:`await process.stdout.read() <stdout>` or :attr:`await "
"process.stderr.read() <stderr>`. This avoids deadlocks due to streams "
"pausing reading or writing and blocking the child process."
msgstr ""
"Utilize o método :meth:`communicate` em vez de :attr:`process.stdin.write() "
"<stdin>`, :attr:`await process.stdout.read() <stdout>` ou :attr:`await "
"process.stderr.read() <stderr>`. Isto evita deadlocks devido a fluxos que "
"pausam a leitura ou escrita e bloqueiam o processo filho."

msgid "Process identification number (PID)."
msgstr "Número de identificação do processo (PID)."

msgid ""
"Note that for processes created by the :func:`~asyncio."
"create_subprocess_shell` function, this attribute is the PID of the spawned "
"shell."
msgstr ""
"Note que para processos criados pela função :func:`~asyncio."
"create_subprocess_shell`, este atributo é o PID da shell gerada."

msgid "Return code of the process when it exits."
msgstr "Código de retorno do processo quando este termina."

msgid "A ``None`` value indicates that the process has not terminated yet."
msgstr "Um valor ``None`` indica que o processo ainda não terminou."

msgid ""
"A negative value ``-N`` indicates that the child was terminated by signal "
"``N`` (POSIX only)."
msgstr ""
"Um valor negativo ``-N`` indica que o processo filho foi terminado pelo "
"sinal ``N`` (apenas POSIX)."

msgid "Subprocess and Threads"
msgstr "Subprocessos e Threads"

msgid ""
"Standard asyncio event loop supports running subprocesses from different "
"threads by default."
msgstr ""
"O event loop padrão do asyncio suporta a execução de subprocessos a partir "
"de diferentes threads por predefinição."

msgid ""
"On Windows subprocesses are provided by :class:`ProactorEventLoop` only "
"(default), :class:`SelectorEventLoop` has no subprocess support."
msgstr ""
"Em Windows, os subprocessos são fornecidos apenas por :class:"
"`ProactorEventLoop` (padrão); o :class:`SelectorEventLoop` não possui "
"suporte para subprocessos."

msgid ""
"Note that alternative event loop implementations might have own limitations; "
"please refer to their documentation."
msgstr ""
"Note que implementações alternativas de event loop podem ter as suas "
"próprias limitações; por favor, consulte a respetiva documentação."

msgid ""
"The :ref:`Concurrency and multithreading in asyncio <asyncio-"
"multithreading>` section."
msgstr ""
"A secção :ref:`Concorrência e multithreading em asyncio <asyncio-"
"multithreading>`."

msgid "Examples"
msgstr "Exemplos"

msgid ""
"An example using the :class:`~asyncio.subprocess.Process` class to control a "
"subprocess and the :class:`StreamReader` class to read from its standard "
"output."
msgstr ""
"Um exemplo utilizando a classe :class:`~asyncio.subprocess.Process` para "
"controlar um subprocesso e a classe :class:`StreamReader` para ler da sua "
"saída padrão."

msgid ""
"The subprocess is created by the :func:`create_subprocess_exec` function::"
msgstr "O subprocesso é criado pela função :func:`create_subprocess_exec`::"

msgid ""
"import asyncio\n"
"import sys\n"
"\n"
"async def get_date():\n"
"    code = 'import datetime; print(datetime.datetime.now())'\n"
"\n"
"    # Create the subprocess; redirect the standard output\n"
"    # into a pipe.\n"
"    proc = await asyncio.create_subprocess_exec(\n"
"        sys.executable, '-c', code,\n"
"        stdout=asyncio.subprocess.PIPE)\n"
"\n"
"    # Read one line of output.\n"
"    data = await proc.stdout.readline()\n"
"    line = data.decode('ascii').rstrip()\n"
"\n"
"    # Wait for the subprocess exit.\n"
"    await proc.wait()\n"
"    return line\n"
"\n"
"date = asyncio.run(get_date())\n"
"print(f\"Current date: {date}\")"
msgstr ""
"import asyncio\n"
"import sys\n"
"\n"
"async def get_date():\n"
"    code = 'import datetime; print(datetime.datetime.now())'\n"
"\n"
"    # Cria o subprocesso; redireciona a saída padrão\n"
"    # para um pipe.\n"
"    proc = await asyncio.create_subprocess_exec(\n"
"        sys.executable, '-c', code,\n"
"        stdout=asyncio.subprocess.PIPE)\n"
"\n"
"    # Lê uma linha da saída.\n"
"    data = await proc.stdout.readline()\n"
"    line = data.decode('ascii').rstrip()\n"
"\n"
"    # Aguarda a saída do subprocesso.\n"
"    await proc.wait()\n"
"    return line\n"
"\n"
"date = asyncio.run(get_date())\n"
"print(f\"Data atual: {date}\")"

msgid ""
"See also the :ref:`same example <asyncio_example_subprocess_proto>` written "
"using low-level APIs."
msgstr ""
"Consulte também o :ref:`mesmo exemplo <asyncio_example_subprocess_proto>` "
"escrito utilizando APIs de baixo nível."
