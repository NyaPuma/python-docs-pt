# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-07 14:20+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!atexit` --- Exit handlers"
msgstr ":mod:`!atexit` --- Manipuladores de saída"

msgid ""
"The :mod:`!atexit` module defines functions to register and unregister "
"cleanup functions.  Functions thus registered are automatically executed "
"upon normal interpreter termination.  :mod:`!atexit` runs these functions in "
"the *reverse* order in which they were registered; if you register ``A``, "
"``B``, and ``C``, at interpreter termination time they will be run in the "
"order ``C``, ``B``, ``A``."
msgstr ""
"O módulo :mod:`!atexit` define funções para registar e cancelar o registo de "
"funções de limpeza. As funções assim registadas são executadas "
"automaticamente após o encerramento normal do interpretador. O :mod:`!"
"atexit` executa essas funções na ordem *inversa* em que foram registadas; se "
"registar ``A``, ``B`` e ``C``, no momento do encerramento do interpretador "
"elas serão executadas na ordem ``C``, ``B``, ``A``."

msgid ""
"**Note:** The functions registered via this module are not called when the "
"program is killed by a signal not handled by Python, when a Python fatal "
"internal error is detected, or when :func:`os._exit` is called."
msgstr ""
"**Nota:** As funções registadas através deste módulo não são chamadas quando "
"o programa é encerrado por um sinal não tratado pelo Python, quando é "
"detetado um erro interno fatal do Python ou quando :func:`os._exit` é "
"chamado."

msgid ""
"**Note:** The effect of registering or unregistering functions from within a "
"cleanup function is undefined."
msgstr ""
"**Observação:** O efeito do registo ou cancelamento do registo de funções a "
"partir de uma função de limpeza é indefinido."

msgid ""
"When used with C-API subinterpreters, registered functions are local to the "
"interpreter they were registered in."
msgstr ""
"Quando utilizadas com subinterpretadores C-API, as funções registadas são "
"locais ao interpretador em que foram registadas."

msgid ""
"Register *func* as a function to be executed at termination.  Any optional "
"arguments that are to be passed to *func* must be passed as arguments to :"
"func:`register`.  It is possible to register the same function and arguments "
"more than once."
msgstr ""
"Regista *func* como uma função a ser executada no encerramento. Quaisquer "
"argumentos opcionais que devam ser passados para *func* devem ser passados "
"como argumentos para :func:`register`. É possível registar a mesma função e "
"argumentos mais de uma vez."

msgid ""
"At normal program termination (for instance, if :func:`sys.exit` is called "
"or the main module's execution completes), all functions registered are "
"called in last in, first out order.  The assumption is that lower level "
"modules will normally be imported before higher level modules and thus must "
"be cleaned up later."
msgstr ""
"No encerramento normal do programa (por exemplo, se :func:`sys.exit` for "
"chamado ou a execução do módulo principal for concluída), todas as funções "
"registradas são chamadas na ordem de última a entrar, primeira a sair. A "
"suposição é que os módulos de nível inferior normalmente serão importados "
"antes dos módulos de nível superior e, portanto, devem ser limpos "
"posteriormente."

msgid ""
"If an exception is raised during execution of the exit handlers, a traceback "
"is printed (unless :exc:`SystemExit` is raised) and the exception "
"information is saved.  After all exit handlers have had a chance to run, the "
"last exception to be raised is re-raised."
msgstr ""
"Se uma exceção for levantada durante a execução dos manipuladores de saída, "
"um rastreamento é impresso (a menos que :exc:`SystemExit` seja levantado) e "
"as informações da exceção são guardadas. Depois que todos os manipuladores "
"de saída tiverem a oportunidade de ser executados, a última exceção a ser "
"levantada é levantada novamente."

msgid ""
"This function returns *func*, which makes it possible to use it as a "
"decorator."
msgstr ""
"Esta função retorna *func*, o que torna possível usá-la como um decorador."

msgid ""
"Starting new threads or calling :func:`os.fork` from a registered function "
"can lead to race condition between the main Python runtime thread freeing "
"thread states while internal :mod:`threading` routines or the new process "
"try to use that state. This can lead to crashes rather than clean shutdown."
msgstr ""
"Iniciar novos threads ou chamar :func:`os.fork` a partir de uma função "
"registada pode levar a uma condição de corrida entre o thread principal do "
"Python, que liberta os estados dos threads, enquanto as rotinas internas :"
"mod:`threading` ou o novo processo tentam usar esse estado. Isso pode levar "
"a falhas, em vez de um encerramento limpo."

msgid ""
"Attempts to start a new thread or :func:`os.fork` a new process in a "
"registered function now leads to :exc:`RuntimeError`."
msgstr ""
"As tentativas de iniciar um novo thread ou :func:`os.fork` um novo processo "
"numa função registada agora levam a :exc:`RuntimeError`."

msgid ""
"Remove *func* from the list of functions to be run at interpreter shutdown. :"
"func:`unregister` silently does nothing if *func* was not previously "
"registered.  If *func* has been registered more than once, every occurrence "
"of that function in the :mod:`!atexit` call stack will be removed.  Equality "
"comparisons (``==``) are used internally during unregistration, so function "
"references do not need to have matching identities."
msgstr ""
"Remove *func* da lista de funções a serem executadas no encerramento do "
"interpretador. :func:`unregister` silenciosamente não faz nada se *func* não "
"tiver sido previamente registado. Se *func* tiver sido registado mais de uma "
"vez, todas as ocorrências dessa função na stack de chamadas :mod:`!atexit` "
"serão removidas. Comparações de igualdade (``==``) são usadas internamente "
"durante o cancelamento do registo, portanto, as referências de função não "
"precisam ter identidades correspondentes."

msgid "Module :mod:`readline`"
msgstr "Módulo :mod:`readline`"

msgid ""
"Useful example of :mod:`!atexit` to read and write :mod:`readline` history "
"files."
msgstr ""
"Exemplo útil de :mod:`!atexit` para ler e escrever ficheiros de histórico :"
"mod:`readline`."

msgid ":mod:`!atexit` Example"
msgstr "Exemplo :mod:`!atexit` "

msgid ""
"The following simple example demonstrates how a module can initialize a "
"counter from a file when it is imported and save the counter's updated value "
"automatically when the program terminates without relying on the application "
"making an explicit call into this module at termination. ::"
msgstr ""
"O exemplo simples a seguir demonstra como um módulo pode inicializar um "
"contador a partir de um ficheiro quando é importado e salvar o valor "
"atualizado do contador automaticamente quando o programa é encerrado, sem "
"depender de uma chamada explícita da aplicação a este módulo no "
"encerramento. ::"

msgid ""
"try:\n"
"    with open('counterfile') as infile:\n"
"        _count = int(infile.read())\n"
"except FileNotFoundError:\n"
"    _count = 0\n"
"\n"
"def incrcounter(n):\n"
"    global _count\n"
"    _count = _count + n\n"
"\n"
"def savecounter():\n"
"    with open('counterfile', 'w') as outfile:\n"
"        outfile.write('%d' % _count)\n"
"\n"
"import atexit\n"
"\n"
"atexit.register(savecounter)"
msgstr ""
"try:\n"
"    with open('counterfile') as infile:\n"
"        _count = int(infile.read())\n"
"except FileNotFoundError:\n"
"    _count = 0\n"
"\n"
"def incrcounter(n):\n"
"    global _count\n"
"    _count = _count + n\n"
"\n"
"def savecounter():\n"
"    with open('counterfile', 'w') as outfile:\n"
"        outfile.write('%d' % _count)\n"
"\n"
"import atexit\n"
"\n"
"atexit.register(savecounter)"

msgid ""
"Positional and keyword arguments may also be passed to :func:`register` to "
"be passed along to the registered function when it is called::"
msgstr ""
"Argumentos posicionais e nomeados também podem ser passados para :func:"
"`register` para serem passados para a função registrada quando ela for "
"chamada::"

msgid ""
"def goodbye(name, adjective):\n"
"    print('Goodbye %s, it was %s to meet you.' % (name, adjective))\n"
"\n"
"import atexit\n"
"\n"
"atexit.register(goodbye, 'Donny', 'nice')\n"
"# or:\n"
"atexit.register(goodbye, adjective='nice', name='Donny')"
msgstr ""
"def goodbye(name, adjective):\n"
"    print('Goodbye %s, it was %s to meet you.' % (name, adjective))\n"
"\n"
"import atexit\n"
"\n"
"atexit.register(goodbye, 'Donny', 'nice')\n"
"# ou:\n"
"atexit.register(goodbye, adjective='nice', name='Donny')"

msgid "Usage as a :term:`decorator`::"
msgstr "Utilização como :term:`decorador`::"

msgid ""
"import atexit\n"
"\n"
"@atexit.register\n"
"def goodbye():\n"
"    print('You are now leaving the Python sector.')"
msgstr ""
"import atexit\n"
"\n"
"@atexit.register\n"
"def goodbye():\n"
"    print('You are now leaving the Python sector.')"

msgid "This only works with functions that can be called without arguments."
msgstr "Isto só funciona com funções que podem ser chamadas sem argumentos."
