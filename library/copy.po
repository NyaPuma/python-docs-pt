# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-09 14:46+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!copy` --- Shallow and deep copy operations"
msgstr ":mod:`!copy` --- Operações de cópia superficial e profunda"

msgid "**Source code:** :source:`Lib/copy.py`"
msgstr "**Código fonte:** :source:`Lib/copy.py`"

msgid ""
"Assignment statements in Python do not copy objects, they create bindings "
"between a target and an object. For collections that are mutable or contain "
"mutable items, a copy is sometimes needed so one can change one copy without "
"changing the other. This module provides generic shallow and deep copy "
"operations (explained below)."
msgstr ""
"As instruções de atribuição em Python não copiam objetos, elas criam "
"ligações entre um destino e um objeto. Para coleções que são mutáveis ou "
"contêm itens mutáveis, às vezes é necessária uma cópia para que se possa "
"alterar uma cópia sem alterar a outra. Este módulo fornece operações "
"genéricas de cópia superficial e profunda (explicadas abaixo)."

msgid "Interface summary:"
msgstr "Resumo da interface:"

msgid "Return a shallow copy of *obj*."
msgstr "Retorna uma cópia superficial de *obj*."

msgid "Return a deep copy of *obj*."
msgstr "Retorna uma cópia profunda de *obj*."

msgid ""
"Creates a new object of the same type as *obj*, replacing fields with values "
"from *changes*."
msgstr ""
"Cria um novo objeto do mesmo tipo que *obj*, substituindo campos por valores "
"de *changes*."

msgid "Raised for module specific errors."
msgstr "Gerado para erros específicos do módulo."

msgid ""
"The difference between shallow and deep copying is only relevant for "
"compound objects (objects that contain other objects, like lists or class "
"instances):"
msgstr ""
"A diferença entre cópia superficial e profunda só é relevante para objetos "
"compostos (objetos que contêm outros objetos, como listas ou instâncias de "
"classe):"

msgid ""
"A *shallow copy* constructs a new compound object and then (to the extent "
"possible) inserts *references* into it to the objects found in the original."
msgstr ""
"Uma *cópia superficial* constrói um novo objeto composto e, em seguida, (na "
"medida do possível) insere *referências* nele para os objetos encontrados no "
"original."

msgid ""
"A *deep copy* constructs a new compound object and then, recursively, "
"inserts *copies* into it of the objects found in the original."
msgstr ""
"Uma *cópia profunda* constrói um novo objeto composto e, em seguida, insere "
"recursivamente *cópias* dos objetos encontrados no original."

msgid ""
"Two problems often exist with deep copy operations that don't exist with "
"shallow copy operations:"
msgstr ""
"Existem dois problemas frequentes nas operações de cópia profunda que não "
"existem nas operações de cópia superficial:"

msgid ""
"Recursive objects (compound objects that, directly or indirectly, contain a "
"reference to themselves) may cause a recursive loop."
msgstr ""
"Objetos recursivos (objetos compostos que, direta ou indiretamente, contêm "
"uma referência a si mesmos) podem causar um loop recursivo."

msgid ""
"Because deep copy copies everything it may copy too much, such as data which "
"is intended to be shared between copies."
msgstr ""
"Como a cópia profunda copia tudo, ela pode copiar demais, como dados que "
"devem ser partilhados entre as cópias."

msgid "The :func:`deepcopy` function avoids these problems by:"
msgstr "A função :func:`deepcopy` evita esses problemas ao:"

msgid ""
"keeping a ``memo`` dictionary of objects already copied during the current "
"copying pass; and"
msgstr ""
"mantendo um dicionário de ``memo`` dos objetos já copiados durante a "
"passagem de cópia atual; e"

msgid ""
"letting user-defined classes override the copying operation or the set of "
"components copied."
msgstr ""
"permitindo que classes definidas pelo utilizador substituam a operação de "
"cópia ou o conjunto de componentes copiados."

msgid ""
"This module does not copy types like module, method, stack trace, stack "
"frame, file, socket, window, or any similar types.  It does \"copy\" "
"functions and classes (shallow and deeply), by returning the original object "
"unchanged; this is compatible with the way these are treated by the :mod:"
"`pickle` module."
msgstr ""
"Este módulo não copia tipos como módulo, método, rastreio de stack, frame de "
"stack, ficheiro, socket, janela ou quaisquer tipos semelhantes. Ele «copia» "
"funções e classes (superficialmente e profundamente), devolvendo o objeto "
"original inalterado; isto é compatível com a forma como estes são tratados "
"pelo módulo :mod:`pickle`."

msgid ""
"Shallow copies of dictionaries can be made using :meth:`dict.copy`, and of "
"lists by assigning a slice of the entire list, for example, ``copied_list = "
"original_list[:]``."
msgstr ""
"Cópias superficiais de dicionários podem ser feitas usando :meth:`dict."
"copy`, e de listas atribuindo uma fatia da lista inteira, por exemplo, "
"``copied_list = original_list[:]``."

msgid ""
"Classes can use the same interfaces to control copying that they use to "
"control pickling.  See the description of module :mod:`pickle` for "
"information on these methods.  In fact, the :mod:`!copy` module uses the "
"registered pickle functions from the :mod:`copyreg` module."
msgstr ""
"As classes podem usar as mesmas interfaces para controlar a cópia que usam "
"para controlar o pickling. Consulte a descrição do módulo :mod:`pickle` para "
"obter informações sobre esses métodos. Na verdade, o módulo :mod:`!copy` usa "
"as funções pickle registradas do módulo :mod:`copyreg`."

msgid ""
"In order for a class to define its own copy implementation, it can define "
"special methods :meth:`~object.__copy__` and :meth:`~object.__deepcopy__`."
msgstr ""
"Para que uma classe defina a sua própria implementação de cópia, ela pode "
"definir métodos especiais :meth:`~object.__copy__` e :meth:`~object."
"__deepcopy__`."

msgid ""
"Called to implement the shallow copy operation; no additional arguments are "
"passed."
msgstr ""
"Chamado para implementar a operação de cópia superficial; nenhum argumento "
"adicional é passado."

msgid ""
"Called to implement the deep copy operation; it is passed one argument, the "
"*memo* dictionary.  If the ``__deepcopy__`` implementation needs to make a "
"deep copy of a component, it should call the :func:`~copy.deepcopy` function "
"with the component as first argument and the *memo* dictionary as second "
"argument. The *memo* dictionary should be treated as an opaque object."
msgstr ""
"Chamado para implementar a operação de cópia profunda; recebe um argumento, "
"o dicionário *memo*. Se a implementação de ``__deepcopy__`` precisar fazer "
"uma cópia profunda de um componente, ela deve chamar a função :func:`~copy."
"deepcopy` com o componente como primeiro argumento e o dicionário *memo* "
"como segundo argumento. O dicionário *memo* deve ser tratado como um objeto "
"opaco."

msgid ""
"Function :func:`!copy.replace` is more limited than :func:`~copy.copy` and :"
"func:`~copy.deepcopy`, and only supports named tuples created by :func:"
"`~collections.namedtuple`, :mod:`dataclasses`, and other classes which "
"define method :meth:`~object.__replace__`."
msgstr ""
"A função :func:`!copy.replace` é mais limitada do que :func:`~copy.copy` e :"
"func:`~copy.deepcopy`, e suporta apenas tuplos nomeados criados por :func:"
"`~collections.namedtuple`, :mod:`dataclasses` e outras classes que definem o "
"método :meth:`~object.__replace__`."

msgid ""
"This method should create a new object of the same type, replacing fields "
"with values from *changes*."
msgstr ""
"Este método deve criar um novo objeto do mesmo tipo, substituindo campos por "
"valores de *alterações*."

msgid "Module :mod:`pickle`"
msgstr "Módulo :mod:`pickle`"

msgid ""
"Discussion of the special methods used to support object state retrieval and "
"restoration."
msgstr ""
"Discussão sobre os métodos especiais utilizados para apoiar a recuperação e "
"restauração do estado dos objetos."

msgid "module"
msgstr "módulo"

msgid "pickle"
msgstr "pickle"

msgid "__copy__() (copy protocol)"
msgstr "__copy__() (protocolo de cópia)"

msgid "__deepcopy__() (copy protocol)"
msgstr "__deepcopy__() (protocolo de cópia)"

msgid "__replace__() (replace protocol)"
msgstr "__replace__() (protocolo de substituição)"
