# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-07 14:20+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!email.header`: Internationalized headers"
msgstr ":mod:`!email.header`: Cabeçalhos internacionalizados"

msgid "**Source code:** :source:`Lib/email/header.py`"
msgstr "**Código-fonte:** :source:`Lib/email/header.py`"

msgid ""
"This module is part of the legacy (``Compat32``) email API.  In the current "
"API encoding and decoding of headers is handled transparently by the "
"dictionary-like API of the :class:`~email.message.EmailMessage` class.  In "
"addition to uses in legacy code, this module can be useful in applications "
"that need to completely control the character sets used when encoding "
"headers."
msgstr ""
"Este módulo faz parte da API de e-mail legada (``Compat32``). Na API atual, "
"a codificação e descodificação de cabeçalhos é gerida de forma transparente "
"pela API tipo dicionário da classe :class:`~email.message.EmailMessage`. "
"Além de ser usado em código legado, este módulo pode ser útil em aplicações "
"que necessitem de controlar totalmente os conjuntos de caracteres usados ao "
"codificar cabeçalhos."

msgid ""
"The remaining text in this section is the original documentation of the "
"module."
msgstr "O texto restante nesta secção é a documentação original do módulo."

msgid ""
":rfc:`2822` is the base standard that describes the format of email "
"messages. It derives from the older :rfc:`822` standard which came into "
"widespread use at a time when most email was composed of ASCII characters "
"only.  :rfc:`2822` is a specification written assuming email contains only 7-"
"bit ASCII characters."
msgstr ""
"A :rfc:`2822` é a norma base que descreve o formato das mensagens de e-mail. "
"Deriva da norma :rfc:`822` mais antiga, que se tornou generalizada numa "
"altura em que a maioria dos e-mails era composta apenas por caracteres "
"ASCII. A :rfc:`2822` é uma especificação escrita assumindo que o e-mail "
"contém apenas caracteres ASCII de 7 bits."

msgid ""
"Of course, as email has been deployed worldwide, it has become "
"internationalized, such that language specific character sets can now be "
"used in email messages.  The base standard still requires email messages to "
"be transferred using only 7-bit ASCII characters, so a slew of RFCs have "
"been written describing how to encode email containing non-ASCII characters "
"into :rfc:`2822`\\ -compliant format. These RFCs include :rfc:`2045`, :rfc:"
"`2046`, :rfc:`2047`, and :rfc:`2231`. The :mod:`email` package supports "
"these standards in its :mod:`!email.header` and :mod:`email.charset` modules."
msgstr ""

msgid ""
"If you want to include non-ASCII characters in your email headers, say in "
"the :mailheader:`Subject` or :mailheader:`To` fields, you should use the :"
"class:`Header` class and assign the field in the :class:`~email.message."
"Message` object to an instance of :class:`Header` instead of using a string "
"for the header value.  Import the :class:`Header` class from the :mod:`!"
"email.header` module. For example::"
msgstr ""

msgid ""
">>> from email.message import Message\n"
">>> from email.header import Header\n"
">>> msg = Message()\n"
">>> h = Header('p\\xf6stal', 'iso-8859-1')\n"
">>> msg['Subject'] = h\n"
">>> msg.as_string()\n"
"'Subject: =?iso-8859-1?q?p=F6stal?=\\n\\n'"
msgstr ""
">>> from email.message import Message\n"
">>> from email.header import Header\n"
">>> msg = Message()\n"
">>> h = Header('p\\xf6stal', 'iso-8859-1')\n"
">>> msg['Subject'] = h\n"
">>> msg.as_string()\n"
"'Subject: =?iso-8859-1?q?p=F6stal?=\\n\\n'"

msgid ""
"Notice here how we wanted the :mailheader:`Subject` field to contain a non-"
"ASCII character?  We did this by creating a :class:`Header` instance and "
"passing in the character set that the byte string was encoded in.  When the "
"subsequent :class:`~email.message.Message` instance was flattened, the :"
"mailheader:`Subject` field was properly :rfc:`2047` encoded.  MIME-aware "
"mail readers would show this header using the embedded ISO-8859-1 character."
msgstr ""
"Reparou como queríamos que o campo :mailheader:`Subject` contivesse um "
"carácter não-ASCII? Fizemo-lo criando uma instância de :class:`Header` e "
"passando o conjunto de caracteres em que a byte string foi codificada. "
"Quando a instância subsequente de :class:`~email.message.Message` foi "
"convertida em texto, o campo :mailheader:`Subject` foi devidamente "
"codificado segundo a :rfc:`2047`. Leitores de e-mail compatíveis com MIME "
"mostrariam este cabeçalho usando o carácter ISO-8859-1 incorporado."

msgid "Here is the :class:`Header` class description:"
msgstr "Aqui está a descrição da classe :class:`Header`:"

msgid ""
"Create a MIME-compliant header that can contain strings in different "
"character sets."
msgstr ""
"Cria um cabeçalho compatível com MIME que pode conter strings em diferentes "
"conjuntos de caracteres."

msgid ""
"Optional *s* is the initial header value.  If ``None`` (the default), the "
"initial header value is not set.  You can later append to the header with :"
"meth:`append` method calls.  *s* may be an instance of :class:`bytes` or :"
"class:`str`, but see the :meth:`append` documentation for semantics."
msgstr ""
"O argumento opcional *s* é o valor inicial do cabeçalho. Se for ``None`` (o "
"padrão), o valor inicial não é definido. Pode acrescentar conteúdo ao "
"cabeçalho mais tarde com chamadas ao método :meth:`append`. *s* pode ser uma "
"instância de :class:`bytes` ou :class:`str`, mas consulte a documentação de :"
"meth:`append` para a semântica."

msgid ""
"Optional *charset* serves two purposes: it has the same meaning as the "
"*charset* argument to the :meth:`append` method.  It also sets the default "
"character set for all subsequent :meth:`append` calls that omit the "
"*charset* argument.  If *charset* is not provided in the constructor (the "
"default), the ``us-ascii`` character set is used both as *s*'s initial "
"charset and as the default for subsequent :meth:`append` calls."
msgstr ""
"O *charset* opcional serve dois propósitos: tem o mesmo significado que o "
"argumento *charset* do método :meth:`append`. Também define o conjunto de "
"caracteres padrão para todas as chamadas subsequentes a :meth:`append` que "
"omitirem esse argumento. Se o *charset* não for fornecido no construtor (o "
"padrão), o conjunto ``us-ascii`` é usado tanto como charset inicial de *s* "
"quanto como padrão para chamadas :meth:`append` futuras."

msgid ""
"The maximum line length can be specified explicitly via *maxlinelen*.  For "
"splitting the first line to a shorter value (to account for the field header "
"which isn't included in *s*, e.g. :mailheader:`Subject`) pass in the name of "
"the field in *header_name*.  The default *maxlinelen* is 78, and the default "
"value for *header_name* is ``None``, meaning it is not taken into account "
"for the first line of a long, split header."
msgstr ""
"O comprimento máximo da linha pode ser especificado via *maxlinelen*. Para "
"dividir a primeira linha num valor mais curto (para contabilizar o nome do "
"campo que não está incluído em *s*, ex: :mailheader:`Subject`), passe o nome "
"do campo em *header_name*. O *maxlinelen* padrão é 78, e o valor padrão para "
"*header_name* é ``None``."

msgid ""
"Optional *continuation_ws* must be :rfc:`2822`\\ -compliant folding "
"whitespace, and is usually either a space or a hard tab character.  This "
"character will be prepended to continuation lines.  *continuation_ws* "
"defaults to a single space character."
msgstr ""
"O *continuation_ws* opcional deve ser um espaço em branco de dobragem "
"(folding) compatível com a :rfc:`2822`, geralmente um espaço ou um "
"tabulador. Este carácter será prefixado às linhas de continuação. O padrão é "
"um único espaço."

msgid ""
"Optional *errors* is passed straight through to the :meth:`append` method."
msgstr ""
"O argumento opcional *errors* é passado diretamente para o método :meth:"
"`append`."

msgid "Append the string *s* to the MIME header."
msgstr "Acrescenta a string *s* ao cabeçalho MIME."

msgid ""
"Optional *charset*, if given, should be a :class:`~email.charset.Charset` "
"instance (see :mod:`email.charset`) or the name of a character set, which "
"will be converted to a :class:`~email.charset.Charset` instance.  A value of "
"``None`` (the default) means that the *charset* given in the constructor is "
"used."
msgstr ""
"O *charset* opcional, se fornecido, deve ser uma instância de :class:`~email."
"charset.Charset` (ver :mod:`email.charset`) ou o nome de um conjunto de "
"caracteres. Um valor de ``None`` significa que o *charset* dado no "
"construtor será usado."

msgid ""
"*s* may be an instance of :class:`bytes` or :class:`str`.  If it is an "
"instance of :class:`bytes`, then *charset* is the encoding of that byte "
"string, and a :exc:`UnicodeError` will be raised if the string cannot be "
"decoded with that character set."
msgstr ""
"*s* pode ser uma instância de :class:`bytes` ou :class:`str`. Se for :class:"
"`bytes`, *charset* é a codificação dessa byte string; um :exc:`UnicodeError` "
"será levantado se a string não puder ser descodificada com esse charset."

msgid ""
"If *s* is an instance of :class:`str`, then *charset* is a hint specifying "
"the character set of the characters in the string."
msgstr ""
"Se *s* for uma instância de :class:`str`, então *charset* é uma sugestão "
"(hint) especificando o conjunto de caracteres dos caracteres na string."

msgid ""
"In either case, when producing an :rfc:`2822`\\ -compliant header using :rfc:"
"`2047` rules, the string will be encoded using the output codec of the "
"charset.  If the string cannot be encoded using the output codec, a "
"UnicodeError will be raised."
msgstr ""
"Em qualquer caso, ao produzir um cabeçalho compatível com a :rfc:`2822` "
"usando as regras da :rfc:`2047`, a string será codificada usando o codec de "
"saída do charset. Se não for possível codificar, será levantado um "
"UnicodeError."

msgid ""
"Optional *errors* is passed as the errors argument to the decode call if *s* "
"is a byte string."
msgstr ""
"O argumento opcional *errors* é passado para a chamada de descodificação se "
"*s* for uma byte string."

msgid ""
"Encode a message header into an RFC-compliant format, possibly wrapping long "
"lines and encapsulating non-ASCII parts in base64 or quoted-printable "
"encodings."
msgstr ""
"Codifica um cabeçalho de mensagem num formato compatível com RFC, "
"possivelmente quebrando linhas longas e encapsulando partes não-ASCII em "
"base64 ou quoted-printable."

msgid ""
"Optional *splitchars* is a string containing characters which should be "
"given extra weight by the splitting algorithm during normal header "
"wrapping.  This is in very rough support of :RFC:`2822`\\'s 'higher level "
"syntactic breaks':  split points preceded by a splitchar are preferred "
"during line splitting, with the characters preferred in the order in which "
"they appear in the string.  Space and tab may be included in the string to "
"indicate whether preference should be given to one over the other as a split "
"point when other split chars do not appear in the line being split.  "
"Splitchars does not affect :RFC:`2047` encoded lines."
msgstr ""
"O argumento opcional *splitchars* é uma string com caracteres que devem ter "
"peso extra no algoritmo de quebra de linha. Isto serve para suportar as "
"'quebras sintáticas de alto nível' da :RFC:`2822`: pontos de divisão "
"precedidos por um *splitchar* são preferidos. Espaço e tabulação podem ser "
"incluídos para indicar preferência. Isto não afeta linhas codificadas por :"
"RFC:`2047`."

msgid ""
"*maxlinelen*, if given, overrides the instance's value for the maximum line "
"length."
msgstr ""
"*maxlinelen*, se fornecido, substitui o valor da instância para o "
"comprimento máximo da linha."

msgid ""
"*linesep* specifies the characters used to separate the lines of the folded "
"header.  It defaults to the most useful value for Python application code "
"(``\\n``), but ``\\r\\n`` can be specified in order to produce headers with "
"RFC-compliant line separators."
msgstr ""
"*linesep* especifica os caracteres usados para separar as linhas do "
"cabeçalho dobrado. O padrão é ``\\n``, mas ``\\r\\n`` pode ser usado para "
"plena conformidade com as RFCs."

msgid "Added the *linesep* argument."
msgstr "Adicionado o argumento *linesep*."

msgid ""
"The :class:`Header` class also provides a number of methods to support "
"standard operators and built-in functions."
msgstr ""
"A classe :class:`Header` também fornece vários métodos para suportar "
"operadores padrão e funções integradas."

msgid ""
"Returns an approximation of the :class:`Header` as a string, using an "
"unlimited line length.  All pieces are converted to unicode using the "
"specified encoding and joined together appropriately.  Any pieces with a "
"charset of ``'unknown-8bit'`` are decoded as ASCII using the ``'replace'`` "
"error handler."
msgstr ""
"Retorna uma aproximação do :class:`Header` como string, usando um "
"comprimento de linha ilimitado. Todas as partes são convertidas para unicode "
"e juntas. Partes com charset ``'unknown-8bit'`` são descodificadas como "
"ASCII usando o manipulador de erros ``'replace'``."

msgid "Added handling for the ``'unknown-8bit'`` charset."
msgstr "Adicionado suporte para o charset ``'unknown-8bit'``."

msgid ""
"This method allows you to compare two :class:`Header` instances for equality."
msgstr ""
"Este método permite comparar duas instâncias de :class:`Header` quanto à "
"igualdade."

msgid ""
"This method allows you to compare two :class:`Header` instances for "
"inequality."
msgstr ""
"Este método permite comparar duas instâncias de :class:`Header` quanto à "
"desigualdade."

msgid ""
"The :mod:`!email.header` module also provides the following convenient "
"functions."
msgstr ""

msgid ""
"Decode a message header value without converting the character set. The "
"header value is in *header*."
msgstr ""
"Descodifica um valor de cabeçalho sem converter o conjunto de caracteres. O "
"valor está em *header*."

msgid "For historical reasons, this function may return either:"
msgstr "Por razões históricas, esta função pode retornar ou:"

msgid ""
"A list of pairs containing each of the decoded parts of the header, "
"``(decoded_bytes, charset)``, where *decoded_bytes* is always an instance "
"of :class:`bytes`, and *charset* is either:"
msgstr ""
"Uma lista de pares contendo cada parte descodificada do cabeçalho, "
"``(decoded_bytes, charset)``, onde *decoded_bytes* é sempre :class:`bytes`, "
"e *charset* é ou:"

msgid "A lower case string containing the name of the character set specified."
msgstr ""
"Uma string em minúsculas com o nome do conjunto de caracteres especificado."

msgid "``None`` for non-encoded parts of the header."
msgstr "``None`` para partes não codificadas do cabeçalho."

msgid ""
"A list of length 1 containing a pair ``(string, None)``, where *string* is "
"always an instance of :class:`str`."
msgstr ""
"Uma lista de comprimento 1 contendo um par ``(string, None)``, onde *string* "
"é sempre uma instância de :class:`str`."

msgid ""
"An :exc:`email.errors.HeaderParseError` may be raised when certain decoding "
"errors occur (e.g. a base64 decoding exception)."
msgstr ""
"Um :exc:`email.errors.HeaderParseError` pode ser levantado se ocorrerem "
"certos erros de descodificação (ex: exceção de descodificação base64)."

msgid "Here are examples:"
msgstr "Aqui estão exemplos:"

msgid ""
"This function exists for backwards compatibility only. For new code, we "
"recommend using :class:`email.headerregistry.HeaderRegistry`."
msgstr ""
"Esta função existe apenas para compatibilidade retroativa. Para novo código, "
"recomendamos o uso de :class:`email.headerregistry.HeaderRegistry`."

msgid ""
"Create a :class:`Header` instance from a sequence of pairs as returned by :"
"func:`decode_header`."
msgstr ""
"Cria uma instância de :class:`Header` a partir de uma sequência de pares "
"como retornada por :func:`decode_header`."

msgid ""
":func:`decode_header` takes a header value string and returns a sequence of "
"pairs of the format ``(decoded_string, charset)`` where *charset* is the "
"name of the character set."
msgstr ""
":func:`decode_header` recebe uma string de cabeçalho e retorna uma sequência "
"de pares no formato ``(decoded_string, charset)``."

msgid ""
"This function takes one of those sequence of pairs and returns a :class:"
"`Header` instance.  Optional *maxlinelen*, *header_name*, and "
"*continuation_ws* are as in the :class:`Header` constructor."
msgstr ""
"Esta função recebe uma dessas sequências de pares e retorna uma instância "
"de :class:`Header`. Os argumentos opcionais são os mesmos do construtor de :"
"class:`Header`."

msgid ""
"This function exists for backwards compatibility only, and is not "
"recommended for use in new code."
msgstr ""
"Esta função existe apenas para compatibilidade retroativa e não é "
"recomendada para uso em novo código."
