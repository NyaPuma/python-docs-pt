# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-01 14:20+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!email.message`: Representing an email message"
msgstr ":mod:`!email.message`: Representar uma mensagem de email"

msgid "**Source code:** :source:`Lib/email/message.py`"
msgstr "**Código-fonte:** :source:`Lib/email/message.py`"

msgid "[1]_"
msgstr "[1]_"

msgid ""
"The central class in the :mod:`email` package is the :class:`EmailMessage` "
"class, imported from the :mod:`email.message` module.  It is the base class "
"for the :mod:`email` object model.  :class:`EmailMessage` provides the core "
"functionality for setting and querying header fields, for accessing message "
"bodies, and for creating or modifying structured messages."
msgstr ""
"A classe central no pacote :mod:`email` é a classe :class:`EmailMessage`, "
"importada do módulo :mod:`email.message`. É a classe base para o modelo de "
"objetos do :mod:`email`. A :class:`EmailMessage` fornece a funcionalidade "
"principal para definir e consultar campos de cabeçalho, para aceder aos "
"corpos das mensagens e para criar ou modificar mensagens estruturadas."

msgid ""
"An email message consists of *headers* and a *payload* (which is also "
"referred to as the *content*).  Headers are :rfc:`5322` or :rfc:`6532` style "
"field names and values, where the field name and value are separated by a "
"colon.  The colon is not part of either the field name or the field value.  "
"The payload may be a simple text message, or a binary object, or a "
"structured sequence of sub-messages each with their own set of headers and "
"their own payload.  The latter type of payload is indicated by the message "
"having a MIME type such as :mimetype:`multipart/\\*` or :mimetype:`message/"
"rfc822`."
msgstr ""
"Uma mensagem de email consiste em *cabeçalhos* (headers) e um *payload* (que "
"também é referido como o *conteúdo*). Os cabeçalhos são nomes de campos e "
"valores ao estilo :rfc:`5322` ou :rfc:`6532`, onde o nome do campo e o valor "
"são separados por um dois-pontos. O dois-pontos não faz parte nem do nome do "
"campo nem do valor do campo. O payload pode ser uma mensagem de texto "
"simples, ou um objeto binário, ou uma sequência estruturada de sub-"
"mensagens, cada uma com o seu próprio conjunto de cabeçalhos e o seu próprio "
"payload. Este último tipo de payload é indicado pelo facto de a mensagem ter "
"um tipo MIME como :mimetype:`multipart/\\*` ou :mimetype:`message/rfc822`."

msgid ""
"The conceptual model provided by an :class:`EmailMessage` object is that of "
"an ordered dictionary of headers coupled with a *payload* that represents "
"the :rfc:`5322` body of the message, which might be a list of sub-"
"``EmailMessage`` objects.  In addition to the normal dictionary methods for "
"accessing the header names and values, there are methods for accessing "
"specialized information from the headers (for example the MIME content "
"type), for operating on the payload, for generating a serialized version of "
"the message, and for recursively walking over the object tree."
msgstr ""
"O modelo conceptual fornecido por um objeto :class:`EmailMessage` é o de um "
"dicionário ordenado de cabeçalhos acoplado a um *payload* que representa o "
"corpo :rfc:`5322` da mensagem, que pode ser uma lista de sub-objetos "
"``EmailMessage``. Além dos métodos normais de dicionário para aceder aos "
"nomes e valores dos cabeçalhos, existem métodos para aceder a informações "
"especializadas dos cabeçalhos (por exemplo, o tipo de conteúdo MIME), para "
"operar no payload, para gerar uma versão serializada da mensagem e para "
"percorrer recursivamente a árvore de objetos."

msgid ""
"The :class:`EmailMessage` dictionary-like interface is indexed by the header "
"names, which must be ASCII values.  The values of the dictionary are strings "
"with some extra methods.  Headers are stored and returned in case-preserving "
"form, but field names are matched case-insensitively.  The keys are ordered, "
"but unlike a real dict, there can be duplicates.  Additional methods are "
"provided for working with headers that have duplicate keys."
msgstr ""
"A interface tipo dicionário da :class:`EmailMessage` é indexada pelos nomes "
"dos cabeçalhos, que devem ser valores ASCII. Os valores do dicionário são "
"strings com alguns métodos extra. Os cabeçalhos são armazenados e retornados "
"preservando as maiúsculas/minúsculas originais, mas a correspondência dos "
"nomes dos campos é feita de forma insensível a maiúsculas (case-"
"insensitive). As chaves são ordenadas, mas, ao contrário de um dict real, "
"podem existir duplicados. São fornecidos métodos adicionais para trabalhar "
"com cabeçalhos que possuem chaves duplicadas."

msgid ""
"The *payload* is either a string or bytes object, in the case of simple "
"message objects, or a list of :class:`EmailMessage` objects, for MIME "
"container documents such as :mimetype:`multipart/\\*` and :mimetype:`message/"
"rfc822` message objects."
msgstr ""
"O *payload* é ou um objeto string ou bytes, no caso de objetos de mensagem "
"simples, ou uma lista de objetos :class:`EmailMessage`, para documentos "
"contentores MIME, como objetos de mensagem :mimetype:`multipart/\\*` e :"
"mimetype:`message/rfc822`."

msgid ""
"If *policy* is specified use the rules it specifies to update and serialize "
"the representation of the message.  If *policy* is not set, use the :class:"
"`~email.policy.default` policy, which follows the rules of the email RFCs "
"except for line endings (instead of the RFC mandated ``\\r\\n``, it uses the "
"Python standard ``\\n`` line endings).  For more information see the :mod:"
"`~email.policy` documentation. [2]_"
msgstr ""
"Se a *policy* for especificada, utilize as regras que ela define para "
"atualizar e serializar a representação da mensagem. Se a *policy* não for "
"definida, utilize a política :class:`~email.policy.default`, que segue as "
"regras dos RFCs de email, exceto para terminações de linha (em vez do "
"``\\r\\n`` exigido pelos RFCs, utiliza as terminações de linha padrão do "
"Python ``\\n``). Para mais informações, consulte a documentação de :mod:"
"`~email.policy`. [2]_"

msgid ""
"Return the entire message flattened as a string.  When optional *unixfrom* "
"is true, the envelope header is included in the returned string.  *unixfrom* "
"defaults to ``False``.  For backward compatibility with the base :class:"
"`~email.message.Message` class *maxheaderlen* is accepted, but defaults to "
"``None``, which means that by default the line length is controlled by the :"
"attr:`~email.policy.Policy.max_line_length` of the policy.  The *policy* "
"argument may be used to override the default policy obtained from the "
"message instance.  This can be used to control some of the formatting "
"produced by the method, since the specified *policy* will be passed to the :"
"class:`~email.generator.Generator`."
msgstr ""
"Retorna a mensagem inteira achatada (flattened) como uma string. Quando o "
"parâmetro opcional *unixfrom* é verdadeiro, o cabeçalho do envelope é "
"incluído na string retornada. O valor padrão de *unixfrom* é ``False``. Para "
"compatibilidade com a classe base :class:`~email.message.Message`, o "
"parâmetro *maxheaderlen* é aceite, mas o seu valor padrão é ``None``, o que "
"significa que, por predefinição, o comprimento da linha é controlado pelo :"
"attr:`~email.policy.Policy.max_line_length` da política. O argumento "
"*policy* pode ser utilizado para sobrepor a política padrão obtida da "
"instância da mensagem. Isto pode ser usado para controlar parte da "
"formatação produzida pelo método, uma vez que a *policy* especificada será "
"passada para o :class:`~email.generator.Generator`."

msgid ""
"Flattening the message may trigger changes to the :class:`EmailMessage` if "
"defaults need to be filled in to complete the transformation to a string "
"(for example, MIME boundaries may be generated or modified)."
msgstr ""
"O achatamento da mensagem pode desencadear alterações na :class:"
"`EmailMessage` se for necessário preencher valores padrão para completar a "
"transformação para string (por exemplo, os limites (boundaries) MIME podem "
"ser gerados ou modificados)."

msgid ""
"Note that this method is provided as a convenience and may not be the most "
"useful way to serialize messages in your application, especially if you are "
"dealing with multiple messages.  See :class:`email.generator.Generator` for "
"a more flexible API for serializing messages.  Note also that this method is "
"restricted to producing messages serialized as \"7 bit clean\" when :attr:"
"`~email.policy.EmailPolicy.utf8` is ``False``, which is the default."
msgstr ""
"Note que este método é fornecido por conveniência e pode não ser a forma "
"mais útil de serializar mensagens na sua aplicação, especialmente se estiver "
"a lidar com múltiplas mensagens. Consulte :class:`email.generator.Generator` "
"para uma API mais flexível de serialização. Note também que este método está "
"restrito a produzir mensagens serializadas como \"7 bit clean\" quando :attr:"
"`~email.policy.EmailPolicy.utf8` é ``False``, que é o padrão."

msgid ""
"the default behavior when *maxheaderlen* is not specified was changed from "
"defaulting to 0 to defaulting to the value of *max_line_length* from the "
"policy."
msgstr ""
"o comportamento padrão quando *maxheaderlen* não é especificado foi alterado "
"de 0 para o valor de *max_line_length* da política."

msgid ""
"Equivalent to ``as_string(policy=self.policy.clone(utf8=True))``.  Allows "
"``str(msg)`` to produce a string containing the serialized message in a "
"readable format."
msgstr ""
"Equivalente a ``as_string(policy=self.policy.clone(utf8=True))``. Permite "
"que ``str(msg)`` produza uma string contendo a mensagem serializada num "
"formato legível."

msgid ""
"the method was changed to use ``utf8=True``, thus producing an :rfc:`6531`-"
"like message representation, instead of being a direct alias for :meth:"
"`as_string`."
msgstr ""
"o método foi alterado para usar ``utf8=True``, produzindo assim uma "
"representação de mensagem ao estilo :rfc:`6531`, em vez de ser um alias "
"direto para :meth:`as_string`."

msgid ""
"Return the entire message flattened as a bytes object.  When optional "
"*unixfrom* is true, the envelope header is included in the returned string.  "
"*unixfrom* defaults to ``False``.  The *policy* argument may be used to "
"override the default policy obtained from the message instance. This can be "
"used to control some of the formatting produced by the method, since the "
"specified *policy* will be passed to the :class:`~email.generator."
"BytesGenerator`."
msgstr ""
"Retorna a mensagem inteira achatada como um objeto bytes. Quando o parâmetro "
"opcional *unixfrom* é verdadeiro, o cabeçalho do envelope é incluído na "
"string retornada. O valor padrão de *unixfrom* é ``False``. O argumento "
"*policy* pode ser utilizado para sobrepor a política padrão obtida da "
"instância da mensagem. Isto pode ser usado para controlar parte da "
"formatação produzida pelo método, uma vez que a *policy* especificada será "
"passada para o :class:`~email.generator.BytesGenerator`."

msgid ""
"Note that this method is provided as a convenience and may not be the most "
"useful way to serialize messages in your application, especially if you are "
"dealing with multiple messages.  See :class:`email.generator.BytesGenerator` "
"for a more flexible API for serializing messages."
msgstr ""
"Note que este método é fornecido por conveniência e pode não ser a forma "
"mais útil de serializar mensagens na sua aplicação, especialmente se estiver "
"a lidar com múltiplas mensagens. Consulte :class:`email.generator."
"BytesGenerator` para uma API mais flexível de serialização."

msgid ""
"Equivalent to :meth:`.as_bytes`.  Allows ``bytes(msg)`` to produce a bytes "
"object containing the serialized message."
msgstr ""
"Equivalente a :meth:`.as_bytes`. Permite que ``bytes(msg)`` produza um "
"objeto bytes contendo a mensagem serializada."

msgid ""
"Return ``True`` if the message's payload is a list of sub-\\ :class:"
"`EmailMessage` objects, otherwise return ``False``.  When :meth:"
"`is_multipart` returns ``False``, the payload should be a string object "
"(which might be a CTE encoded binary payload).  Note that :meth:"
"`is_multipart` returning ``True`` does not necessarily mean that \"msg."
"get_content_maintype() == 'multipart'\" will return the ``True``. For "
"example, ``is_multipart`` will return ``True`` when the :class:"
"`EmailMessage` is of type ``message/rfc822``."
msgstr ""
"Retorna ``True`` se o payload da mensagem for uma lista de sub-objetos :"
"class:`EmailMessage`, caso contrário retorna ``False``. Quando :meth:"
"`is_multipart` retorna ``False``, o payload deve ser um objeto string (que "
"pode ser um payload binário codificado em CTE). Note que :meth:"
"`is_multipart` retornar ``True`` não significa necessariamente que \"msg."
"get_content_maintype() == 'multipart'\" retornará ``True``. Por exemplo, "
"``is_multipart`` retornará ``True`` quando a :class:`EmailMessage` for do "
"tipo ``message/rfc822``."

msgid ""
"Set the message's envelope header to *unixfrom*, which should be a string.  "
"(See :class:`~mailbox.mboxMessage` for a brief description of this header.)"
msgstr ""
"Define o cabeçalho do envelope da mensagem para *unixfrom*, que deve ser uma "
"string. (Consulte :class:`~mailbox.mboxMessage` para uma breve descrição "
"deste cabeçalho.)"

msgid ""
"Return the message's envelope header.  Defaults to ``None`` if the envelope "
"header was never set."
msgstr ""
"Retorna o cabeçalho do envelope da mensagem. Por padrão é ``None`` se o "
"cabeçalho do envelope nunca foi definido."

msgid ""
"The following methods implement the mapping-like interface for accessing the "
"message's headers.  Note that there are some semantic differences between "
"these methods and a normal mapping (i.e. dictionary) interface.  For "
"example, in a dictionary there are no duplicate keys, but here there may be "
"duplicate message headers.  Also, in dictionaries there is no guaranteed "
"order to the keys returned by :meth:`keys`, but in an :class:`EmailMessage` "
"object, headers are always returned in the order they appeared in the "
"original message, or in which they were added to the message later.  Any "
"header deleted and then re-added is always appended to the end of the header "
"list."
msgstr ""
"Os métodos seguintes implementam a interface tipo mapeamento para aceder aos "
"cabeçalhos da mensagem. Note que existem algumas diferenças semânticas entre "
"estes métodos e uma interface de mapeamento normal (ex: dicionário). Por "
"exemplo, num dicionário não existem chaves duplicadas, mas aqui pode haver "
"cabeçalhos de mensagem duplicados. Além disso, nos dicionários não existe "
"uma ordem garantida para as chaves retornadas por :meth:`keys`, mas num "
"objeto :class:`EmailMessage`, os cabeçalhos são sempre retornados na ordem "
"em que apareceram na mensagem original, ou na qual foram adicionados à "
"mensagem posteriormente. Qualquer cabeçalho eliminado e depois re-adicionado "
"é sempre acrescentado ao final da lista de cabeçalhos."

msgid ""
"These semantic differences are intentional and are biased toward convenience "
"in the most common use cases."
msgstr ""
"Estas diferenças semânticas são intencionais e visam a conveniência nos "
"casos de uso mais comuns."

msgid ""
"Note that in all cases, any envelope header present in the message is not "
"included in the mapping interface."
msgstr ""
"Note que, em todos os casos, qualquer cabeçalho de envelope presente na "
"mensagem não está incluído na interface de mapeamento."

msgid "Return the total number of headers, including duplicates."
msgstr "Retorna o número total de cabeçalhos, incluindo duplicados."

msgid ""
"Return ``True`` if the message object has a field named *name*. Matching is "
"done without regard to case and *name* does not include the trailing colon.  "
"Used for the ``in`` operator.  For example::"
msgstr ""
"Retorna ``True`` se o objeto de mensagem tiver um campo chamado *name*. A "
"correspondência é feita sem distinção entre maiúsculas e minúsculas e o "
"*name* não inclui o dois-pontos final. Utilizado para o operador ``in``. Por "
"exemplo::"

msgid ""
"if 'message-id' in myMessage:\n"
"   print('Message-ID:', myMessage['message-id'])"
msgstr ""
"if 'message-id' in myMessage:\n"
"   print('ID da Mensagem:', myMessage['message-id'])"

msgid ""
"Return the value of the named header field.  *name* does not include the "
"colon field separator.  If the header is missing, ``None`` is returned; a :"
"exc:`KeyError` is never raised."
msgstr ""
"Retorna o valor do campo de cabeçalho nomeado. O *name* não inclui o "
"separador dois-pontos. Se o cabeçalho estiver em falta, é retornado "
"``None``; nunca é lançado um :exc:`KeyError`."

msgid ""
"Note that if the named field appears more than once in the message's "
"headers, exactly which of those field values will be returned is undefined.  "
"Use the :meth:`get_all` method to get the values of all the extant headers "
"named *name*."
msgstr ""
"Note que se o campo nomeado aparecer mais de uma vez nos cabeçalhos da "
"mensagem, não está definido qual desses valores de campo será retornado. "
"Utilize o método :meth:`get_all` para obter os valores de todos os "
"cabeçalhos existentes chamados *name*."

msgid ""
"Using the standard (non-``compat32``) policies, the returned value is an "
"instance of a subclass of :class:`email.headerregistry.BaseHeader`."
msgstr ""
"Utilizando as políticas padrão (não-``compat32``), o valor retornado é uma "
"instância de uma subclasse de :class:`email.headerregistry.BaseHeader`."

msgid ""
"Add a header to the message with field name *name* and value *val*.  The "
"field is appended to the end of the message's existing headers."
msgstr ""
"Adiciona um cabeçalho à mensagem com o nome de campo *name* e valor *val*. O "
"campo é acrescentado ao final dos cabeçalhos existentes da mensagem."

msgid ""
"Note that this does *not* overwrite or delete any existing header with the "
"same name.  If you want to ensure that the new header is the only one "
"present in the message with field name *name*, delete the field first, e.g.::"
msgstr ""
"Note que isto *não* sobrescreve ou apaga qualquer cabeçalho existente com o "
"mesmo nome. Se quiser garantir que o novo cabeçalho é o único presente na "
"mensagem com o nome do campo *name*, apague o campo primeiro, por exemplo::"

msgid ""
"del msg['subject']\n"
"msg['subject'] = 'Python roolz!'"
msgstr ""
"del msg['assunto']\n"
"msg['assunto'] = 'Python é fixe!'"

msgid ""
"If the :mod:`policy <email.policy>` defines certain headers to be unique (as "
"the standard policies do), this method may raise a :exc:`ValueError` when an "
"attempt is made to assign a value to such a header when one already exists.  "
"This behavior is intentional for consistency's sake, but do not depend on it "
"as we may choose to make such assignments do an automatic deletion of the "
"existing header in the future."
msgstr ""
"Se a :mod:`policy <email.policy>` definir certos cabeçalhos como únicos "
"(como as políticas padrão fazem), este método pode lançar um :exc:"
"`ValueError` quando se tenta atribuir um valor a tal cabeçalho se este já "
"existir. Este comportamento é intencional por questões de consistência, mas "
"não dependa dele, pois poderemos optar por fazer com que tais atribuições "
"eliminem automaticamente o cabeçalho existente no futuro."

msgid ""
"Delete all occurrences of the field with name *name* from the message's "
"headers.  No exception is raised if the named field isn't present in the "
"headers."
msgstr ""
"Apaga todas as ocorrências do campo com o nome *name* dos cabeçalhos da "
"mensagem. Nenhuma exceção é levantada se o campo nomeado não estiver "
"presente nos cabeçalhos."

msgid "Return a list of all the message's header field names."
msgstr ""
"Retorna uma lista de todos os nomes dos campos de cabeçalho da mensagem."

msgid "Return a list of all the message's field values."
msgstr "Retorna uma lista de todos os valores dos campos da mensagem."

msgid ""
"Return a list of 2-tuples containing all the message's field headers and "
"values."
msgstr ""
"Retorna uma lista de tuplos de 2 elementos contendo todos os cabeçalhos e "
"valores dos campos da mensagem."

msgid ""
"Return the value of the named header field.  This is identical to :meth:"
"`~object.__getitem__` except that optional *failobj* is returned if the "
"named header is missing (*failobj* defaults to ``None``)."
msgstr ""
"Retorna o valor do campo de cabeçalho nomeado. Isto é idêntico a :meth:"
"`~object.__getitem__`, exceto que o parâmetro opcional *failobj* é retornado "
"se o cabeçalho estiver em falta (*failobj* tem o valor padrão ``None``)."

msgid "Here are some additional useful header related methods:"
msgstr ""
"Aqui estão alguns métodos adicionais úteis relacionados com cabeçalhos:"

msgid ""
"Return a list of all the values for the field named *name*. If there are no "
"such named headers in the message, *failobj* is returned (defaults to "
"``None``)."
msgstr ""
"Retorna uma lista de todos os valores para o campo nomeado *name*. Se não "
"houver cabeçalhos com esse nome na mensagem, *failobj* é retornado (o padrão "
"é ``None``)."

msgid ""
"Extended header setting.  This method is similar to :meth:`__setitem__` "
"except that additional header parameters can be provided as keyword "
"arguments.  *_name* is the header field to add and *_value* is the *primary* "
"value for the header."
msgstr ""
"Definição estendida de cabeçalho. Este método é semelhante a :meth:"
"`__setitem__`, exceto que parâmetros adicionais de cabeçalho podem ser "
"fornecidos como argumentos de palavra-chave. *_name* é o campo de cabeçalho "
"a adicionar e *_value* é o valor *primário* para o cabeçalho."

msgid ""
"For each item in the keyword argument dictionary *_params*, the key is taken "
"as the parameter name, with underscores converted to dashes (since dashes "
"are illegal in Python identifiers).  Normally, the parameter will be added "
"as ``key=\"value\"`` unless the value is ``None``, in which case only the "
"key will be added."
msgstr ""
"Para cada item no dicionário de argumentos de palavra-chave *_params*, a "
"chave é usada como o nome do parâmetro, com os sublinhados convertidos em "
"traços (uma vez que os traços são ilegais em identificadores Python). "
"Normalmente, o parâmetro será adicionado como ``key=\"valor\"``, a menos que "
"o valor seja ``None``, caso em que apenas a chave será adicionada."

msgid ""
"If the value contains non-ASCII characters, the charset and language may be "
"explicitly controlled by specifying the value as a three tuple in the format "
"``(CHARSET, LANGUAGE, VALUE)``, where ``CHARSET`` is a string naming the "
"charset to be used to encode the value, ``LANGUAGE`` can usually be set to "
"``None`` or the empty string (see :rfc:`2231` for other possibilities), and "
"``VALUE`` is the string value containing non-ASCII code points.  If a three "
"tuple is not passed and the value contains non-ASCII characters, it is "
"automatically encoded in :rfc:`2231` format using a ``CHARSET`` of ``utf-8`` "
"and a ``LANGUAGE`` of ``None``."
msgstr ""
"Se o valor contiver caracteres não-ASCII, o conjunto de caracteres e o "
"idioma podem ser explicitamente controlados especificando o valor como um "
"tuplo de três elementos no formato ``(CHARSET, LANGUAGE, VALUE)``, onde "
"``CHARSET`` é uma string que nomeia o charset a usar para codificar o valor, "
"``LANGUAGE`` pode ser geralmente definido como ``None`` ou uma string vazia "
"(consulte :rfc:`2231` para outras possibilidades), e ``VALUE`` é o valor da "
"string que contém caracteres não-ASCII. Se um tuplo de três elementos não "
"for passado e o valor contiver caracteres não-ASCII, este é automaticamente "
"codificado no formato :rfc:`2231` usando um ``CHARSET`` de ``utf-8`` e um "
"``LANGUAGE`` de ``None``."

msgid "Here is an example::"
msgstr "Aqui está um exemplo::"

msgid "msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')"
msgstr ""
"msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')"

msgid "This will add a header that looks like ::"
msgstr "Isto adicionará um cabeçalho com o seguinte aspeto::"

msgid "Content-Disposition: attachment; filename=\"bud.gif\""
msgstr "Content-Disposition: attachment; filename=\"bud.gif\""

msgid "An example of the extended interface with non-ASCII characters::"
msgstr "Um exemplo da interface estendida com caracteres não-ASCII::"

msgid ""
"msg.add_header('Content-Disposition', 'attachment',\n"
"               filename=('iso-8859-1', '', 'Fußballer.ppt'))"
msgstr ""
"msg.add_header('Content-Disposition', 'attachment',\n"
"               filename=('iso-8859-1', '', 'Fußballer.ppt'))"

msgid ""
"Replace a header.  Replace the first header found in the message that "
"matches *_name*, retaining header order and field name case of the original "
"header.  If no matching header is found, raise a :exc:`KeyError`."
msgstr ""
"Substitui um cabeçalho. Substitui o primeiro cabeçalho encontrado na "
"mensagem que corresponda a *_name*, preservando a ordem dos cabeçalhos e a "
"caixa do nome do campo do cabeçalho original. Se não for encontrado nenhum "
"cabeçalho correspondente, lança um :exc:`KeyError`."

msgid ""
"Return the message's content type, coerced to lower case of the form :"
"mimetype:`maintype/subtype`.  If there is no :mailheader:`Content-Type` "
"header in the message return the value returned by :meth:"
"`get_default_type`.  If the :mailheader:`Content-Type` header is invalid, "
"return ``text/plain``."
msgstr ""
"Retorna o tipo de conteúdo da mensagem, convertido para minúsculas no "
"formato :mimetype:`maintype/subtype`. Se não houver um cabeçalho :mailheader:"
"`Content-Type` na mensagem, retorna o valor retornado por :meth:"
"`get_default_type`. Se o cabeçalho :mailheader:`Content-Type` for inválido, "
"retorna ``text/plain``."

msgid ""
"(According to :rfc:`2045`, messages always have a default type, :meth:"
"`get_content_type` will always return a value.  :rfc:`2045` defines a "
"message's default type to be :mimetype:`text/plain` unless it appears inside "
"a :mimetype:`multipart/digest` container, in which case it would be :"
"mimetype:`message/rfc822`.  If the :mailheader:`Content-Type` header has an "
"invalid type specification, :rfc:`2045` mandates that the default type be :"
"mimetype:`text/plain`.)"
msgstr ""
"(De acordo com o :rfc:`2045`, as mensagens têm sempre um tipo padrão, e :"
"meth:`get_content_type` retornará sempre um valor. O :rfc:`2045` define o "
"tipo padrão de uma mensagem como :mimetype:`text/plain`, a menos que apareça "
"dentro de um contentor :mimetype:`multipart/digest`, caso em que seria :"
"mimetype:`message/rfc822`. Se o cabeçalho :mailheader:`Content-Type` tiver "
"uma especificação de tipo inválida, o :rfc:`2045` exige que o tipo padrão "
"seja :mimetype:`text/plain`.)"

msgid ""
"Return the message's main content type.  This is the :mimetype:`maintype` "
"part of the string returned by :meth:`get_content_type`."
msgstr ""
"Retorna o tipo de conteúdo principal da mensagem. Esta é a parte :mimetype:"
"`maintype` da string retornada por :meth:`get_content_type`."

msgid ""
"Return the message's sub-content type.  This is the :mimetype:`subtype` part "
"of the string returned by :meth:`get_content_type`."
msgstr ""
"Retorna o subtipo de conteúdo da mensagem. Esta é a parte :mimetype:"
"`subtype` da string retornada por :meth:`get_content_type`."

msgid ""
"Return the default content type.  Most messages have a default content type "
"of :mimetype:`text/plain`, except for messages that are subparts of :"
"mimetype:`multipart/digest` containers.  Such subparts have a default "
"content type of :mimetype:`message/rfc822`."
msgstr ""
"Retorna o tipo de conteúdo padrão. A maioria das mensagens tem um tipo de "
"conteúdo padrão de :mimetype:`text/plain`, exceto para mensagens que são "
"subpartes de contentores :mimetype:`multipart/digest`. Essas subpartes têm "
"um tipo de conteúdo padrão de :mimetype:`message/rfc822`."

msgid ""
"Set the default content type.  *ctype* should either be :mimetype:`text/"
"plain` or :mimetype:`message/rfc822`, although this is not enforced.  The "
"default content type is not stored in the :mailheader:`Content-Type` header, "
"so it only affects the return value of the ``get_content_type`` methods when "
"no :mailheader:`Content-Type` header is present in the message."
msgstr ""
"Define o tipo de conteúdo padrão. *ctype* deve ser :mimetype:`text/plain` "
"ou :mimetype:`message/rfc822`, embora isto não seja forçado. O tipo de "
"conteúdo padrão não é armazenado no cabeçalho :mailheader:`Content-Type`, "
"pelo que apenas afeta o valor de retorno dos métodos ``get_content_type`` "
"quando não existe um cabeçalho :mailheader:`Content-Type` na mensagem."

msgid ""
"Set a parameter in the :mailheader:`Content-Type` header.  If the parameter "
"already exists in the header, replace its value with *value*. When *header* "
"is ``Content-Type`` (the default) and the header does not yet exist in the "
"message, add it, set its value to :mimetype:`text/plain`, and append the new "
"parameter value.  Optional *header* specifies an alternative header to :"
"mailheader:`Content-Type`."
msgstr ""
"Define um parâmetro no cabeçalho :mailheader:`Content-Type`. Se o parâmetro "
"já existir no cabeçalho, substitui o seu valor por *valor*. Quando o "
"*header* é ``Content-Type`` (o padrão) e o cabeçalho ainda não existe na "
"mensagem, adiciona-o, define o seu valor para :mimetype:`text/plain` e anexa "
"o novo valor do parâmetro. O parâmetro opcional *header* especifica um "
"cabeçalho alternativo ao :mailheader:`Content-Type`."

msgid ""
"If the value contains non-ASCII characters, the charset and language may be "
"explicitly specified using the optional *charset* and *language* "
"parameters.  Optional *language* specifies the :rfc:`2231` language, "
"defaulting to the empty string.  Both *charset* and *language* should be "
"strings.  The default is to use the ``utf8`` *charset* and ``None`` for the "
"*language*."
msgstr ""
"Se o valor contiver caracteres não-ASCII, o charset e o idioma podem ser "
"explicitamente especificados utilizando os parâmetros opcionais *charset* e "
"*language*. O parâmetro opcional *language* especifica o idioma :rfc:`2231`, "
"com o valor padrão de uma string vazia. Tanto *charset* como *language* "
"devem ser strings. O padrão é usar o *charset* ``utf8`` e ``None`` para o "
"*language*."

msgid ""
"If *replace* is ``False`` (the default) the header is moved to the end of "
"the list of headers.  If *replace* is ``True``, the header will be updated "
"in place."
msgstr ""
"Se *replace* for ``False`` (o padrão), o cabeçalho é movido para o final da "
"lista de cabeçalhos. Se *replace* for ``True``, o cabeçalho será atualizado "
"no local."

msgid ""
"Use of the *requote* parameter with :class:`EmailMessage` objects is "
"deprecated."
msgstr ""
"O uso do parâmetro *requote* com objetos :class:`EmailMessage` é "
"descontinuado (deprecated)."

msgid ""
"Note that existing parameter values of headers may be accessed through the :"
"attr:`~email.headerregistry.ParameterizedMIMEHeader.params` attribute of the "
"header value (for example, ``msg['Content-Type'].params['charset']``)."
msgstr ""
"Note que os valores dos parâmetros existentes nos cabeçalhos podem ser "
"acedidos através do atributo :attr:`~email.headerregistry."
"ParameterizedMIMEHeader.params` do valor do cabeçalho (por exemplo, "
"``msg['Content-Type'].params['charset']``)."

msgid "``replace`` keyword was added."
msgstr "A palavra-chave ``replace`` foi adicionada."

msgid ""
"Remove the given parameter completely from the :mailheader:`Content-Type` "
"header.  The header will be re-written in place without the parameter or its "
"value.  Optional *header* specifies an alternative to :mailheader:`Content-"
"Type`."
msgstr ""
"Remove completamente o parâmetro fornecido do cabeçalho :mailheader:`Content-"
"Type`. O cabeçalho será reescrito no local sem o parâmetro ou o seu valor. O "
"parâmetro opcional *header* especifica uma alternativa ao :mailheader:"
"`Content-Type`."

msgid ""
"Return the value of the ``filename`` parameter of the :mailheader:`Content-"
"Disposition` header of the message.  If the header does not have a "
"``filename`` parameter, this method falls back to looking for the ``name`` "
"parameter on the :mailheader:`Content-Type` header.  If neither is found, or "
"the header is missing, then *failobj* is returned. The returned string will "
"always be unquoted as per :func:`email.utils.unquote`."
msgstr ""
"Retorna o valor do parâmetro ``filename`` do cabeçalho :mailheader:`Content-"
"Disposition` da mensagem. Se o cabeçalho não tiver um parâmetro "
"``filename``, este método tenta encontrar o parâmetro ``name`` no cabeçalho :"
"mailheader:`Content-Type`. Se nenhum for encontrado, ou se o cabeçalho "
"estiver em falta, então *failobj* é retornado. A string retornada será "
"sempre desaspada conforme :func:`email.utils.unquote`."

msgid ""
"Return the value of the ``boundary`` parameter of the :mailheader:`Content-"
"Type` header of the message, or *failobj* if either the header is missing, "
"or has no ``boundary`` parameter.  The returned string will always be "
"unquoted as per :func:`email.utils.unquote`."
msgstr ""
"Retorna o valor do parâmetro ``boundary`` do cabeçalho :mailheader:`Content-"
"Type` da mensagem, ou *failobj* se o cabeçalho estiver em falta ou não tiver "
"um parâmetro ``boundary``. A string retornada será sempre desaspada "
"conforme :func:`email.utils.unquote`."

msgid ""
"Set the ``boundary`` parameter of the :mailheader:`Content-Type` header to "
"*boundary*.  :meth:`set_boundary` will always quote *boundary* if "
"necessary.  A :exc:`~email.errors.HeaderParseError` is raised if the message "
"object has no :mailheader:`Content-Type` header."
msgstr ""
"Define o parâmetro ``boundary`` do cabeçalho :mailheader:`Content-Type` para "
"*boundary*. O método :meth:`set_boundary` irá sempre colocar o *boundary* "
"entre aspas, se necessário. Um :exc:`~email.errors.HeaderParseError` é "
"lançado se o objeto de mensagem não tiver um cabeçalho :mailheader:`Content-"
"Type`."

msgid ""
"Note that using this method is subtly different from deleting the old :"
"mailheader:`Content-Type` header and adding a new one with the new boundary "
"via :meth:`add_header`, because :meth:`set_boundary` preserves the order of "
"the :mailheader:`Content-Type` header in the list of headers."
msgstr ""
"Note que usar este método é subtilmente diferente de eliminar o antigo "
"cabeçalho :mailheader:`Content-Type` e adicionar um novo com o novo limite "
"através de :meth:`add_header`, porque o :meth:`set_boundary` preserva a "
"ordem do cabeçalho :mailheader:`Content-Type` na lista de cabeçalhos."

msgid ""
"Return the ``charset`` parameter of the :mailheader:`Content-Type` header, "
"coerced to lower case.  If there is no :mailheader:`Content-Type` header, or "
"if that header has no ``charset`` parameter, *failobj* is returned."
msgstr ""
"Retorna o parâmetro ``charset`` do cabeçalho :mailheader:`Content-Type`, "
"convertido para minúsculas. Se não houver cabeçalho :mailheader:`Content-"
"Type`, ou se esse cabeçalho não tiver um parâmetro ``charset``, *failobj* é "
"retornado."

msgid ""
"Return a list containing the character set names in the message.  If the "
"message is a :mimetype:`multipart`, then the list will contain one element "
"for each subpart in the payload, otherwise, it will be a list of length 1."
msgstr ""
"Retorna uma lista contendo os nomes dos conjuntos de caracteres na mensagem. "
"Se a mensagem for um :mimetype:`multipart`, então a lista conterá um "
"elemento para cada subparte no payload, caso contrário, será uma lista de "
"comprimento 1."

msgid ""
"Each item in the list will be a string which is the value of the ``charset`` "
"parameter in the :mailheader:`Content-Type` header for the represented "
"subpart.  If the subpart has no :mailheader:`Content-Type` header, no "
"``charset`` parameter, or is not of the :mimetype:`text` main MIME type, "
"then that item in the returned list will be *failobj*."
msgstr ""
"Cada item na lista será uma string com o valor do parâmetro ``charset`` no "
"cabeçalho :mailheader:`Content-Type` para a subparte representada. Se a "
"subparte não tiver um cabeçalho :mailheader:`Content-Type`, não tiver "
"parâmetro ``charset`` ou não for do tipo MIME principal :mimetype:`text`, "
"então esse item na lista retornada será *failobj*."

msgid ""
"Return ``True`` if there is a :mailheader:`Content-Disposition` header and "
"its (case insensitive) value is ``attachment``, ``False`` otherwise."
msgstr ""
"Retorna ``True`` se existir um cabeçalho :mailheader:`Content-Disposition` e "
"o seu valor (insensível a maiúsculas) for ``attachment``, caso contrário "
"retorna ``False``."

msgid ""
"is_attachment is now a method instead of a property, for consistency with :"
"meth:`~email.message.Message.is_multipart`."
msgstr ""
"is_attachment é agora um método em vez de uma propriedade, para consistência "
"com :meth:`~email.message.Message.is_multipart`."

msgid ""
"Return the lowercased value (without parameters) of the message's :"
"mailheader:`Content-Disposition` header if it has one, or ``None``.  The "
"possible values for this method are *inline*, *attachment* or ``None`` if "
"the message follows :rfc:`2183`."
msgstr ""
"Retorna o valor em minúsculas (sem parâmetros) do cabeçalho :mailheader:"
"`Content-Disposition` da mensagem, se tiver um, ou ``None``. Os valores "
"possíveis para este método são *inline*, *attachment* ou ``None`` se a "
"mensagem seguir o :rfc:`2183`."

msgid ""
"The following methods relate to interrogating and manipulating the content "
"(payload) of the message."
msgstr ""
"Os métodos seguintes relacionam-se com a interrogação e manipulação do "
"conteúdo (payload) da mensagem."

msgid ""
"The :meth:`walk` method is an all-purpose generator which can be used to "
"iterate over all the parts and subparts of a message object tree, in depth-"
"first traversal order.  You will typically use :meth:`walk` as the iterator "
"in a ``for`` loop; each iteration returns the next subpart."
msgstr ""
"O método :meth:`walk` é um gerador de uso geral que pode ser usado para "
"iterar sobre todas as partes e subpartes de uma árvore de objetos de "
"mensagem, em ordem de travessia em profundidade (depth-first). Tipicamente, "
"usará o :meth:`walk` como o iterador num ciclo ``for``; cada iteração "
"retorna a subparte seguinte."

msgid ""
"Here's an example that prints the MIME type of every part of a multipart "
"message structure:"
msgstr ""
"Eis um exemplo que imprime o tipo MIME de cada parte de uma estrutura de "
"mensagem multiparte:"

msgid ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_type())\n"
"multipart/report\n"
"text/plain\n"
"message/delivery-status\n"
"text/plain\n"
"text/plain\n"
"message/rfc822\n"
"text/plain"
msgstr ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_type())\n"
"multipart/report\n"
"text/plain\n"
"message/delivery-status\n"
"text/plain\n"
"text/plain\n"
"message/rfc822\n"
"text/plain"

msgid ""
"``walk`` iterates over the subparts of any part where :meth:`is_multipart` "
"returns ``True``, even though ``msg.get_content_maintype() == 'multipart'`` "
"may return ``False``.  We can see this in our example by making use of the "
"``_structure`` debug helper function:"
msgstr ""
"O ``walk`` itera sobre as subpartes de qualquer parte onde :meth:"
"`is_multipart` retorne ``True``, mesmo que ``msg.get_content_maintype() == "
"'multipart'`` possa retornar ``False``. Podemos ver isto no nosso exemplo "
"utilizando a função auxiliar de depuração ``_structure``:"

msgid ""
">>> from email.iterators import _structure\n"
">>> for part in msg.walk():\n"
"...     print(part.get_content_maintype() == 'multipart',\n"
"...           part.is_multipart())\n"
"True True\n"
"False False\n"
"False True\n"
"False False\n"
"False False\n"
"False True\n"
"False False\n"
">>> _structure(msg)\n"
"multipart/report\n"
"    text/plain\n"
"    message/delivery-status\n"
"        text/plain\n"
"        text/plain\n"
"    message/rfc822\n"
"        text/plain"
msgstr ""
">>> from email.iterators import _structure\n"
">>> for part in msg.walk():\n"
"...     print(part.get_content_maintype() == 'multipart',\n"
"...           part.is_multipart())\n"
"True True\n"
"False False\n"
"False True\n"
"False False\n"
"False False\n"
"False True\n"
"False False\n"
">>> _structure(msg)\n"
"multipart/report\n"
"    text/plain\n"
"    message/delivery-status\n"
"        text/plain\n"
"        text/plain\n"
"    message/rfc822\n"
"        text/plain"

msgid ""
"Here the ``message`` parts are not ``multiparts``, but they do contain "
"subparts. ``is_multipart()`` returns ``True`` and ``walk`` descends into the "
"subparts."
msgstr ""
"Aqui, as partes ``message`` não são ``multiparts``, mas contêm subpartes. O "
"método ``is_multipart()`` retorna ``True`` e o ``walk`` desce para as "
"subpartes."

msgid ""
"Return the MIME part that is the best candidate to be the \"body\" of the "
"message."
msgstr ""
"Retorna a parte MIME que é a melhor candidata a ser o \"corpo\" (body) da "
"mensagem."

msgid ""
"*preferencelist* must be a sequence of strings from the set ``related``, "
"``html``, and ``plain``, and indicates the order of preference for the "
"content type of the part returned."
msgstr ""
"*preferencelist* deve ser uma sequência de strings do conjunto ``related``, "
"``html``, e ``plain``, e indica a ordem de preferência para o tipo de "
"conteúdo da parte retornada."

msgid ""
"Start looking for candidate matches with the object on which the "
"``get_body`` method is called."
msgstr ""
"Começa a procurar correspondências candidatas com o objeto sobre o qual o "
"método ``get_body`` é chamado."

msgid ""
"If ``related`` is not included in *preferencelist*, consider the root part "
"(or subpart of the root part) of any related encountered as a candidate if "
"the (sub-)part matches a preference."
msgstr ""
"Se ``related`` não for incluído na *preferencelist*, considera a parte raiz "
"(ou subparte da parte raiz) de qualquer elemento relacionado encontrado como "
"candidata se a (sub-)parte corresponder a uma preferência."

msgid ""
"When encountering a ``multipart/related``, check the ``start`` parameter and "
"if a part with a matching :mailheader:`Content-ID` is found, consider only "
"it when looking for candidate matches.  Otherwise consider only the first "
"(default root) part of the ``multipart/related``."
msgstr ""
"Ao encontrar um ``multipart/related``, verifica o parâmetro ``start`` e, se "
"for encontrada uma parte com um :mailheader:`Content-ID` correspondente, "
"considera apenas essa parte ao procurar correspondências candidatas. Caso "
"contrário, considera apenas a primeira parte (raiz padrão) do ``multipart/"
"related``."

msgid ""
"If a part has a :mailheader:`Content-Disposition` header, only consider the "
"part a candidate match if the value of the header is ``inline``."
msgstr ""
"Se uma parte tiver um cabeçalho :mailheader:`Content-Disposition`, apenas "
"considera a parte como uma correspondência candidata se o valor do cabeçalho "
"for ``inline``."

msgid ""
"If none of the candidates matches any of the preferences in "
"*preferencelist*, return ``None``."
msgstr ""
"Se nenhum dos candidatos corresponder a qualquer das preferências na "
"*preferencelist*, retorna ``None``."

msgid ""
"Notes: (1) For most applications the only *preferencelist* combinations that "
"really make sense are ``('plain',)``, ``('html', 'plain')``, and the default "
"``('related', 'html', 'plain')``.  (2) Because matching starts with the "
"object on which ``get_body`` is called, calling ``get_body`` on a "
"``multipart/related`` will return the object itself unless *preferencelist* "
"has a non-default value. (3) Messages (or message parts) that do not specify "
"a :mailheader:`Content-Type` or whose :mailheader:`Content-Type` header is "
"invalid will be treated as if they are of type ``text/plain``, which may "
"occasionally cause ``get_body`` to return unexpected results."
msgstr ""

msgid ""
"Return an iterator over all of the immediate sub-parts of the message that "
"are not candidate \"body\" parts.  That is, skip the first occurrence of "
"each of ``text/plain``, ``text/html``, ``multipart/related``, or ``multipart/"
"alternative`` (unless they are explicitly marked as attachments via :"
"mailheader:`Content-Disposition: attachment`), and return all remaining "
"parts.  When applied directly to a ``multipart/related``, return an iterator "
"over the all the related parts except the root part (ie: the part pointed to "
"by the ``start`` parameter, or the first part if there is no ``start`` "
"parameter or the ``start`` parameter doesn't match the :mailheader:`Content-"
"ID` of any of the parts).  When applied directly to a ``multipart/"
"alternative`` or a non-``multipart``, return an empty iterator."
msgstr ""

msgid ""
"Return an iterator over all of the immediate sub-parts of the message, which "
"will be empty for a non-``multipart``.  (See also :meth:`~email.message."
"EmailMessage.walk`.)"
msgstr ""

msgid ""
"Call the :meth:`~email.contentmanager.ContentManager.get_content` method of "
"the *content_manager*, passing self as the message object, and passing along "
"any other arguments or keywords as additional arguments.  If "
"*content_manager* is not specified, use the ``content_manager`` specified by "
"the current :mod:`~email.policy`."
msgstr ""

msgid ""
"Call the :meth:`~email.contentmanager.ContentManager.set_content` method of "
"the *content_manager*, passing self as the message object, and passing along "
"any other arguments or keywords as additional arguments.  If "
"*content_manager* is not specified, use the ``content_manager`` specified by "
"the current :mod:`~email.policy`."
msgstr ""

msgid ""
"Convert a non-``multipart`` message into a ``multipart/related`` message, "
"moving any existing :mailheader:`Content-` headers and payload into a (new) "
"first part of the ``multipart``.  If *boundary* is specified, use it as the "
"boundary string in the multipart, otherwise leave the boundary to be "
"automatically created when it is needed (for example, when the message is "
"serialized)."
msgstr ""

msgid ""
"Convert a non-``multipart`` or a ``multipart/related`` into a ``multipart/"
"alternative``, moving any existing :mailheader:`Content-` headers and "
"payload into a (new) first part of the ``multipart``.  If *boundary* is "
"specified, use it as the boundary string in the multipart, otherwise leave "
"the boundary to be automatically created when it is needed (for example, "
"when the message is serialized)."
msgstr ""

msgid ""
"Convert a non-``multipart``, a ``multipart/related``, or a ``multipart-"
"alternative`` into a ``multipart/mixed``, moving any existing :mailheader:"
"`Content-` headers and payload into a (new) first part of the "
"``multipart``.  If *boundary* is specified, use it as the boundary string in "
"the multipart, otherwise leave the boundary to be automatically created when "
"it is needed (for example, when the message is serialized)."
msgstr ""

msgid ""
"If the message is a ``multipart/related``, create a new message object, pass "
"all of the arguments to its :meth:`set_content` method, and :meth:`~email."
"message.Message.attach` it to the ``multipart``.  If the message is a non-"
"``multipart``, call :meth:`make_related` and then proceed as above.  If the "
"message is any other type of ``multipart``, raise a :exc:`TypeError`. If "
"*content_manager* is not specified, use the ``content_manager`` specified by "
"the current :mod:`~email.policy`. If the added part has no :mailheader:"
"`Content-Disposition` header, add one with the value ``inline``."
msgstr ""

msgid ""
"If the message is a ``multipart/alternative``, create a new message object, "
"pass all of the arguments to its :meth:`set_content` method, and :meth:"
"`~email.message.Message.attach` it to the ``multipart``.  If the message is "
"a non-``multipart`` or ``multipart/related``, call :meth:`make_alternative` "
"and then proceed as above.  If the message is any other type of "
"``multipart``, raise a :exc:`TypeError`. If *content_manager* is not "
"specified, use the ``content_manager`` specified by the current :mod:`~email."
"policy`."
msgstr ""

msgid ""
"If the message is a ``multipart/mixed``, create a new message object, pass "
"all of the arguments to its :meth:`set_content` method, and :meth:`~email."
"message.Message.attach` it to the ``multipart``.  If the message is a non-"
"``multipart``, ``multipart/related``, or ``multipart/alternative``, call :"
"meth:`make_mixed` and then proceed as above. If *content_manager* is not "
"specified, use the ``content_manager`` specified by the current :mod:`~email."
"policy`.  If the added part has no :mailheader:`Content-Disposition` header, "
"add one with the value ``attachment``.  This method can be used both for "
"explicit attachments (:mailheader:`Content-Disposition: attachment`) and "
"``inline`` attachments (:mailheader:`Content-Disposition: inline`), by "
"passing appropriate options to the ``content_manager``."
msgstr ""

msgid "Remove the payload and all of the headers."
msgstr ""

msgid ""
"Remove the payload and all of the :mailheader:`!Content-` headers, leaving "
"all other headers intact and in their original order."
msgstr ""

msgid ":class:`EmailMessage` objects have the following instance attributes:"
msgstr ""

msgid ""
"The format of a MIME document allows for some text between the blank line "
"following the headers, and the first multipart boundary string. Normally, "
"this text is never visible in a MIME-aware mail reader because it falls "
"outside the standard MIME armor.  However, when viewing the raw text of the "
"message, or when viewing the message in a non-MIME aware reader, this text "
"can become visible."
msgstr ""
"O formato de um documento MIME permite algum texto entre a linha em branco "
"após os cabeçalhos e a primeira string de limite multiparte. Normalmente, "
"este texto nunca é visível num leitor de correio com consciência MIME porque "
"cai fora da blindagem MIME padrão. No entanto, ao visualizar o texto bruto "
"da mensagem ou ao visualizar a mensagem num leitor sem consciência MIME, "
"este texto pode tornar-se visível."

msgid ""
"The *preamble* attribute contains this leading extra-armor text for MIME "
"documents.  When the :class:`~email.parser.Parser` discovers some text after "
"the headers but before the first boundary string, it assigns this text to "
"the message's *preamble* attribute.  When the :class:`~email.generator."
"Generator` is writing out the plain text representation of a MIME message, "
"and it finds the message has a *preamble* attribute, it will write this text "
"in the area between the headers and the first boundary.  See :mod:`email."
"parser` and :mod:`email.generator` for details."
msgstr ""
"O atributo *preamble* contém este texto extra-armadura inicial para "
"documentos MIME. Quando o :class:`~email.parser.Parser` descobre algum texto "
"após os cabeçalhos, mas antes da primeira string de limite, atribui este "
"texto ao atributo *preamble* da mensagem. Quando o :class:`~email.generator."
"Generator` está a escrever a representação de texto simples de uma mensagem "
"MIME e encontra que a mensagem tem um atributo *preamble*, escreverá este "
"texto na área entre os cabeçalhos e o primeiro limite. Consulte :mod:`email."
"parser` e :mod:`email.generator` para mais detalhes."

msgid ""
"Note that if the message object has no preamble, the *preamble* attribute "
"will be ``None``."
msgstr ""
"Note que se o objeto mensagem não tiver preâmbulo, o atributo *preamble* "
"será ``None``."

msgid ""
"The *epilogue* attribute acts the same way as the *preamble* attribute, "
"except that it contains text that appears between the last boundary and the "
"end of the message.  As with the :attr:`~EmailMessage.preamble`, if there is "
"no epilog text this attribute will be ``None``."
msgstr ""

msgid ""
"The *defects* attribute contains a list of all the problems found when "
"parsing this message.  See :mod:`email.errors` for a detailed description of "
"the possible parsing defects."
msgstr ""
"O atributo *defects* contém uma lista de todos os problemas encontrados ao "
"analisar esta mensagem. Consulte :mod:`email.errors` para uma descrição "
"detalhada dos possíveis defeitos de análise."

msgid ""
"This class represents a subpart of a MIME message.  It is identical to :"
"class:`EmailMessage`, except that no :mailheader:`MIME-Version` headers are "
"added when :meth:`~EmailMessage.set_content` is called, since sub-parts do "
"not need their own :mailheader:`MIME-Version` headers."
msgstr ""

msgid "Footnotes"
msgstr "Notas de rodapé"

msgid ""
"Originally added in 3.4 as a :term:`provisional module <provisional "
"package>`.  Docs for legacy message class moved to :ref:`compat32_message`."
msgstr ""

msgid ""
"The :class:`EmailMessage` class requires a policy that provides a "
"``content_manager`` attribute for content management methods like "
"``set_content()`` and ``get_content()`` to work. The legacy :const:`~email."
"policy.compat32` policy does not support these methods and should not be "
"used with :class:`EmailMessage`."
msgstr ""
