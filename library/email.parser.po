# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-05 14:39+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!email.parser`: Parsing email messages"
msgstr ":mod:`!email.parser`: Processamento (*parsing*) de mensagens de email"

msgid "**Source code:** :source:`Lib/email/parser.py`"
msgstr "**Código fonte:** :source:`Lib/email/parser.py`"

msgid ""
"Message object structures can be created in one of two ways: they can be "
"created from whole cloth by creating an :class:`~email.message.EmailMessage` "
"object, adding headers using the dictionary interface, and adding payload(s) "
"using :meth:`~email.message.EmailMessage.set_content` and related methods, "
"or they can be created by parsing a serialized representation of the email "
"message."
msgstr ""
"As estruturas de objetos de mensagem podem ser criadas de duas formas: do "
"zero, criando um objeto :class:`~email.message.EmailMessage`, adicionando "
"cabeçalhos através da interface de dicionário e payloads usando :meth:"
"`~email.message.EmailMessage.set_content` e métodos relacionados; ou através "
"do processamento (*parsing*) de uma representação serializada da mensagem de "
"email."

msgid ""
"The :mod:`email` package provides a standard parser that understands most "
"email document structures, including MIME documents.  You can pass the "
"parser a bytes, string or file object, and the parser will return to you the "
"root :class:`~email.message.EmailMessage` instance of the object structure.  "
"For simple, non-MIME messages the payload of this root object will likely be "
"a string containing the text of the message.  For MIME messages, the root "
"object will return ``True`` from its :meth:`~email.message.EmailMessage."
"is_multipart` method, and the subparts can be accessed via the payload "
"manipulation methods, such as :meth:`~email.message.EmailMessage.get_body`, :"
"meth:`~email.message.EmailMessage.iter_parts`, and :meth:`~email.message."
"EmailMessage.walk`."
msgstr ""
"O pacote :mod:`email` fornece um analisador (*parser*) padrão que compreende "
"a maioria das estruturas de documentos de email, incluindo documentos MIME. "
"Pode passar ao analisador um objeto de bytes, string ou ficheiro, e ele "
"retornará a instância raiz :class:`~email.message.EmailMessage` da "
"estrutura. Para mensagens simples não-MIME, o payload deste objeto raiz será "
"provavelmente uma string com o texto da mensagem. Para mensagens MIME, o "
"objeto raiz retornará ``True`` no seu método :meth:`~email.message."
"EmailMessage.is_multipart`, e as subpartes podem ser acedidas via métodos de "
"manipulação de payload, como :meth:`~email.message.EmailMessage.get_body`, :"
"meth:`~email.message.EmailMessage.iter_parts` e :meth:`~email.message."
"EmailMessage.walk`."

msgid ""
"There are actually two parser interfaces available for use, the :class:"
"`Parser` API and the incremental :class:`FeedParser` API.  The :class:"
"`Parser` API is most useful if you have the entire text of the message in "
"memory, or if the entire message lives in a file on the file system.  :class:"
"`FeedParser` is more appropriate when you are reading the message from a "
"stream which might block waiting for more input (such as reading an email "
"message from a socket).  The :class:`FeedParser` can consume and parse the "
"message incrementally, and only returns the root object when you close the "
"parser."
msgstr ""
"Existem duas interfaces de análise disponíveis: a API :class:`Parser` e a "
"API incremental :class:`FeedParser`. A API :class:`Parser` é mais útil se "
"tiver o texto completo da mensagem em memória ou num ficheiro no sistema. A :"
"class:`FeedParser` é mais adequada para ler mensagens de um fluxo (*stream*) "
"que pode bloquear à espera de dados (como ler de um socket). A :class:"
"`FeedParser` consome e processa a mensagem incrementalmente, retornando o "
"objeto raiz apenas quando fecha o analisador."

msgid ""
"Note that the parser can be extended in limited ways, and of course you can "
"implement your own parser completely from scratch.  All of the logic that "
"connects the :mod:`email` package's bundled parser and the :class:`~email."
"message.EmailMessage` class is embodied in the :class:`~email.policy.Policy` "
"class, so a custom parser can create message object trees any way it finds "
"necessary by implementing custom versions of the appropriate :class:`!"
"Policy` methods."
msgstr ""
"Nota que o analisador pode ser estendido de formas limitadas e, claro, podes "
"implementar o teu próprio analisador totalmente do zero. Toda a lógica que "
"liga o analisador incluído no pacote :mod:`email` e a classe :class:`~email."
"message.EmailMessage` está incorporada na classe :class:`~email.policy."
"Policy`, pelo que um analisador personalizado pode criar árvores de objetos "
"de mensagem da forma que considerar necessária, implementando versões "
"personalizadas dos métodos :class:`!Policy` apropriados."

msgid "FeedParser API"
msgstr "API FeedParser"

msgid ""
"The :class:`BytesFeedParser`, imported from the :mod:`email.feedparser` "
"module, provides an API that is conducive to incremental parsing of email "
"messages, such as would be necessary when reading the text of an email "
"message from a source that can block (such as a socket).  The :class:"
"`BytesFeedParser` can of course be used to parse an email message fully "
"contained in a :term:`bytes-like object`, string, or file, but the :class:"
"`BytesParser` API may be more convenient for such use cases.  The semantics "
"and results of the two parser APIs are identical."
msgstr ""
"A :class:`BytesFeedParser`, importada do módulo :mod:`email.feedparser`, "
"fornece uma API propícia à análise incremental de mensagens de email, tal "
"como seria necessário ao ler o texto de uma mensagem de uma fonte que pode "
"bloquear (como um *socket*). A :class:`BytesFeedParser` pode, naturalmente, "
"ser utilizada para analisar uma mensagem totalmente contida num :term:`bytes-"
"like object`, string ou ficheiro, mas a API :class:`BytesParser` pode ser "
"mais conveniente para tais casos de uso. A semântica e os resultados das "
"duas APIs de análise são idênticos."

msgid ""
"The :class:`BytesFeedParser`'s API is simple; you create an instance, feed "
"it a bunch of bytes until there's no more to feed it, then close the parser "
"to retrieve the root message object.  The :class:`BytesFeedParser` is "
"extremely accurate when parsing standards-compliant messages, and it does a "
"very good job of parsing non-compliant messages, providing information about "
"how a message was deemed broken.  It will populate a message object's :attr:"
"`~email.message.EmailMessage.defects` attribute with a list of any problems "
"it found in a message.  See the :mod:`email.errors` module for the list of "
"defects that it can find."
msgstr ""
"A API da :class:`BytesFeedParser` é simples; cria uma instância, fornece-lhe "
"um conjunto de bytes até não haver mais para fornecer e, em seguida, fecha o "
"analisador para obter o objeto de mensagem raiz. A :class:`BytesFeedParser` "
"é extremamente precisa ao analisar mensagens que cumprem as normas e faz um "
"excelente trabalho ao analisar mensagens não conformes, fornecendo "
"informações sobre o motivo pelo qual uma mensagem foi considerada "
"corrompida. Irá preencher o atributo :attr:`~email.message.EmailMessage."
"defects` do objeto de mensagem com uma lista de quaisquer problemas "
"encontrados. Consulte o módulo :mod:`email.errors` para a lista de defeitos "
"que pode detetar."

msgid "Here is the API for the :class:`BytesFeedParser`:"
msgstr "Aqui está a API para a :class:`BytesFeedParser`:"

msgid ""
"Create a :class:`BytesFeedParser` instance.  Optional *_factory* is a no-"
"argument callable; if not specified use the :attr:`~email.policy.Policy."
"message_factory` from the *policy*.  Call *_factory* whenever a new message "
"object is needed."
msgstr ""
"Cria uma instância de :class:`BytesFeedParser`. O argumento opcional "
"*_factory* é um chamável (callable) sem argumentos; se não for especificado, "
"utiliza o :attr:`~email.policy.Policy.message_factory` da *policy*. Chama "
"*_factory* sempre que um novo objeto de mensagem for necessário."

msgid ""
"If *policy* is specified use the rules it specifies to update the "
"representation of the message.  If *policy* is not set, use the :class:"
"`compat32 <email.policy.Compat32>` policy, which maintains backward "
"compatibility with the Python 3.2 version of the email package and provides :"
"class:`~email.message.Message` as the default factory.  All other policies "
"provide :class:`~email.message.EmailMessage` as the default *_factory*. For "
"more information on what else *policy* controls, see the :mod:`~email."
"policy` documentation."
msgstr ""
"Se *policy* for especificada, utiliza as regras nela definidas para "
"atualizar a representação da mensagem. Se *policy* não for definida, utiliza "
"a política :class:`compat32 <email.policy.Compat32>`, que mantém a "
"retrocompatibilidade com a versão do pacote email do Python 3.2 e fornece :"
"class:`~email.message.Message` como a fábrica padrão. Todas as outras "
"políticas fornecem :class:`~email.message.EmailMessage` como a *_factory* "
"padrão. Para mais informações sobre o que mais a *policy* controla, consulte "
"a documentação de :mod:`~email.policy`."

msgid ""
"Note: **The policy keyword should always be specified**; The default will "
"change to :data:`email.policy.default` in a future version of Python."
msgstr ""
"Nota: **A palavra-chave policy deve ser sempre especificada**; o valor "
"padrão mudará para :data:`email.policy.default` numa versão futura do Python."

msgid "Added the *policy* keyword."
msgstr "Adicionada a palavra-chave *policy*."

msgid "*_factory* defaults to the policy ``message_factory``."
msgstr "*_factory* tem como valor padrão a ``message_factory`` da política."

msgid ""
"Feed the parser some more data.  *data* should be a :term:`bytes-like "
"object` containing one or more lines.  The lines can be partial and the "
"parser will stitch such partial lines together properly.  The lines can have "
"any of the three common line endings: carriage return, newline, or carriage "
"return and newline (they can even be mixed)."
msgstr ""
"Fornece mais dados ao analisador. *data* deve ser um :term:`bytes-like "
"object` contendo uma ou mais linhas. As linhas podem ser parciais e o "
"analisador irá unir essas linhas parciais corretamente. As linhas podem ter "
"qualquer uma das três terminações de linha comuns: retorno de carro (CR), "
"nova linha (LF) ou retorno de carro e nova linha (CRLF) (podem até ser "
"misturadas)."

msgid ""
"Complete the parsing of all previously fed data and return the root message "
"object.  It is undefined what happens if :meth:`~feed` is called after this "
"method has been called."
msgstr ""
"Conclui o processamento de todos os dados fornecidos anteriormente e retorna "
"o objeto de mensagem raiz. O comportamento é indefinido se o método :meth:"
"`~feed` for chamado após a execução deste método."

msgid ""
"Works like :class:`BytesFeedParser` except that the input to the :meth:"
"`~BytesFeedParser.feed` method must be a string.  This is of limited "
"utility, since the only way for such a message to be valid is for it to "
"contain only ASCII text or, if :attr:`~email.policy.EmailPolicy.utf8` is "
"``True``, no binary attachments."
msgstr ""
"Funciona como a :class:`BytesFeedParser`, exceto que a entrada para o "
"método :meth:`~BytesFeedParser.feed` deve ser uma string. Isto é de "
"utilidade limitada, uma vez que a única forma de tal mensagem ser válida é "
"conter apenas texto ASCII ou, se :attr:`~email.policy.EmailPolicy.utf8` for "
"``True``, não possuir anexos binários."

msgid "Parser API"
msgstr "API Parser"

msgid ""
"The :class:`BytesParser` class, imported from the :mod:`email.parser` "
"module, provides an API that can be used to parse a message when the "
"complete contents of the message are available in a :term:`bytes-like "
"object` or file.  The :mod:`email.parser` module also provides :class:"
"`Parser` for parsing strings, and header-only parsers, :class:"
"`BytesHeaderParser` and :class:`HeaderParser`, which can be used if you're "
"only interested in the headers of the message.  :class:`BytesHeaderParser` "
"and :class:`HeaderParser` can be much faster in these situations, since they "
"do not attempt to parse the message body, instead setting the payload to the "
"raw body."
msgstr ""
"A classe :class:`BytesParser`, importada do módulo :mod:`email.parser`, "
"fornece uma API que pode ser usada para analisar uma mensagem quando o "
"conteúdo completo da mesma está disponível num :term:`bytes-like object` ou "
"ficheiro. O módulo :mod:`email.parser` também fornece :class:`Parser` para "
"analisar strings, e analisadores apenas de cabeçalhos, :class:"
"`BytesHeaderParser` e :class:`HeaderParser`, que podem ser usados se estiver "
"apenas interessado nos cabeçalhos da mensagem. A :class:`BytesHeaderParser` "
"e a :class:`HeaderParser` podem ser muito mais rápidas nestas situações, uma "
"vez que não tentam analisar o corpo da mensagem, definindo o payload como o "
"corpo bruto (*raw body*)."

msgid ""
"Create a :class:`BytesParser` instance.  The *_class* and *policy* arguments "
"have the same meaning and semantics as the *_factory* and *policy* arguments "
"of :class:`BytesFeedParser`."
msgstr ""
"Cria uma instância de :class:`BytesParser`. Os argumentos *_class* e "
"*policy* têm o mesmo significado e semântica que os argumentos *_factory* e "
"*policy* da :class:`BytesFeedParser`."

msgid ""
"Removed the *strict* argument that was deprecated in 2.4.  Added the "
"*policy* keyword."
msgstr ""
"Removido o argumento *strict* que foi descontinuado na versão 2.4. "
"Adicionada a palavra-chave *policy*."

msgid "*_class* defaults to the policy ``message_factory``."
msgstr "*_class* tem como valor padrão a ``message_factory`` da política."

msgid ""
"Read all the data from the binary file-like object *fp*, parse the resulting "
"bytes, and return the message object.  *fp* must support both the :meth:`~io."
"IOBase.readline` and the :meth:`~io.IOBase.read` methods."
msgstr ""
"Lê todos os dados do objeto binário tipo ficheiro *fp*, analisa os bytes "
"resultantes e retorna o objeto de mensagem. *fp* deve suportar tanto o "
"método :meth:`~io.IOBase.readline` como o método :meth:`~io.IOBase.read`."

msgid ""
"The bytes contained in *fp* must be formatted as a block of :rfc:`5322` (or, "
"if :attr:`~email.policy.EmailPolicy.utf8` is ``True``, :rfc:`6532`) style "
"headers and header continuation lines, optionally preceded by an envelope "
"header.  The header block is terminated either by the end of the data or by "
"a blank line.  Following the header block is the body of the message (which "
"may contain MIME-encoded subparts, including subparts with a :mailheader:"
"`Content-Transfer-Encoding` of ``8bit``)."
msgstr ""
"Os bytes contidos em *fp* devem estar formatados como um bloco de cabeçalhos "
"ao estilo :rfc:`5322` (ou :rfc:`6532`, se :attr:`~email.policy.EmailPolicy."
"utf8` for ``True``) e linhas de continuação, opcionalmente precedidos por um "
"cabeçalho de envelope. O bloco de cabeçalho é terminado ou pelo fim dos "
"dados ou por uma linha em branco. Após o bloco de cabeçalho encontra-se o "
"corpo da mensagem (que pode conter subpartes codificadas em MIME, incluindo "
"subpartes com um :mailheader:`Content-Transfer-Encoding` de ``8bit``)."

msgid ""
"Optional *headersonly* is a flag specifying whether to stop parsing after "
"reading the headers or not.  The default is ``False``, meaning it parses the "
"entire contents of the file."
msgstr ""
"O argumento opcional *headersonly* é uma flag que especifica se deve ou não "
"parar a análise após a leitura dos cabeçalhos. O valor padrão é ``False``, o "
"que significa que analisa todo o conteúdo do ficheiro."

msgid ""
"Similar to the :meth:`parse` method, except it takes a :term:`bytes-like "
"object` instead of a file-like object.  Calling this method on a :term:"
"`bytes-like object` is equivalent to wrapping *bytes* in a :class:`~io."
"BytesIO` instance first and calling :meth:`parse`."
msgstr ""
"Semelhante ao método :meth:`parse`, exceto que recebe um :term:`bytes-like "
"object` em vez de um objeto tipo ficheiro. Chamar este método num :term:"
"`bytes-like object` é equivalente a envolver primeiro os *bytes* numa "
"instância de :class:`~io.BytesIO` e chamar o :meth:`parse`."

msgid "Optional *headersonly* is as with the :meth:`parse` method."
msgstr ""
"O argumento opcional *headersonly* funciona como no método :meth:`parse`."

msgid ""
"Exactly like :class:`BytesParser`, except that *headersonly* defaults to "
"``True``."
msgstr ""
"Exatamente como :class:`BytesParser`, exceto que *headersonly* tem como "
"valor padrão ``True``."

msgid ""
"This class is parallel to :class:`BytesParser`, but handles string input."
msgstr ""
"Esta classe é paralela à :class:`BytesParser`, mas lida com entrada de "
"strings."

msgid "Removed the *strict* argument.  Added the *policy* keyword."
msgstr "Removido o argumento *strict*. Adicionada a palavra-chave *policy*."

msgid ""
"Read all the data from the text-mode file-like object *fp*, parse the "
"resulting text, and return the root message object.  *fp* must support both "
"the :meth:`~io.TextIOBase.readline` and the :meth:`~io.TextIOBase.read` "
"methods on file-like objects."
msgstr ""
"Lê todos os dados do objeto tipo ficheiro em modo texto *fp*, analisa o "
"texto resultante e retorna o objeto de mensagem raiz. *fp* deve suportar os "
"métodos :meth:`~io.TextIOBase.readline` e :meth:`~io.TextIOBase.read` em "
"objetos tipo ficheiro."

msgid ""
"Other than the text mode requirement, this method operates like :meth:"
"`BytesParser.parse`."
msgstr ""
"À exceção do requisito de modo texto, este método opera como :meth:"
"`BytesParser.parse`."

msgid ""
"Similar to the :meth:`parse` method, except it takes a string object instead "
"of a file-like object.  Calling this method on a string is equivalent to "
"wrapping *text* in a :class:`~io.StringIO` instance first and calling :meth:"
"`parse`."
msgstr ""
"Semelhante ao método :meth:`parse`, exceto que recebe um objeto string em "
"vez de um objeto tipo ficheiro. Chamar este método numa string é equivalente "
"a envolver primeiro o *text* numa instância de :class:`~io.StringIO` e "
"chamar o :meth:`parse`."

msgid ""
"Exactly like :class:`Parser`, except that *headersonly* defaults to ``True``."
msgstr ""
"Exatamente como :class:`Parser`, exceto que *headersonly* tem como valor "
"padrão ``True``."

msgid ""
"Since creating a message object structure from a string or a file object is "
"such a common task, four functions are provided as a convenience.  They are "
"available in the top-level :mod:`email` package namespace."
msgstr ""
"Uma vez que criar uma estrutura de objeto de mensagem a partir de uma string "
"ou de um objeto ficheiro é uma tarefa comum, são fornecidas quatro funções "
"por conveniência. Estão disponíveis no namespace de nível superior do "
"pacote :mod:`email`."

msgid ""
"Return a message object structure from a :term:`bytes-like object`.  This is "
"equivalent to ``BytesParser().parsebytes(s)``.  Optional *_class* and "
"*policy* are interpreted as with the :class:`~email.parser.BytesParser` "
"class constructor."
msgstr ""
"Retorna uma estrutura de objeto de mensagem a partir de um :term:`bytes-like "
"object`. É equivalente a ``BytesParser().parsebytes(s)``. O *_class* e "
"*policy* opcionais são interpretados como no construtor da classe :class:"
"`~email.parser.BytesParser`."

msgid ""
"Return a message object structure tree from an open binary :term:`file "
"object`.  This is equivalent to ``BytesParser().parse(fp)``.  *_class* and "
"*policy* are interpreted as with the :class:`~email.parser.BytesParser` "
"class constructor."
msgstr ""
"Retorna uma árvore de estrutura de objeto de mensagem a partir de um :term:"
"`objeto de ficheiro` binário aberto. É equivalente a ``BytesParser()."
"parse(fp)``. O *_class* e *policy* são interpretados como no construtor da "
"classe :class:`~email.parser.BytesParser`."

msgid ""
"Return a message object structure from a string.  This is equivalent to "
"``Parser().parsestr(s)``.  *_class* and *policy* are interpreted as with "
"the :class:`~email.parser.Parser` class constructor."
msgstr ""
"Retorna uma estrutura de objeto de mensagem a partir de uma string. É "
"equivalente a ``Parser().parsestr(s)``. O *_class* e *policy* são "
"interpretados como no construtor da classe :class:`~email.parser.Parser`."

msgid ""
"Return a message object structure tree from an open :term:`file object`. "
"This is equivalent to ``Parser().parse(fp)``.  *_class* and *policy* are "
"interpreted as with the :class:`~email.parser.Parser` class constructor."
msgstr ""
"Retorna uma árvore de estrutura de objeto de mensagem a partir de um :term:"
"`objeto de ficheiro` aberto. É equivalente a ``Parser().parse(fp)``. O "
"*_class* e *policy* são interpretados como no construtor da classe :class:"
"`~email.parser.Parser`."

msgid ""
"Here's an example of how you might use :func:`message_from_bytes` at an "
"interactive Python prompt::"
msgstr ""
"Aqui está um exemplo de como podes usar a função :func:`message_from_bytes` "
"numa consola interativa de Python::"

msgid ""
">>> import email\n"
">>> msg = email.message_from_bytes(myBytes)"
msgstr ""

msgid "Additional notes"
msgstr "Notas adicionais"

msgid "Here are some notes on the parsing semantics:"
msgstr "Aqui estão algumas notas sobre a semântica da análise:"

msgid ""
"Most non-\\ :mimetype:`multipart` type messages are parsed as a single "
"message object with a string payload.  These objects will return ``False`` "
"for :meth:`~email.message.EmailMessage.is_multipart`, and :meth:`~email."
"message.EmailMessage.iter_parts` will yield an empty list."
msgstr ""
"A maioria das mensagens que não são do tipo :mimetype:`multipart` são "
"analisadas como um único objeto de mensagem com um payload de string. Estes "
"objetos retornarão ``False`` em :meth:`~email.message.EmailMessage."
"is_multipart`, e :meth:`~email.message.EmailMessage.iter_parts` produzirá "
"uma lista vazia."

msgid ""
"All :mimetype:`multipart` type messages will be parsed as a container "
"message object with a list of sub-message objects for their payload.  The "
"outer container message will return ``True`` for :meth:`~email.message."
"EmailMessage.is_multipart`, and :meth:`~email.message.EmailMessage."
"iter_parts` will yield a list of subparts."
msgstr ""
"Todas as mensagens do tipo :mimetype:`multipart` serão analisadas como um "
"objeto de mensagem contentor com uma lista de sub-objetos de mensagem no seu "
"payload. A mensagem contentora externa retornará ``True`` em :meth:`~email."
"message.EmailMessage.is_multipart`, e :meth:`~email.message.EmailMessage."
"iter_parts` produzirá uma lista de subpartes."

msgid ""
"Most messages with a content type of :mimetype:`message/\\*` (such as :"
"mimetype:`message/delivery-status` and :mimetype:`message/rfc822`) will also "
"be parsed as container object containing a list payload of length 1.  Their :"
"meth:`~email.message.EmailMessage.is_multipart` method will return ``True``. "
"The single element yielded by :meth:`~email.message.EmailMessage.iter_parts` "
"will be a sub-message object."
msgstr ""
"A maioria das mensagens com um tipo de conteúdo :mimetype:`message/\\*` "
"(como :mimetype:`message/delivery-status` e :mimetype:`message/rfc822`) "
"também serão analisadas como um objeto contentor com um payload de lista de "
"comprimento 1. O seu método :meth:`~email.message.EmailMessage.is_multipart` "
"retornará ``True``. O único elemento produzido por :meth:`~email.message."
"EmailMessage.iter_parts` será um sub-objeto de mensagem."

msgid ""
"Some non-standards-compliant messages may not be internally consistent about "
"their :mimetype:`multipart`\\ -edness.  Such messages may have a :mailheader:"
"`Content-Type` header of type :mimetype:`multipart`, but their :meth:`~email."
"message.EmailMessage.is_multipart` method may return ``False``. If such "
"messages were parsed with the :class:`~email.parser.FeedParser`, they will "
"have an instance of the :class:`~email.errors."
"MultipartInvariantViolationDefect` class in their *defects* attribute list.  "
"See :mod:`email.errors` for details."
msgstr ""
"Algumas mensagens não conformes com as normas podem não ser internamente "
"consistentes quanto ao seu estado :mimetype:`multipart`. Tais mensagens "
"podem ter um cabeçalho :mailheader:`Content-Type` do tipo :mimetype:"
"`multipart`, mas o seu método :meth:`~email.message.EmailMessage."
"is_multipart` pode retornar ``False``. Se tais mensagens foram analisadas "
"com a :class:`~email.parser.FeedParser`, terão uma instância da classe :"
"class:`~email.errors.MultipartInvariantViolationDefect` na sua lista de "
"atributos *defects*. Consulte :mod:`email.errors` para mais detalhes."
