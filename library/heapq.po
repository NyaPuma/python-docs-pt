# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-03 14:40+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!heapq` --- Heap queue algorithm"
msgstr ":mod:`!heapq` --- Algoritmo de fila de prioridade (heap)"

msgid "**Source code:** :source:`Lib/heapq.py`"
msgstr "**Código-fonte:** :source:`Lib/heapq.py`"

msgid ""
"This module provides an implementation of the heap queue algorithm, also "
"known as the priority queue algorithm."
msgstr ""
"Este módulo fornece uma implementação do algoritmo de fila de heap, também "
"conhecido como algoritmo de fila de prioridade."

msgid ""
"Min-heaps are binary trees for which every parent node has a value less than "
"or equal to any of its children. We refer to this condition as the heap "
"invariant."
msgstr ""
"As min-heaps são árvores binárias onde cada nó pai tem um valor menor ou "
"igual a qualquer um dos seus filhos. Referimo-nos a esta condição como a "
"invariante da heap."

msgid ""
"For min-heaps, this implementation uses lists for which ``heap[k] <= "
"heap[2*k+1]`` and ``heap[k] <= heap[2*k+2]`` for all *k* for which the "
"compared elements exist.  Elements are counted from zero.  The interesting "
"property of a min-heap is that its smallest element is always the root, "
"``heap[0]``."
msgstr ""
"Para min-heaps, esta implementação utiliza listas onde ``heap[k] <= "
"heap[2*k+1]`` e ``heap[k] <= heap[2*k+2]`` para todo o *k* para o qual os "
"elementos comparados existam. Os elementos são contados a partir de zero. A "
"propriedade interessante de uma min-heap é que o seu menor elemento é sempre "
"a raiz, ``heap[0]``."

msgid ""
"Max-heaps satisfy the reverse invariant: every parent node has a value "
"*greater* than any of its children.  These are implemented as lists for "
"which ``maxheap[2*k+1] <= maxheap[k]`` and ``maxheap[2*k+2] <= maxheap[k]`` "
"for all *k* for which the compared elements exist. The root, ``maxheap[0]``, "
"contains the *largest* element; ``heap.sort(reverse=True)`` maintains the "
"max-heap invariant."
msgstr ""
"As max-heaps satisfazem a invariante inversa: cada nó pai tem um valor "
"*maior* que qualquer um dos seus filhos. Estas são implementadas como listas "
"onde ``maxheap[2*k+1] <= maxheap[k]`` e ``maxheap[2*k+2] <= maxheap[k]`` "
"para todo o *k* para o qual os elementos existam. A raiz, ``maxheap[0]``, "
"contém o *maior* elemento; ``heap.sort(reverse=True)`` mantém a invariante "
"de max-heap."

msgid ""
"The :mod:`!heapq` API differs from textbook heap algorithms in two aspects: "
"(a) We use zero-based indexing.  This makes the relationship between the "
"index for a node and the indexes for its children slightly less obvious, but "
"is more suitable since Python uses zero-based indexing. (b) Textbooks often "
"focus on max-heaps, due to their suitability for in-place sorting. Our "
"implementation favors min-heaps as they better correspond to Python :class:"
"`lists <list>`."
msgstr ""
"A API do :mod:`!heapq` difere dos algoritmos de heap dos livros didáticos em "
"dois aspetos: (a) Utilizamos indexação baseada em zero. Isto torna a relação "
"entre o índice de um nó e os índices dos seus filhos ligeiramente menos "
"óbvia, mas é mais adequada dado que o Python utiliza indexação baseada em "
"zero. (b) Os livros didáticos focam-se frequentemente em max-heaps, devido à "
"sua adequação para ordenação in-place. A nossa implementação favorece min-"
"heaps pois correspondem melhor às :class:`listas <list>` do Python."

msgid ""
"These two aspects make it possible to view the heap as a regular Python list "
"without surprises: ``heap[0]`` is the smallest item, and ``heap.sort()`` "
"maintains the heap invariant!"
msgstr ""
"Estes dois aspetos tornam possível ver a heap como uma lista normal de "
"Python sem surpresas: ``heap[0]`` é o item mais pequeno, e ``heap.sort()`` "
"mantém a invariante da heap!"

msgid ""
"Like :meth:`list.sort`, this implementation uses only the ``<`` operator for "
"comparisons, for both min-heaps and max-heaps."
msgstr ""
"Tal como :meth:`list.sort`, esta implementação utiliza apenas o operador "
"``<`` para comparações, tanto para min-heaps como para max-heaps."

msgid ""
"In the API below, and in this documentation, the unqualified term *heap* "
"generally refers to a min-heap. The API for max-heaps is named using a "
"``_max``  suffix."
msgstr ""
"Na API abaixo, e nesta documentação, o termo não qualificado *heap* refere-"
"se geralmente a uma min-heap. A API para max-heaps é nomeada utilizando um "
"sufixo ``_max``."

msgid ""
"To create a heap, use a list initialized as ``[]``, or transform an existing "
"list into a min-heap or max-heap using the :func:`heapify` or :func:"
"`heapify_max` functions, respectively."
msgstr ""
"Para criar uma heap, utilize uma lista inicializada como ``[]``, ou "
"transforme uma lista existente numa min-heap ou max-heap utilizando as "
"funções :func:`heapify` ou :func:`heapify_max`, respetivamente."

msgid "The following functions are provided for min-heaps:"
msgstr "As seguintes funções são fornecidas para min-heaps:"

msgid "Transform list *x* into a min-heap, in-place, in linear time."
msgstr "Transforma a lista *x* numa min-heap, in-place, em tempo linear."

msgid ""
"Push the value *item* onto the *heap*, maintaining the min-heap invariant."
msgstr "Insere o valor *item* na *heap*, mantendo a invariante de min-heap."

msgid ""
"Pop and return the smallest item from the *heap*, maintaining the min-heap "
"invariant.  If the heap is empty, :exc:`IndexError` is raised.  To access "
"the smallest item without popping it, use ``heap[0]``."
msgstr ""
"Remove e devolve o menor item da *heap*, mantendo a invariante de min-heap. "
"Se a heap estiver vazia, é levantada uma exceção :exc:`IndexError`. Para "
"aceder ao menor item sem o remover, utilize ``heap[0]``."

msgid ""
"Push *item* on the heap, then pop and return the smallest item from the "
"*heap*.  The combined action runs more efficiently than :func:`heappush` "
"followed by a separate call to :func:`heappop`."
msgstr ""
"Insere o *item* na heap, depois remove e devolve o menor item da *heap*. A "
"ação combinada corre de forma mais eficiente do que um :func:`heappush` "
"seguido de uma chamada separada a :func:`heappop`."

msgid ""
"Pop and return the smallest item from the *heap*, and also push the new "
"*item*. The heap size doesn't change. If the heap is empty, :exc:"
"`IndexError` is raised."
msgstr ""
"Remove e devolve o menor item da *heap*, e insere também o novo *item*. O "
"tamanho da heap não muda. Se a heap estiver vazia, é levantada uma exceção :"
"exc:`IndexError`."

msgid ""
"This one step operation is more efficient than a :func:`heappop` followed "
"by :func:`heappush` and can be more appropriate when using a fixed-size "
"heap. The pop/push combination always returns an element from the heap and "
"replaces it with *item*."
msgstr ""
"Esta operação de um só passo é mais eficiente do que um :func:`heappop` "
"seguido de um :func:`heappush` e pode ser mais apropriada ao utilizar uma "
"heap de tamanho fixo. A combinação pop/push devolve sempre um elemento da "
"heap e substitui-o pelo *item*."

msgid ""
"The value returned may be larger than the *item* added.  If that isn't "
"desired, consider using :func:`heappushpop` instead.  Its push/pop "
"combination returns the smaller of the two values, leaving the larger value "
"on the heap."
msgstr ""
"O valor devolvido pode ser maior do que o *item* adicionado. Se isso não for "
"desejado, considere utilizar :func:`heappushpop`. A sua combinação push/pop "
"devolve o menor dos dois valores, deixando o maior valor na heap."

msgid "For max-heaps, the following functions are provided:"
msgstr "Para max-heaps, são fornecidas as seguintes funções:"

msgid "Transform list *x* into a max-heap, in-place, in linear time."
msgstr "Transforma a lista *x* numa max-heap, in-place, em tempo linear."

msgid ""
"Push the value *item* onto the max-heap *heap*, maintaining the max-heap "
"invariant."
msgstr ""
"Insere o valor *item* na max-heap *heap*, mantendo a invariante de max-heap."

msgid ""
"Pop and return the largest item from the max-heap *heap*, maintaining the "
"max-heap invariant.  If the max-heap is empty, :exc:`IndexError` is raised. "
"To access the largest item without popping it, use ``maxheap[0]``."
msgstr ""
"Remove e devolve o maior item da max-heap *heap*, mantendo a invariante de "
"max-heap. Se a max-heap estiver vazia, é levantada uma exceção :exc:"
"`IndexError`. Para aceder ao maior item sem o remover, utilize "
"``maxheap[0]``."

msgid ""
"Push *item* on the max-heap *heap*, then pop and return the largest item "
"from *heap*. The combined action runs more efficiently than :func:"
"`heappush_max` followed by a separate call to :func:`heappop_max`."
msgstr ""
"Insere o *item* na max-heap *heap*, depois remove e devolve o maior item da "
"*heap*. A ação combinada corre de forma mais eficiente do que um :func:"
"`heappush_max` seguido de uma chamada separada a :func:`heappop_max`."

msgid ""
"Pop and return the largest item from the max-heap *heap* and also push the "
"new *item*. The max-heap size doesn't change. If the max-heap is empty, :exc:"
"`IndexError` is raised."
msgstr ""
"Remove e devolve o maior item da max-heap *heap* e também insere o novo "
"*item*. O tamanho da max-heap não muda. Se a max-heap estiver vazia, é "
"levantada uma exceção :exc:`IndexError`."

msgid ""
"The value returned may be smaller than the *item* added.  Refer to the "
"analogous function :func:`heapreplace` for detailed usage notes."
msgstr ""
"O valor devolvido pode ser menor que o *item* adicionado. Consulte a função "
"análoga :func:`heapreplace` para notas de utilização detalhadas."

msgid "The module also offers three general purpose functions based on heaps."
msgstr ""
"O módulo oferece também três funções de propósito geral baseadas em heaps."

msgid ""
"Merge multiple sorted inputs into a single sorted output (for example, merge "
"timestamped entries from multiple log files).  Returns an :term:`iterator` "
"over the sorted values."
msgstr ""
"Funde múltiplas entradas ordenadas numa única saída ordenada (por exemplo, "
"fundir entradas com carimbo de data/hora de vários ficheiros de log). "
"Devolve um :term:`iterador` sobre os valores ordenados."

msgid ""
"Similar to ``sorted(itertools.chain(*iterables))`` but returns an iterable, "
"does not pull the data into memory all at once, and assumes that each of the "
"input streams is already sorted (smallest to largest)."
msgstr ""
"Semelhante a ``sorted(itertools.chain(*iterables))`` mas devolve um "
"iterável, não carrega os dados todos para a memória de uma vez, e assume que "
"cada um dos fluxos de entrada já está ordenado (do menor para o maior)."

msgid ""
"Has two optional arguments which must be specified as keyword arguments."
msgstr ""
"Tem dois argumentos opcionais que devem ser especificados como argumentos "
"nomeados."

msgid ""
"*key* specifies a :term:`key function` of one argument that is used to "
"extract a comparison key from each input element.  The default value is "
"``None`` (compare the elements directly)."
msgstr ""
"*key* especifica uma :term:`função de chave` de um argumento que é utilizada "
"para extrair uma chave de comparação de cada elemento de entrada. O valor "
"padrão é ``None`` (compara os elementos diretamente)."

msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the input elements "
"are merged as if each comparison were reversed. To achieve behavior similar "
"to ``sorted(itertools.chain(*iterables), reverse=True)``, all iterables must "
"be sorted from largest to smallest."
msgstr ""
"*reverse* é um valor booleano. Se definido como ``True``, os elementos de "
"entrada são fundidos como se cada comparação fosse invertida. Para obter um "
"comportamento semelhante a ``sorted(itertools.chain(*iterables), "
"reverse=True)``, todos os iteráveis devem estar ordenados do maior para o "
"menor."

msgid "Added the optional *key* and *reverse* parameters."
msgstr "Adicionados os parâmetros opcionais *key* e *reverse*."

msgid ""
"Return a list with the *n* largest elements from the dataset defined by "
"*iterable*.  *key*, if provided, specifies a function of one argument that "
"is used to extract a comparison key from each element in *iterable* (for "
"example, ``key=str.lower``).  Equivalent to:  ``sorted(iterable, key=key, "
"reverse=True)[:n]``."
msgstr ""
"Devolve uma lista com os *n* maiores elementos do conjunto de dados definido "
"por *iterable*. *key*, se fornecido, especifica uma função de um argumento "
"que é utilizada para extrair uma chave de comparação de cada elemento no "
"*iterable* (por exemplo, ``key=str.lower``). Equivalente a: "
"``sorted(iterable, key=key, reverse=True)[:n]``."

msgid ""
"Return a list with the *n* smallest elements from the dataset defined by "
"*iterable*.  *key*, if provided, specifies a function of one argument that "
"is used to extract a comparison key from each element in *iterable* (for "
"example, ``key=str.lower``).  Equivalent to:  ``sorted(iterable, key=key)[:"
"n]``."
msgstr ""
"Devolve uma lista com os *n* menores elementos do conjunto de dados definido "
"por *iterable*. *key*, se fornecido, especifica uma função de um argumento "
"que é utilizada para extrair uma chave de comparação de cada elemento no "
"*iterable* (por exemplo, ``key=str.lower``). Equivalente a: "
"``sorted(iterable, key=key)[:n]``."

msgid ""
"The latter two functions perform best for smaller values of *n*.  For larger "
"values, it is more efficient to use the :func:`sorted` function.  Also, when "
"``n==1``, it is more efficient to use the built-in :func:`min` and :func:"
"`max` functions.  If repeated usage of these functions is required, consider "
"turning the iterable into an actual heap."
msgstr ""
"As últimas duas funções têm melhor desempenho para valores pequenos de *n*. "
"Para valores maiores, é mais eficiente utilizar a função :func:`sorted`. "
"Além disso, quando ``n==1``, é mais eficiente utilizar as funções "
"integradas :func:`min` e :func:`max`. Se for necessária a utilização "
"repetida destas funções, considere transformar o iterável numa heap real."

msgid "Basic Examples"
msgstr "Exemplos Básicos"

msgid ""
"A `heapsort <https://en.wikipedia.org/wiki/Heapsort>`_ can be implemented by "
"pushing all values onto a heap and then popping off the smallest values one "
"at a time::"
msgstr ""
"Um `heapsort <https://en.wikipedia.org/wiki/Heapsort>`_ pode ser "
"implementado inserindo todos os valores numa heap e depois removendo os "
"valores mais pequenos um de cada vez::"

msgid ""
">>> def heapsort(iterable):\n"
"...     h = []\n"
"...     for value in iterable:\n"
"...         heappush(h, value)\n"
"...     return [heappop(h) for i in range(len(h))]\n"
"...\n"
">>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])\n"
"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"
msgstr ""

msgid ""
"This is similar to ``sorted(iterable)``, but unlike :func:`sorted`, this "
"implementation is not stable."
msgstr ""
"Isto é semelhante a ``sorted(iterable)``, mas ao contrário de :func:"
"`sorted`, esta implementação não é estável."

msgid ""
"Heap elements can be tuples.  This is useful for assigning comparison values "
"(such as task priorities) alongside the main record being tracked::"
msgstr ""
"Os elementos da heap podem ser tuplos. Isto é útil para atribuir valores de "
"comparação (como prioridades de tarefas) juntamente com o registo principal "
"que está a ser acompanhado::"

msgid ""
">>> h = []\n"
">>> heappush(h, (5, 'write code'))\n"
">>> heappush(h, (7, 'release product'))\n"
">>> heappush(h, (1, 'write spec'))\n"
">>> heappush(h, (3, 'create tests'))\n"
">>> heappop(h)\n"
"(1, 'write spec')"
msgstr ""

msgid "Other Applications"
msgstr "Outras Aplicações"

msgid ""
"`Medians <https://en.wikipedia.org/wiki/Median>`_ are a measure of central "
"tendency for a set of numbers.  In distributions skewed by outliers, the "
"median provides a more stable estimate than an average (arithmetic mean).  A "
"running median is an `online algorithm <https://en.wikipedia.org/wiki/"
"Online_algorithm>`_ that updates continuously as new data arrives."
msgstr ""
"As `medianas <https://en.wikipedia.org/wiki/Median>`_ são uma medida de "
"tendência central para um conjunto de números. Em distribuições enviesadas "
"por valores atípicos (outliers), a mediana fornece uma estimativa mais "
"estável do que uma média (média aritmética). Uma mediana móvel é um "
"`algoritmo online <https://en.wikipedia.org/wiki/Online_algorithm>`_ que se "
"atualiza continuamente à medida que novos dados chegam."

msgid ""
"A running median can be efficiently implemented by balancing two heaps, a "
"max-heap for values at or below the midpoint and a min-heap for values above "
"the midpoint.  When the two heaps have the same size, the new median is the "
"average of the tops of the two heaps; otherwise, the median is at the top of "
"the larger heap::"
msgstr ""
"Uma mediana móvel pode ser implementada eficientemente equilibrando duas "
"heaps: uma max-heap para valores no ou abaixo do ponto médio e uma min-heap "
"para valores acima do ponto médio. Quando as duas heaps têm o mesmo tamanho, "
"a nova mediana é a média dos topos das duas heaps; caso contrário, a mediana "
"está no topo da heap maior::"

msgid ""
"def running_median(iterable):\n"
"    \"Yields the cumulative median of values seen so far.\"\n"
"\n"
"    lo = []  # max-heap\n"
"    hi = []  # min-heap (same size as or one smaller than lo)\n"
"\n"
"    for x in iterable:\n"
"        if len(lo) == len(hi):\n"
"            heappush_max(lo, heappushpop(hi, x))\n"
"            yield lo[0]\n"
"        else:\n"
"            heappush(hi, heappushpop_max(lo, x))\n"
"            yield (lo[0] + hi[0]) / 2"
msgstr ""
"def running_median(iterable):\n"
"    \"Gera a mediana cumulativa dos valores vistos até agora.\"\n"
"\n"
"    lo = []  # max-heap\n"
"    hi = []  # min-heap (mesmo tamanho ou um elemento menor que lo)\n"
"\n"
"    for x in iterable:\n"
"        if len(lo) == len(hi):\n"
"            heappush_max(lo, heappushpop(hi, x))\n"
"            yield lo[0]\n"
"        else:\n"
"            heappush(hi, heappushpop_max(lo, x))\n"
"            yield (lo[0] + hi[0]) / 2"

msgid "For example::"
msgstr "Por exemplo::"

msgid ""
">>> list(running_median([5.0, 9.0, 4.0, 12.0, 8.0, 9.0]))\n"
"[5.0, 7.0, 5.0, 7.0, 8.0, 8.5]"
msgstr ""

msgid "Priority Queue Implementation Notes"
msgstr "Notas de Implementação de Fila de Prioridade"

msgid ""
"A `priority queue <https://en.wikipedia.org/wiki/Priority_queue>`_ is common "
"use for a heap, and it presents several implementation challenges:"
msgstr ""
"Uma `fila de prioridade <https://en.wikipedia.org/wiki/Priority_queue>`_ é "
"um uso comum para uma heap, e apresenta vários desafios de implementação:"

msgid ""
"Sort stability:  how do you get two tasks with equal priorities to be "
"returned in the order they were originally added?"
msgstr ""
"Estabilidade da ordenação: como fazer com que duas tarefas com prioridades "
"iguais sejam devolvidas na ordem em que foram originalmente adicionadas?"

msgid ""
"Tuple comparison breaks for (priority, task) pairs if the priorities are "
"equal and the tasks do not have a default comparison order."
msgstr ""
"A comparação de tuplos falha para pares (prioridade, tarefa) se as "
"prioridades forem iguais e as tarefas não tiverem uma ordem de comparação "
"padrão."

msgid ""
"If the priority of a task changes, how do you move it to a new position in "
"the heap?"
msgstr ""
"Se a prioridade de uma tarefa mudar, como a move para uma nova posição na "
"heap?"

msgid ""
"Or if a pending task needs to be deleted, how do you find it and remove it "
"from the queue?"
msgstr ""
"Ou se uma tarefa pendente precisar de ser eliminada, como a encontra e "
"remove da fila?"

msgid ""
"A solution to the first two challenges is to store entries as 3-element list "
"including the priority, an entry count, and the task.  The entry count "
"serves as a tie-breaker so that two tasks with the same priority are "
"returned in the order they were added. And since no two entry counts are the "
"same, the tuple comparison will never attempt to directly compare two tasks."
msgstr ""
"Uma solução para os dois primeiros desafios é armazenar as entradas como uma "
"lista de 3 elementos, incluindo a prioridade, uma contagem de entrada e a "
"tarefa. A contagem de entrada serve como desempate para que duas tarefas com "
"a mesma prioridade sejam devolvidas na ordem em que foram adicionadas. E "
"como não há duas contagens iguais, a comparação de tuplos nunca tentará "
"comparar diretamente duas tarefas."

msgid ""
"Another solution to the problem of non-comparable tasks is to create a "
"wrapper class that ignores the task item and only compares the priority "
"field::"
msgstr ""
"Outra solução para o problema de tarefas não comparáveis é criar uma classe "
"invólucro (wrapper) que ignore o item da tarefa e apenas compare o campo de "
"prioridade::"

msgid ""
"from dataclasses import dataclass, field\n"
"from typing import Any\n"
"\n"
"@dataclass(order=True)\n"
"class PrioritizedItem:\n"
"    priority: int\n"
"    item: Any=field(compare=False)"
msgstr ""
"from dataclasses import dataclass, field\n"
"from typing import Any\n"
"\n"
"@dataclass(order=True)\n"
"class PrioritizedItem:\n"
"    priority: int\n"
"    item: Any=field(compare=False)"

msgid ""
"The remaining challenges revolve around finding a pending task and making "
"changes to its priority or removing it entirely.  Finding a task can be done "
"with a dictionary pointing to an entry in the queue."
msgstr ""
"Os desafios restantes giram em torno de encontrar uma tarefa pendente e "
"fazer alterações na sua prioridade ou removê-la inteiramente. Encontrar uma "
"tarefa pode ser feito com um dicionário que aponte para uma entrada na fila."

msgid ""
"Removing the entry or changing its priority is more difficult because it "
"would break the heap structure invariants.  So, a possible solution is to "
"mark the entry as removed and add a new entry with the revised priority::"
msgstr ""
"Remover a entrada ou alterar a sua prioridade é mais difícil porque "
"quebraria as invariantes da estrutura da heap. Assim, uma solução possível é "
"marcar a entrada como removida e adicionar uma nova entrada com a prioridade "
"revista::"

msgid ""
"pq = []                         # list of entries arranged in a heap\n"
"entry_finder = {}               # mapping of tasks to entries\n"
"REMOVED = '<removed-task>'      # placeholder for a removed task\n"
"counter = itertools.count()     # unique sequence count\n"
"\n"
"def add_task(task, priority=0):\n"
"    'Add a new task or update the priority of an existing task'\n"
"    if task in entry_finder:\n"
"        remove_task(task)\n"
"    count = next(counter)\n"
"    entry = [priority, count, task]\n"
"    entry_finder[task] = entry\n"
"    heappush(pq, entry)\n"
"\n"
"def remove_task(task):\n"
"    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n"
"    entry = entry_finder.pop(task)\n"
"    entry[-1] = REMOVED\n"
"\n"
"def pop_task():\n"
"    'Remove and return the lowest priority task. Raise KeyError if empty.'\n"
"    while pq:\n"
"        priority, count, task = heappop(pq)\n"
"        if task is not REMOVED:\n"
"            del entry_finder[task]\n"
"            return task\n"
"    raise KeyError('pop from an empty priority queue')"
msgstr ""

msgid "Theory"
msgstr "Teoria"

msgid ""
"Heaps are arrays for which ``a[k] <= a[2*k+1]`` and ``a[k] <= a[2*k+2]`` for "
"all *k*, counting elements from 0.  For the sake of comparison, non-existing "
"elements are considered to be infinite.  The interesting property of a heap "
"is that ``a[0]`` is always its smallest element."
msgstr ""
"Heaps são arrays para os quais ``a[k] <= a[2*k+1]`` e ``a[k] <= a[2*k+2]`` "
"para todo o *k*, contando elementos a partir de 0. Para efeitos de "
"comparação, elementos não existentes são considerados infinitos. A "
"propriedade interessante de uma heap é que ``a[0]`` é sempre o seu menor "
"elemento."

msgid ""
"The strange invariant above is meant to be an efficient memory "
"representation for a tournament.  The numbers below are *k*, not ``a[k]``::"
msgstr ""
"A estranha invariante acima pretende ser uma representação de memória "
"eficiente para um torneio. Os números abaixo são *k*, não ``a[k]``::"

msgid ""
"                               0\n"
"\n"
"              1                                 2\n"
"\n"
"      3               4                5               6\n"
"\n"
"  7       8       9       10      11      12      13      14\n"
"\n"
"15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30"
msgstr ""

msgid ""
"In the tree above, each cell *k* is topping ``2*k+1`` and ``2*k+2``. In a "
"usual binary tournament we see in sports, each cell is the winner over the "
"two cells it tops, and we can trace the winner down the tree to see all "
"opponents s/he had.  However, in many computer applications of such "
"tournaments, we do not need to trace the history of a winner. To be more "
"memory efficient, when a winner is promoted, we try to replace it by "
"something else at a lower level, and the rule becomes that a cell and the "
"two cells it tops contain three different items, but the top cell \"wins\" "
"over the two topped cells."
msgstr ""
"Na árvore acima, cada célula *k* está acima de ``2*k+1`` e ``2*k+2``. Num "
"torneio binário habitual que vemos no desporto, cada célula é a vencedora "
"sobre as duas células que encabeça, e podemos rastrear o vencedor árvore "
"abaixo para ver todos os adversários que teve. No entanto, em muitas "
"aplicações informáticas de tais torneios, não precisamos de rastrear o "
"histórico de um vencedor. Para ser mais eficiente em termos de memória, "
"quando um vencedor é promovido, tentamos substituí-lo por outra coisa num "
"nível inferior, e a regra passa a ser que uma célula e as duas células que "
"ela encabeça contêm três itens diferentes, mas a célula superior \"vence\" "
"as duas células abaixo."

msgid ""
"If this heap invariant is protected at all time, index 0 is clearly the "
"overall winner.  The simplest algorithmic way to remove it and find the "
"\"next\" winner is to move some loser (let's say cell 30 in the diagram "
"above) into the 0 position, and then percolate this new 0 down the tree, "
"exchanging values, until the invariant is re-established. This is clearly "
"logarithmic on the total number of items in the tree. By iterating over all "
"items, you get an *O*\\ (*n* log *n*) sort."
msgstr ""
"Se esta invariante de heap for protegida em todos os momentos, o índice 0 é "
"claramente o vencedor global. A forma algorítmica mais simples de o remover "
"e encontrar o \"próximo\" vencedor é mover algum perdedor (digamos, a célula "
"30 no diagrama acima) para a posição 0, e depois fazer percolar este novo 0 "
"pela árvore abaixo, trocando valores, até que a invariante seja "
"restabelecida. Isto é claramente logarítmico em relação ao número total de "
"itens na árvore. Ao iterar sobre todos os itens, obtém-se uma ordenação "
"*O*\\ (*n* log *n*)."

msgid ""
"A nice feature of this sort is that you can efficiently insert new items "
"while the sort is going on, provided that the inserted items are not "
"\"better\" than the last 0'th element you extracted.  This is especially "
"useful in simulation contexts, where the tree holds all incoming events, and "
"the \"win\" condition means the smallest scheduled time.  When an event "
"schedules other events for execution, they are scheduled into the future, so "
"they can easily go into the heap.  So, a heap is a good structure for "
"implementing schedulers (this is what I used for my MIDI sequencer :-)."
msgstr ""
"Uma característica agradável desta ordenação é que pode inserir novos itens "
"eficientemente enquanto a ordenação decorre, desde que os itens inseridos "
"não sejam \"melhores\" do que o último elemento 0 que extraiu. Isto é "
"especialmente útil em contextos de simulação, onde a árvore contém todos os "
"eventos de entrada, e a condição de \"vitória\" significa o menor tempo "
"agendado. Quando um evento agenda outros eventos para execução, estes são "
"agendados para o futuro, pelo que podem entrar facilmente na heap. Assim, "
"uma heap é uma boa estrutura para implementar agendadores (foi o que "
"utilizei para o meu sequenciador MIDI :-)."

msgid ""
"Various structures for implementing schedulers have been extensively "
"studied, and heaps are good for this, as they are reasonably speedy, the "
"speed is almost constant, and the worst case is not much different than the "
"average case. However, there are other representations which are more "
"efficient overall, yet the worst cases might be terrible."
msgstr ""
"Várias estruturas para implementar agendadores foram extensivamente "
"estudadas, e as heaps são boas para isso, pois são razoavelmente rápidas, a "
"velocidade é quase constante, e o pior caso não é muito diferente do caso "
"médio. No entanto, existem outras representações que são mais eficientes no "
"geral, embora os piores casos possam ser terríveis."

msgid ""
"Heaps are also very useful in big disk sorts.  You most probably all know "
"that a big sort implies producing \"runs\" (which are pre-sorted sequences, "
"whose size is usually related to the amount of CPU memory), followed by a "
"merging passes for these runs, which merging is often very cleverly "
"organised [#]_. It is very important that the initial sort produces the "
"longest runs possible.  Tournaments are a good way to achieve that.  If, "
"using all the memory available to hold a tournament, you replace and "
"percolate items that happen to fit the current run, you'll produce runs "
"which are twice the size of the memory for random input, and much better for "
"input fuzzily ordered."
msgstr ""
"As heaps também são muito úteis em grandes ordenações de disco. "
"Provavelmente todos sabem que uma grande ordenação implica a produção de "
"\"runs\" (que são sequências pré-ordenadas, cujo tamanho está normalmente "
"relacionado com a quantidade de memória CPU), seguidas por passagens de "
"fusão (merging) para estas runs, fusão essa que é frequentemente organizada "
"de forma muito inteligente [#]_. É muito importante que a ordenação inicial "
"produza as runs mais longas possíveis. Os torneios são uma boa forma de o "
"conseguir. Se, utilizando toda a memória disponível para manter um torneio, "
"substituir e fizer percolar itens que caibam na run atual, produzirá runs "
"que têm o dobro do tamanho da memória para entrada aleatória, e muito "
"melhores para entrada ordenada de forma difusa (fuzzily ordered)."

msgid ""
"Moreover, if you output the 0'th item on disk and get an input which may not "
"fit in the current tournament (because the value \"wins\" over the last "
"output value), it cannot fit in the heap, so the size of the heap "
"decreases.  The freed memory could be cleverly reused immediately for "
"progressively building a second heap, which grows at exactly the same rate "
"the first heap is melting.  When the first heap completely vanishes, you "
"switch heaps and start a new run.  Clever and quite effective!"
msgstr ""
"Além disso, se enviar o item 0 para o disco e receber uma entrada que possa "
"não caber no torneio atual (porque o valor \"vence\" o último valor de "
"saída), ela não pode caber na heap, pelo que o tamanho da heap diminui. A "
"memória libertada poderia ser imediatamente reutilizada para construir "
"progressivamente uma segunda heap, que cresce exatamente à mesma taxa que a "
"primeira heap se esvazia. Quando a primeira heap desaparece completamente, "
"troca-se de heap e inicia-se uma nova run. Inteligente e bastante eficaz!"

msgid ""
"In a word, heaps are useful memory structures to know.  I use them in a few "
"applications, and I think it is good to keep a 'heap' module around. :-)"
msgstr ""
"Em suma, as heaps são estruturas de memória úteis de conhecer. Utilizo-as em "
"algumas aplicações e acho que é bom ter um módulo 'heap' por perto. :-)"

msgid "Footnotes"
msgstr "Notas de rodapé"

msgid ""
"The disk balancing algorithms which are current, nowadays, are more annoying "
"than clever, and this is a consequence of the seeking capabilities of the "
"disks. On devices which cannot seek, like big tape drives, the story was "
"quite different, and one had to be very clever to ensure (far in advance) "
"that each tape movement will be the most effective possible (that is, will "
"best participate at \"progressing\" the merge).  Some tapes were even able "
"to read backwards, and this was also used to avoid the rewinding time. "
"Believe me, real good tape sorts were quite spectacular to watch! From all "
"times, sorting has always been a Great Art! :-)"
msgstr ""
"Os algoritmos de balanceamento de disco que são atuais, hoje em dia, são "
"mais irritantes do que inteligentes, e isto é uma consequência das "
"capacidades de busca (seeking) dos discos. Em dispositivos que não conseguem "
"fazer buscas, como grandes unidades de fita, a história era bem diferente, e "
"era preciso ser muito inteligente para garantir (com muita antecedência) que "
"cada movimento da fita seria o mais eficaz possível (ou seja, que melhor "
"participaria no \"progresso\" da fusão). Algumas fitas eram até capazes de "
"ler de trás para a frente, e isto também era usado para evitar o tempo de "
"rebobinagem. Acreditem, boas ordenações de fita eram espetaculares de ver! "
"Desde sempre, a ordenação foi uma Grande Arte! :-)"
