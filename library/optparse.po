# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-07 14:20+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!optparse` --- Parser for command line options"
msgstr ":mod:`!optparse` --- Analisador de opções de linha de comandos"

msgid "**Source code:** :source:`Lib/optparse.py`"
msgstr "**Código fonte:** :source:`Lib/optparse.py`"

msgid "Choosing an argument parsing library"
msgstr "Escolher uma biblioteca de análise de argumentos"

msgid "The standard library includes three argument parsing libraries:"
msgstr "A biblioteca padrão inclui três bibliotecas de análise de argumentos:"

msgid ""
":mod:`getopt`: a module that closely mirrors the procedural C ``getopt`` "
"API. Included in the standard library since before the initial Python 1.0 "
"release."
msgstr ""
":mod:`getopt`: um módulo que reflete de perto a API procedural C ``getopt``. "
"Incluído na biblioteca padrão desde antes do lançamento inicial do Python "
"1.0."

msgid ""
":mod:`!optparse`: a declarative replacement for ``getopt`` that provides "
"equivalent functionality without requiring each application to implement its "
"own procedural option parsing logic. Included in the standard library since "
"the Python 2.3 release."
msgstr ""

msgid ""
":mod:`argparse`: a more opinionated alternative to ``optparse`` that "
"provides more functionality by default, at the expense of reduced "
"application flexibility in controlling exactly how arguments are processed. "
"Included in the standard library since the Python 2.7 and Python 3.2 "
"releases."
msgstr ""
":mod:`argparse`: uma alternativa mais opinativa ao ``optparse`` que fornece "
"mais funcionalidade por predefinição, à custa de uma flexibilidade reduzida "
"da aplicação no controlo exato de como os argumentos são processados. "
"Incluído na biblioteca padrão desde os lançamentos do Python 2.7 e Python "
"3.2."

msgid ""
"In the absence of more specific argument parsing design constraints, :mod:"
"`argparse` is the recommended choice for implementing command line "
"applications, as it offers the highest level of baseline functionality with "
"the least application level code."
msgstr ""
"Na ausência de restrições de design mais específicas de análise de "
"argumentos, :mod:`argparse` é a escolha recomendada para implementar "
"aplicações de linha de comandos, uma vez que oferece o nível mais alto de "
"funcionalidade base com o menor código a nível de aplicação."

msgid ""
":mod:`getopt` is retained almost entirely for backwards compatibility "
"reasons. However, it also serves a niche use case as a tool for prototyping "
"and testing command line argument handling in ``getopt``-based C "
"applications."
msgstr ""
":mod:`getopt` é mantido quase exclusivamente por razões de compatibilidade "
"retroativa. No entanto, também serve um caso de uso específico como "
"ferramenta para prototipagem e teste de manipulação de argumentos de linha "
"de comandos em aplicações C baseadas em ``getopt``."

msgid ""
":mod:`!optparse` should be considered as an alternative to :mod:`argparse` "
"in the following cases:"
msgstr ""

msgid ""
"an application is already using :mod:`!optparse` and doesn't want to risk "
"the subtle behavioural changes that may arise when migrating to :mod:"
"`argparse`"
msgstr ""

msgid ""
"the application requires additional control over the way options and "
"positional parameters are interleaved on the command line (including the "
"ability to disable the interleaving feature completely)"
msgstr ""
"a aplicação requer controlo adicional sobre a forma como as opções e os "
"parâmetros posicionais são intercalados na linha de comandos (incluindo a "
"capacidade de desativar completamente a funcionalidade de intercalamento)"

msgid ""
"the application requires additional control over the incremental parsing of "
"command line elements (while ``argparse`` does support this, the exact way "
"it works in practice is undesirable for some use cases)"
msgstr ""
"a aplicação requer controlo adicional sobre a análise incremental de "
"elementos da linha de comandos (embora ``argparse`` suporte isto, a forma "
"exata como funciona na prática é indesejável para alguns casos de uso)"

msgid ""
"the application requires additional control over the handling of options "
"which accept parameter values that may start with ``-`` (such as delegated "
"options to be passed to invoked subprocesses)"
msgstr ""
"a aplicação requer controlo adicional sobre o manuseamento de opções que "
"aceitam valores de parâmetros que podem começar com ``-`` (como opções "
"delegadas a serem passadas para subprocessos invocados)"

msgid ""
"the application requires some other command line parameter processing "
"behavior which ``argparse`` does not support, but which can be implemented "
"in terms of the lower level interface offered by ``optparse``"
msgstr ""
"a aplicação requer algum outro comportamento de processamento de parâmetros "
"de linha de comandos que ``argparse`` não suporta, mas que pode ser "
"implementado em termos da interface de nível inferior oferecida por "
"``optparse``"

msgid ""
"These considerations also mean that :mod:`!optparse` is likely to provide a "
"better foundation for library authors writing third party command line "
"argument processing libraries."
msgstr ""

msgid ""
"As a concrete example, consider the following two command line argument "
"parsing configurations, the first using ``optparse``, and the second using "
"``argparse``:"
msgstr ""
"Como exemplo concreto, considere as seguintes duas configurações de análise "
"de argumentos de linha de comandos, a primeira usando ``optparse`` e a "
"segunda usando ``argparse``:"

msgid ""
"import optparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = optparse.OptionParser()\n"
"    parser.add_option('-o', '--output')\n"
"    parser.add_option('-v', dest='verbose', action='store_true')\n"
"    opts, args = parser.parse_args()\n"
"    process(args, output=opts.output, verbose=opts.verbose)"
msgstr ""
"import optparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = optparse.OptionParser()\n"
"    parser.add_option('-o', '--output')\n"
"    parser.add_option('-v', dest='verbose', action='store_true')\n"
"    opts, args = parser.parse_args()\n"
"    process(args, output=opts.output, verbose=opts.verbose)"

msgid ""
"import argparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = argparse.ArgumentParser()\n"
"    parser.add_argument('-o', '--output')\n"
"    parser.add_argument('-v', dest='verbose', action='store_true')\n"
"    parser.add_argument('rest', nargs='*')\n"
"    args = parser.parse_args()\n"
"    process(args.rest, output=args.output, verbose=args.verbose)"
msgstr ""
"import argparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = argparse.ArgumentParser()\n"
"    parser.add_argument('-o', '--output')\n"
"    parser.add_argument('-v', dest='verbose', action='store_true')\n"
"    parser.add_argument('rest', nargs='*')\n"
"    args = parser.parse_args()\n"
"    process(args.rest, output=args.output, verbose=args.verbose)"

msgid ""
"The most obvious difference is that in the ``optparse`` version, the non-"
"option arguments are processed separately by the application after the "
"option processing is complete. In the ``argparse`` version, positional "
"arguments are declared and processed in the same way as the named options."
msgstr ""
"A diferença mais óbvia é que, na versão ``optparse``, os argumentos não-"
"opção são processados separadamente pela aplicação após a conclusão do "
"processamento de opções. Na versão ``argparse``, os argumentos posicionais "
"são declarados e processados da mesma forma que as opções nomeadas."

msgid ""
"However, the ``argparse`` version will also handle some parameter "
"combination differently from the way the ``optparse`` version would handle "
"them. For example (amongst other differences):"
msgstr ""
"No entanto, a versão ``argparse`` também lidará com algumas combinações de "
"parâmetros de forma diferente da versão ``optparse``. Por exemplo (entre "
"outras diferenças):"

msgid ""
"supplying ``-o -v`` gives ``output=\"-v\"`` and ``verbose=False`` when using "
"``optparse``, but a usage error with ``argparse`` (complaining that no value "
"has been supplied for ``-o/--output``, since ``-v`` is interpreted as "
"meaning the verbosity flag)"
msgstr ""
"fornecer ``-o -v`` dá ``output=\"-v\"`` e ``verbose=False`` ao usar "
"``optparse``, mas um erro de utilização com ``argparse`` (reclamando que "
"nenhum valor foi fornecido para ``-o/--output``, uma vez que ``-v`` é "
"interpretado como significando a flag de verbosidade)"

msgid ""
"similarly, supplying ``-o --`` gives ``output=\"--\"`` and ``args=()`` when "
"using ``optparse``, but a usage error with ``argparse`` (also complaining "
"that no value has been supplied for ``-o/--output``, since ``--`` is "
"interpreted as terminating the option processing and treating all remaining "
"values as positional arguments)"
msgstr ""
"da mesma forma, fornecer ``-o --`` dá ``output=\"--\"`` e ``args=()`` ao "
"usar ``optparse``, mas um erro de utilização com ``argparse`` (também "
"reclamando que nenhum valor foi fornecido para ``-o/--output``, uma vez que "
"``--`` é interpretado como terminando o processamento de opções e tratando "
"todos os valores restantes como argumentos posicionais)"

msgid ""
"supplying ``-o=foo`` gives ``output=\"=foo\"`` when using ``optparse``, but "
"gives ``output=\"foo\"`` with ``argparse`` (since ``=`` is special cased as "
"an alternative separator for option parameter values)"
msgstr ""
"fornecer ``-o=foo`` dá ``output=\"=foo\"`` ao usar ``optparse``, mas dá "
"``output=\"foo\"`` com ``argparse`` (uma vez que ``=`` é tratado de forma "
"especial como um separador alternativo para valores de parâmetros de opções)"

msgid ""
"Whether these differing behaviors in the ``argparse`` version are considered "
"desirable or a problem will depend on the specific command line application "
"use case."
msgstr ""
"Se estes comportamentos diferentes na versão ``argparse`` são considerados "
"desejáveis ou um problema dependerá do caso de uso específico da aplicação "
"de linha de comandos."

msgid ""
":pypi:`click` is a third party argument processing library (originally based "
"on ``optparse``), which allows command line applications to be developed as "
"a set of decorated command implementation functions."
msgstr ""
":pypi:`click` é uma biblioteca de processamento de argumentos de terceiros "
"(originalmente baseada em ``optparse``), que permite que aplicações de linha "
"de comandos sejam desenvolvidas como um conjunto de funções de implementação "
"de comandos decoradas."

msgid ""
"Other third party libraries, such as :pypi:`typer` or :pypi:`msgspec-click`, "
"allow command line interfaces to be specified in ways that more effectively "
"integrate with static checking of Python type annotations."
msgstr ""
"Outras bibliotecas de terceiros, como :pypi:`typer` ou :pypi:`msgspec-"
"click`, permitem que interfaces de linha de comandos sejam especificadas de "
"formas que integram mais efetivamente com a verificação estática de "
"anotações de tipo Python."

msgid "Introduction"
msgstr "Introdução"

msgid ""
":mod:`!optparse` is a more convenient, flexible, and powerful library for "
"parsing command-line options than the minimalist :mod:`getopt` module. :mod:"
"`!optparse` uses a more declarative style of command-line parsing: you "
"create an instance of :class:`OptionParser`, populate it with options, and "
"parse the command line. :mod:`!optparse` allows users to specify options in "
"the conventional GNU/POSIX syntax, and additionally generates usage and help "
"messages for you."
msgstr ""

msgid "Here's an example of using :mod:`!optparse` in a simple script::"
msgstr ""

msgid ""
"from optparse import OptionParser\n"
"...\n"
"parser = OptionParser()\n"
"parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n"
"                  help=\"write report to FILE\", metavar=\"FILE\")\n"
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_false\", dest=\"verbose\", default=True,\n"
"                  help=\"don't print status messages to stdout\")\n"
"\n"
"(options, args) = parser.parse_args()"
msgstr ""
"from optparse import OptionParser\n"
"...\n"
"parser = OptionParser()\n"
"parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n"
"                  help=\"escrever relatório para FICHEIRO\", "
"metavar=\"FICHEIRO\")\n"
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_false\", dest=\"verbose\", default=True,\n"
"                  help=\"não imprimir mensagens de estado para stdout\")\n"
"\n"
"(options, args) = parser.parse_args()"

msgid ""
"With these few lines of code, users of your script can now do the \"usual "
"thing\" on the command-line, for example::"
msgstr ""
"Com estas poucas linhas de código, os utilizadores do seu script podem agora "
"fazer o \"usual\" na linha de comandos, por exemplo::"

msgid "<yourscript> --file=outfile -q"
msgstr "<oseuscript> --file=ficheirosaida -q"

msgid ""
"As it parses the command line, :mod:`!optparse` sets attributes of the "
"``options`` object returned by :meth:`~OptionParser.parse_args` based on "
"user-supplied command-line values.  When :meth:`~OptionParser.parse_args` "
"returns from parsing this command line, ``options.filename`` will be "
"``\"outfile\"`` and ``options.verbose`` will be ``False``.  :mod:`!optparse` "
"supports both long and short options, allows short options to be merged "
"together, and allows options to be associated with their arguments in a "
"variety of ways.  Thus, the following command lines are all equivalent to "
"the above example::"
msgstr ""

msgid ""
"<yourscript> -f outfile --quiet\n"
"<yourscript> --quiet --file outfile\n"
"<yourscript> -q -foutfile\n"
"<yourscript> -qfoutfile"
msgstr ""
"<oseuscript> -f ficheirosaida --quiet\n"
"<oseuscript> --quiet --file ficheirosaida\n"
"<oseuscript> -q -fficheirosaida\n"
"<oseuscript> -qfficheirosaida"

msgid "Additionally, users can run one of the following ::"
msgstr "Adicionalmente, os utilizadores podem executar um dos seguintes ::"

msgid ""
"<yourscript> -h\n"
"<yourscript> --help"
msgstr ""
"<oseuscript> -h\n"
"<oseuscript> --help"

msgid ""
"and :mod:`!optparse` will print out a brief summary of your script's options:"
msgstr ""

msgid ""
"Usage: <yourscript> [options]\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -f FILE, --file=FILE  write report to FILE\n"
"  -q, --quiet           don't print status messages to stdout"
msgstr ""
"Utilização: <oseuscript> [opções]\n"
"\n"
"Opções:\n"
"  -h, --help            mostrar esta mensagem de ajuda e sair\n"
"  -f FICHEIRO, --file=FICHEIRO  escrever relatório para FICHEIRO\n"
"  -q, --quiet           não imprimir mensagens de estado para stdout"

msgid ""
"where the value of *yourscript* is determined at runtime (normally from "
"``sys.argv[0]``)."
msgstr ""
"onde o valor de *oseuscript* é determinado em tempo de execução (normalmente "
"a partir de ``sys.argv[0]``)."

msgid "Background"
msgstr "Contexto"

msgid ""
":mod:`!optparse` was explicitly designed to encourage the creation of "
"programs with straightforward command-line interfaces that follow the "
"conventions established by the :c:func:`!getopt` family of functions "
"available to C developers. To that end, it supports only the most common "
"command-line syntax and semantics conventionally used under Unix.  If you "
"are unfamiliar with these conventions, reading this section will allow you "
"to acquaint yourself with them."
msgstr ""

msgid "Terminology"
msgstr "Terminologia"

msgid "argument"
msgstr "argumento"

msgid ""
"a string entered on the command-line, and passed by the shell to ``execl()`` "
"or ``execv()``.  In Python, arguments are elements of ``sys.argv[1:]`` "
"(``sys.argv[0]`` is the name of the program being executed).  Unix shells "
"also use the term \"word\"."
msgstr ""
"uma string introduzida na linha de comandos e passada pela shell para "
"``execl()`` ou ``execv()``. Em Python, os argumentos são elementos de ``sys."
"argv[1:]`` (``sys.argv[0]`` é o nome do programa a ser executado). As shells "
"Unix também usam o termo \"palavra\"."

msgid ""
"It is occasionally desirable to substitute an argument list other than ``sys."
"argv[1:]``, so you should read \"argument\" as \"an element of ``sys."
"argv[1:]``, or of some other list provided as a substitute for ``sys."
"argv[1:]``\"."
msgstr ""
"É ocasionalmente desejável substituir uma lista de argumentos diferente de "
"``sys.argv[1:]``, por isso deve ler \"argumento\" como \"um elemento de "
"``sys.argv[1:]``, ou de alguma outra lista fornecida como substituto para "
"``sys.argv[1:]``\"."

msgid "option"
msgstr "opção"

msgid ""
"an argument used to supply extra information to guide or customize the "
"execution of a program.  There are many different syntaxes for options; the "
"traditional Unix syntax is a hyphen (\"-\") followed by a single letter, e."
"g. ``-x`` or ``-F``.  Also, traditional Unix syntax allows multiple options "
"to be merged into a single argument, e.g. ``-x -F`` is equivalent to ``-"
"xF``.  The GNU project introduced ``--`` followed by a series of hyphen-"
"separated words, e.g. ``--file`` or ``--dry-run``.  These are the only two "
"option syntaxes provided by :mod:`!optparse`."
msgstr ""

msgid "Some other option syntaxes that the world has seen include:"
msgstr "Algumas outras sintaxes de opções que o mundo já viu incluem:"

msgid ""
"a hyphen followed by a few letters, e.g. ``-pf`` (this is *not* the same as "
"multiple options merged into a single argument)"
msgstr ""
"um hífen seguido de algumas letras, por exemplo, ``-pf`` (isto *não* é o "
"mesmo que várias opções fundidas num único argumento)"

msgid ""
"a hyphen followed by a whole word, e.g. ``-file`` (this is technically "
"equivalent to the previous syntax, but they aren't usually seen in the same "
"program)"
msgstr ""
"um hífen seguido de uma palavra inteira, por exemplo, ``-file`` (isto é "
"tecnicamente equivalente à sintaxe anterior, mas geralmente não são vistas "
"no mesmo programa)"

msgid ""
"a plus sign followed by a single letter, or a few letters, or a word, e.g. "
"``+f``, ``+rgb``"
msgstr ""
"um sinal de mais seguido de uma letra única, ou algumas letras, ou uma "
"palavra, por exemplo, ``+f``, ``+rgb``"

msgid ""
"a slash followed by a letter, or a few letters, or a word, e.g. ``/f``, ``/"
"file``"
msgstr ""
"uma barra seguida de uma letra, ou algumas letras, ou uma palavra, por "
"exemplo, ``/f``, ``/file``"

msgid ""
"These option syntaxes are not supported by :mod:`!optparse`, and they never "
"will be.  This is deliberate: the first three are non-standard on any "
"environment, and the last only makes sense if you're exclusively targeting "
"Windows or certain legacy platforms (e.g. VMS, MS-DOS)."
msgstr ""

msgid "option argument"
msgstr "argumento de opção"

msgid ""
"an argument that follows an option, is closely associated with that option, "
"and is consumed from the argument list when that option is. With :mod:`!"
"optparse`, option arguments may either be in a separate argument from their "
"option:"
msgstr ""

msgid ""
"-f foo\n"
"--file foo"
msgstr ""
"-f ficheiro\n"
"--file ficheiro"

msgid "or included in the same argument:"
msgstr "ou incluído no mesmo argumento:"

msgid ""
"-ffoo\n"
"--file=foo"
msgstr ""
"-fficheiro\n"
"--file=ficheiro"

msgid ""
"Typically, a given option either takes an argument or it doesn't. Lots of "
"people want an \"optional option arguments\" feature, meaning that some "
"options will take an argument if they see it, and won't if they don't.  This "
"is somewhat controversial, because it makes parsing ambiguous: if ``-a`` "
"takes an optional argument and ``-b`` is another option entirely, how do we "
"interpret ``-ab``?  Because of this ambiguity, :mod:`!optparse` does not "
"support this feature."
msgstr ""

msgid "positional argument"
msgstr "argumento posicional"

msgid ""
"something leftover in the argument list after options have been parsed, i.e. "
"after options and their arguments have been parsed and removed from the "
"argument list."
msgstr ""
"algo que resta na lista de argumentos após as opções terem sido analisadas, "
"ou seja, após as opções e os seus argumentos terem sido analisados e "
"removidos da lista de argumentos."

msgid "required option"
msgstr "opção obrigatória"

msgid ""
"an option that must be supplied on the command-line; note that the phrase "
"\"required option\" is self-contradictory in English.  :mod:`!optparse` "
"doesn't prevent you from implementing required options, but doesn't give you "
"much help at it either."
msgstr ""

msgid "For example, consider this hypothetical command-line::"
msgstr "Por exemplo, considere esta linha de comandos hipotética::"

msgid "prog -v --report report.txt foo bar"
msgstr "prog -v --report relatorio.txt foo bar"

msgid ""
"``-v`` and ``--report`` are both options.  Assuming that ``--report`` takes "
"one argument, ``report.txt`` is an option argument.  ``foo`` and ``bar`` are "
"positional arguments."
msgstr ""
"``-v`` e ``--report`` são ambas opções. Assumindo que ``--report`` aceita um "
"argumento, ``report.txt`` é um argumento de opção. ``foo`` e ``bar`` são "
"argumentos posicionais."

msgid "What are options for?"
msgstr "Para que servem as opções?"

msgid ""
"Options are used to provide extra information to tune or customize the "
"execution of a program.  In case it wasn't clear, options are usually "
"*optional*.  A program should be able to run just fine with no options "
"whatsoever.  (Pick a random program from the Unix or GNU toolsets.  Can it "
"run without any options at all and still make sense?  The main exceptions "
"are ``find``, ``tar``, and ``dd``\\ ---all of which are mutant oddballs that "
"have been rightly criticized for their non-standard syntax and confusing "
"interfaces.)"
msgstr ""
"As opções são usadas para fornecer informações extra para ajustar ou "
"personalizar a execução de um programa. Caso não esteja claro, as opções são "
"geralmente *opcionais*. Um programa deve ser capaz de funcionar "
"perfeitamente bem sem quaisquer opções. (Escolha um programa aleatório dos "
"conjuntos de ferramentas Unix ou GNU. Pode executar sem quaisquer opções e "
"ainda assim fazer sentido? As principais exceções são ``find``, ``tar`` e "
"``dd`` --- todos eles são casos estranhos mutantes que foram criticados com "
"razão pela sua sintaxe não padrão e interfaces confusas.)"

msgid ""
"Lots of people want their programs to have \"required options\".  Think "
"about it. If it's required, then it's *not optional*!  If there is a piece "
"of information that your program absolutely requires in order to run "
"successfully, that's what positional arguments are for."
msgstr ""
"Muitas pessoas querem que os seus programas tenham \"opções obrigatórias\". "
"Pense nisso. Se é obrigatório, então não é *opcional*! Se houver uma peça de "
"informação que o seu programa necessita absolutamente para executar com "
"sucesso, é para isso que servem os argumentos posicionais."

msgid ""
"As an example of good command-line interface design, consider the humble "
"``cp`` utility, for copying files.  It doesn't make much sense to try to "
"copy files without supplying a destination and at least one source. Hence, "
"``cp`` fails if you run it with no arguments.  However, it has a flexible, "
"useful syntax that does not require any options at all::"
msgstr ""
"Como exemplo de um bom design de interface de linha de comandos, considere a "
"utilidade humilde ``cp``, para copiar ficheiros. Não faz muito sentido "
"tentar copiar ficheiros sem fornecer um destino e pelo menos uma origem. "
"Portanto, ``cp`` falha se o executar sem argumentos. No entanto, tem uma "
"sintaxe flexível e útil que não requer quaisquer opções::"

msgid ""
"cp SOURCE DEST\n"
"cp SOURCE ... DEST-DIR"
msgstr ""
"cp ORIGEM DEST\n"
"cp ORIGEM ... DIRETORIO-DEST"

msgid ""
"You can get pretty far with just that.  Most ``cp`` implementations provide "
"a bunch of options to tweak exactly how the files are copied: you can "
"preserve mode and modification time, avoid following symlinks, ask before "
"clobbering existing files, etc.  But none of this distracts from the core "
"mission of ``cp``, which is to copy either one file to another, or several "
"files to another directory."
msgstr ""
"Pode chegar longe apenas com isso. A maioria das implementações de ``cp`` "
"fornece um conjunto de opções para ajustar exatamente como os ficheiros são "
"copiados: pode preservar o modo e a hora de modificação, evitar seguir "
"ligações simbólicas, perguntar antes de sobrescrever ficheiros existentes, "
"etc. Mas nada disto distraí da missão principal do ``cp``, que é copiar um "
"ficheiro para outro, ou vários ficheiros para outro diretório."

msgid "What are positional arguments for?"
msgstr "Para que servem os argumentos posicionais?"

msgid ""
"Positional arguments are for those pieces of information that your program "
"absolutely, positively requires to run."
msgstr ""
"Os argumentos posicionais são para aquelas peças de informação que o seu "
"programa absolutamente precisa para executar."

msgid ""
"A good user interface should have as few absolute requirements as possible.  "
"If your program requires 17 distinct pieces of information in order to run "
"successfully, it doesn't much matter *how* you get that information from the "
"user---most people will give up and walk away before they successfully run "
"the program.  This applies whether the user interface is a command-line, a "
"configuration file, or a GUI: if you make that many demands on your users, "
"most of them will simply give up."
msgstr ""
"Uma boa interface de utilizador deve ter o menor número possível de "
"requisitos absolutos. Se o seu programa requer 17 peças distintas de "
"informação para executar com sucesso, não importa muito *como* obtém essa "
"informação do utilizador --- a maioria das pessoas desistirá antes de "
"executar o programa com sucesso. Isto aplica-se quer a interface de "
"utilizador seja uma linha de comandos, um ficheiro de configuração ou uma "
"GUI: se fizer tantas exigências aos seus utilizadores, a maioria deles "
"simplesmente desistirá."

msgid ""
"In short, try to minimize the amount of information that users are "
"absolutely required to supply---use sensible defaults whenever possible.  Of "
"course, you also want to make your programs reasonably flexible.  That's "
"what options are for.  Again, it doesn't matter if they are entries in a "
"config file, widgets in the \"Preferences\" dialog of a GUI, or command-line "
"options---the more options you implement, the more flexible your program is, "
"and the more complicated its implementation becomes.  Too much flexibility "
"has drawbacks as well, of course; too many options can overwhelm users and "
"make your code much harder to maintain."
msgstr ""
"Em resumo, tente minimizar a quantidade de informação que os utilizadores "
"são obrigados a fornecer --- use valores predefinidos sensatos sempre que "
"possível. Claro que também quer tornar os seus programas razoavelmente "
"flexíveis. É para isso que servem as opções. Mais uma vez, não importa se "
"são entradas num ficheiro de configuração, widgets na caixa de diálogo "
"\"Preferências\" de uma GUI ou opções de linha de comandos --- quanto mais "
"opções implementar, mais flexível será o seu programa e mais complicada se "
"tornará a sua implementação. Claro que, flexibilidade a mais também tem "
"desvantagens; demasiadas opções podem sobrecarregar os utilizadores e tornar "
"o seu código muito mais difícil de manter."

msgid "Tutorial"
msgstr "Tutorial"

msgid ""
"While :mod:`!optparse` is quite flexible and powerful, it's also "
"straightforward to use in most cases.  This section covers the code patterns "
"that are common to any :mod:`!optparse`\\ -based program."
msgstr ""

msgid ""
"First, you need to import the OptionParser class; then, early in the main "
"program, create an OptionParser instance::"
msgstr ""
"Primeiro, precisa de importar a classe OptionParser; depois, no início do "
"programa principal, crie uma instância de OptionParser::"

msgid ""
"from optparse import OptionParser\n"
"...\n"
"parser = OptionParser()"
msgstr ""
"from optparse import OptionParser\n"
"...\n"
"parser = OptionParser()"

msgid "Then you can start defining options.  The basic syntax is::"
msgstr "Depois pode começar a definir opções. A sintaxe básica é::"

msgid ""
"parser.add_option(opt_str, ...,\n"
"                  attr=value, ...)"
msgstr ""
"parser.add_option(opt_str, ...,\n"
"                  attr=valor, ...)"

msgid ""
"Each option has one or more option strings, such as ``-f`` or ``--file``, "
"and several option attributes that tell :mod:`!optparse` what to expect and "
"what to do when it encounters that option on the command line."
msgstr ""

msgid ""
"Typically, each option will have one short option string and one long option "
"string, e.g.::"
msgstr ""
"Tipicamente, cada opção terá uma string de opção curta e uma string de opção "
"longa, por exemplo::"

msgid "parser.add_option(\"-f\", \"--file\", ...)"
msgstr "parser.add_option(\"-f\", \"--file\", ...)"

msgid ""
"You're free to define as many short option strings and as many long option "
"strings as you like (including zero), as long as there is at least one "
"option string overall."
msgstr ""
"Pode definir quantas strings de opção curtas e longas quiser (incluindo "
"zero), desde que haja pelo menos uma string de opção no total."

msgid ""
"The option strings passed to :meth:`OptionParser.add_option` are effectively "
"labels for the option defined by that call.  For brevity, we will frequently "
"refer to *encountering an option* on the command line; in reality, :mod:`!"
"optparse` encounters *option strings* and looks up options from them."
msgstr ""

msgid ""
"Once all of your options are defined, instruct :mod:`!optparse` to parse "
"your program's command line::"
msgstr ""

msgid "(options, args) = parser.parse_args()"
msgstr "(options, args) = parser.parse_args()"

msgid ""
"(If you like, you can pass a custom argument list to :meth:`~OptionParser."
"parse_args`, but that's rarely necessary: by default it uses ``sys."
"argv[1:]``.)"
msgstr ""
"(Se quiser, pode passar uma lista de argumentos personalizada para :meth:"
"`~OptionParser.parse_args`, mas isso é raramente necessário: por "
"predefinição, usa ``sys.argv[1:]``.)"

msgid ":meth:`~OptionParser.parse_args` returns two values:"
msgstr ":meth:`~OptionParser.parse_args` retorna dois valores:"

msgid ""
"``options``, an object containing values for all of your options---e.g. if "
"``--file`` takes a single string argument, then ``options.file`` will be the "
"filename supplied by the user, or ``None`` if the user did not supply that "
"option"
msgstr ""
"``options``, um objeto contendo valores para todas as suas opções --- por "
"exemplo, se ``--file`` aceita um argumento de string único, então ``options."
"file`` será o nome do ficheiro fornecido pelo utilizador, ou ``None`` se o "
"utilizador não forneceu essa opção"

msgid ""
"``args``, the list of positional arguments leftover after parsing options"
msgstr ""
"``args``, a lista de argumentos posicionais restantes após a análise das "
"opções"

msgid ""
"This tutorial section only covers the four most important option "
"attributes: :attr:`~Option.action`, :attr:`~Option.type`, :attr:`~Option."
"dest` (destination), and :attr:`~Option.help`. Of these, :attr:`~Option."
"action` is the most fundamental."
msgstr ""
"Esta secção do tutorial abrange apenas os quatro atributos de opção mais "
"importantes: :attr:`~Option.action`, :attr:`~Option.type`, :attr:`~Option."
"dest` (destino) e :attr:`~Option.help`. Destes, :attr:`~Option.action` é o "
"mais fundamental."

msgid "Understanding option actions"
msgstr "Compreender as ações de opção"

msgid ""
"Actions tell :mod:`!optparse` what to do when it encounters an option on the "
"command line.  There is a fixed set of actions hard-coded into :mod:`!"
"optparse`; adding new actions is an advanced topic covered in section :ref:"
"`optparse-extending-optparse`.  Most actions tell :mod:`!optparse` to store "
"a value in some variable---for example, take a string from the command line "
"and store it in an attribute of ``options``."
msgstr ""

msgid ""
"If you don't specify an option action, :mod:`!optparse` defaults to "
"``store``."
msgstr ""

msgid "The store action"
msgstr "A ação de armazenamento"

msgid ""
"The most common option action is ``store``, which tells :mod:`!optparse` to "
"take the next argument (or the remainder of the current argument), ensure "
"that it is of the correct type, and store it to your chosen destination."
msgstr ""

msgid "For example::"
msgstr "Por exemplo::"

msgid ""
"parser.add_option(\"-f\", \"--file\",\n"
"                  action=\"store\", type=\"string\", dest=\"filename\")"
msgstr ""
"parser.add_option(\"-f\", \"--file\",\n"
"                  action=\"store\", type=\"string\", dest=\"filename\")"

msgid ""
"Now let's make up a fake command line and ask :mod:`!optparse` to parse it::"
msgstr ""

msgid ""
"args = [\"-f\", \"foo.txt\"]\n"
"(options, args) = parser.parse_args(args)"
msgstr ""
"args = [\"-f\", \"foo.txt\"]\n"
"(options, args) = parser.parse_args(args)"

msgid ""
"When :mod:`!optparse` sees the option string ``-f``, it consumes the next "
"argument, ``foo.txt``, and stores it in ``options.filename``.  So, after "
"this call to :meth:`~OptionParser.parse_args`, ``options.filename`` is "
"``\"foo.txt\"``."
msgstr ""

msgid ""
"Some other option types supported by :mod:`!optparse` are ``int`` and "
"``float``. Here's an option that expects an integer argument::"
msgstr ""

msgid "parser.add_option(\"-n\", type=\"int\", dest=\"num\")"
msgstr "parser.add_option(\"-n\", type=\"int\", dest=\"num\")"

msgid ""
"Note that this option has no long option string, which is perfectly "
"acceptable. Also, there's no explicit action, since the default is ``store``."
msgstr ""
"Note que esta opção não tem uma string de opção longa, o que é perfeitamente "
"aceitável. Além disso, não há uma ação explícita, uma vez que a predefinição "
"é ``store``."

msgid ""
"Let's parse another fake command-line.  This time, we'll jam the option "
"argument right up against the option: since ``-n42`` (one argument) is "
"equivalent to ``-n 42`` (two arguments), the code ::"
msgstr ""
"Vamos analisar outra linha de comandos falsa. Desta vez, vamos juntar o "
"argumento da opção à opção: uma vez que ``-n42`` (um argumento) é "
"equivalente a ``-n 42`` (dois argumentos), o código ::"

msgid ""
"(options, args) = parser.parse_args([\"-n42\"])\n"
"print(options.num)"
msgstr ""
"(options, args) = parser.parse_args([\"-n42\"])\n"
"print(options.num)"

msgid "will print ``42``."
msgstr "imprimirá ``42``."

msgid ""
"If you don't specify a type, :mod:`!optparse` assumes ``string``.  Combined "
"with the fact that the default action is ``store``, that means our first "
"example can be a lot shorter::"
msgstr ""

msgid "parser.add_option(\"-f\", \"--file\", dest=\"filename\")"
msgstr "parser.add_option(\"-f\", \"--file\", dest=\"filename\")"

msgid ""
"If you don't supply a destination, :mod:`!optparse` figures out a sensible "
"default from the option strings: if the first long option string is ``--foo-"
"bar``, then the default destination is ``foo_bar``.  If there are no long "
"option strings, :mod:`!optparse` looks at the first short option string: the "
"default destination for ``-f`` is ``f``."
msgstr ""

msgid ""
":mod:`!optparse` also includes the built-in ``complex`` type.  Adding types "
"is covered in section :ref:`optparse-extending-optparse`."
msgstr ""

msgid "Handling boolean (flag) options"
msgstr "Manipular opções booleanas (flags)"

msgid ""
"Flag options---set a variable to true or false when a particular option is "
"seen---are quite common.  :mod:`!optparse` supports them with two separate "
"actions, ``store_true`` and ``store_false``.  For example, you might have a "
"``verbose`` flag that is turned on with ``-v`` and off with ``-q``::"
msgstr ""

msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\")\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\")"
msgstr ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\")\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\")"

msgid ""
"Here we have two different options with the same destination, which is "
"perfectly OK.  (It just means you have to be a bit careful when setting "
"default values---see below.)"
msgstr ""
"Aqui temos duas opções diferentes com o mesmo destino, o que é perfeitamente "
"aceitável. (Isso apenas significa que tem de ter algum cuidado ao definir "
"valores predefinidos --- veja abaixo.)"

msgid ""
"When :mod:`!optparse` encounters ``-v`` on the command line, it sets "
"``options.verbose`` to ``True``; when it encounters ``-q``, ``options."
"verbose`` is set to ``False``."
msgstr ""

msgid "Other actions"
msgstr "Outras ações"

msgid "Some other actions supported by :mod:`!optparse` are:"
msgstr ""

msgid "``\"store_const\"``"
msgstr "``\"store_const\"``"

msgid "store a constant value, pre-set via :attr:`Option.const`"
msgstr "armazenar um valor constante, pré-definido via :attr:`Option.const`"

msgid "``\"append\"``"
msgstr "``\"append\"``"

msgid "append this option's argument to a list"
msgstr "anexar o argumento desta opção a uma lista"

msgid "``\"count\"``"
msgstr "``\"count\"``"

msgid "increment a counter by one"
msgstr "incrementar um contador em um"

msgid "``\"callback\"``"
msgstr "``\"callback\"``"

msgid "call a specified function"
msgstr "chamar uma função especificada"

msgid ""
"These are covered in section :ref:`optparse-reference-guide`, and section :"
"ref:`optparse-option-callbacks`."
msgstr ""
"Estas são abordadas na secção :ref:`optparse-reference-guide` e na secção :"
"ref:`optparse-option-callbacks`."

msgid "Default values"
msgstr "Valores predefinidos"

msgid ""
"All of the above examples involve setting some variable (the "
"\"destination\") when certain command-line options are seen.  What happens "
"if those options are never seen?  Since we didn't supply any defaults, they "
"are all set to ``None``.  This is usually fine, but sometimes you want more "
"control.  :mod:`!optparse` lets you supply a default value for each "
"destination, which is assigned before the command line is parsed."
msgstr ""

msgid ""
"First, consider the verbose/quiet example.  If we want :mod:`!optparse` to "
"set ``verbose`` to ``True`` unless ``-q`` is seen, then we can do this::"
msgstr ""

msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\", "
"default=True)\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\")"
msgstr ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\", "
"default=True)\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\")"

msgid ""
"Since default values apply to the *destination* rather than to any "
"particular option, and these two options happen to have the same "
"destination, this is exactly equivalent::"
msgstr ""
"Uma vez que os valores predefinidos se aplicam ao *destino* em vez de a "
"qualquer opção particular, e estas duas opções acontecem ter o mesmo "
"destino, isto é exatamente equivalente::"

msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\")\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\", "
"default=True)"
msgstr ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\")\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\", "
"default=True)"

msgid "Consider this::"
msgstr "Considere isto::"

msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\", "
"default=False)\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\", "
"default=True)"
msgstr ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\", "
"default=False)\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\", "
"default=True)"

msgid ""
"Again, the default value for ``verbose`` will be ``True``: the last default "
"value supplied for any particular destination is the one that counts."
msgstr ""
"Mais uma vez, o valor predefinido para ``verbose`` será ``True``: o último "
"valor predefinido fornecido para qualquer destino particular é o que conta."

msgid ""
"A clearer way to specify default values is the :meth:`set_defaults` method "
"of OptionParser, which you can call at any time before calling :meth:"
"`~OptionParser.parse_args`::"
msgstr ""
"Uma forma mais clara de especificar valores predefinidos é o método :meth:"
"`set_defaults` de OptionParser, que pode chamar a qualquer momento antes de "
"chamar :meth:`~OptionParser.parse_args`::"

msgid ""
"parser.set_defaults(verbose=True)\n"
"parser.add_option(...)\n"
"(options, args) = parser.parse_args()"
msgstr ""
"parser.set_defaults(verbose=True)\n"
"parser.add_option(...)\n"
"(options, args) = parser.parse_args()"

msgid ""
"As before, the last value specified for a given option destination is the "
"one that counts.  For clarity, try to use one method or the other of setting "
"default values, not both."
msgstr ""
"Como antes, o último valor especificado para um determinado destino de opção "
"é o que conta. Para clareza, tente usar um método ou outro para definir "
"valores predefinidos, não ambos."

msgid "Generating help"
msgstr "Gerar ajuda"

msgid ""
":mod:`!optparse`'s ability to generate help and usage text automatically is "
"useful for creating user-friendly command-line interfaces.  All you have to "
"do is supply a :attr:`~Option.help` value for each option, and optionally a "
"short usage message for your whole program.  Here's an OptionParser "
"populated with user-friendly (documented) options::"
msgstr ""

msgid ""
"usage = \"usage: %prog [options] arg1 arg2\"\n"
"parser = OptionParser(usage=usage)\n"
"parser.add_option(\"-v\", \"--verbose\",\n"
"                  action=\"store_true\", dest=\"verbose\", default=True,\n"
"                  help=\"make lots of noise [default]\")\n"
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_false\", dest=\"verbose\",\n"
"                  help=\"be vewwy quiet (I'm hunting wabbits)\")\n"
"parser.add_option(\"-f\", \"--filename\",\n"
"                  metavar=\"FILE\", help=\"write output to FILE\")\n"
"parser.add_option(\"-m\", \"--mode\",\n"
"                  default=\"intermediate\",\n"
"                  help=\"interaction mode: novice, intermediate, \"\n"
"                       \"or expert [default: %default]\")"
msgstr ""
"usage = \"utilização: %prog [opções] arg1 arg2\"\n"
"parser = OptionParser(usage=usage)\n"
"parser.add_option(\"-v\", \"--verbose\",\n"
"                  action=\"store_true\", dest=\"verbose\", default=True,\n"
"                  help=\"fazer muito barulho [predefinição]\")\n"
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_false\", dest=\"verbose\",\n"
"                  help=\"ser muito quieto (estou a caçar coelhos)\")\n"
"parser.add_option(\"-f\", \"--filename\",\n"
"                  metavar=\"FICHEIRO\", help=\"escrever saída para "
"FICHEIRO\")\n"
"parser.add_option(\"-m\", \"--mode\",\n"
"                  default=\"intermédio\",\n"
"                  help=\"modo de interação: principiante, intermédio, \"\n"
"                       \"ou experiente [predefinição: %default]\")"

msgid ""
"If :mod:`!optparse` encounters either ``-h`` or ``--help`` on the command-"
"line, or if you just call :meth:`parser.print_help`, it prints the following "
"to standard output:"
msgstr ""

msgid ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or\n"
"                        expert [default: intermediate]"
msgstr ""
"Utilização: <oseuscript> [opções] arg1 arg2\n"
"\n"
"Opções:\n"
"  -h, --help            mostrar esta mensagem de ajuda e sair\n"
"  -v, --verbose         fazer muito barulho [predefinição]\n"
"  -q, --quiet           ser muito quieto (estou a caçar coelhos)\n"
"  -f FICHEIRO, --filename=FICHEIRO\n"
"                        escrever saída para FICHEIRO\n"
"  -m MODO, --mode=MODO  modo de interação: principiante, intermédio, ou\n"
"                        experiente [predefinição: intermédio]"

msgid ""
"(If the help output is triggered by a help option, :mod:`!optparse` exits "
"after printing the help text.)"
msgstr ""

msgid ""
"There's a lot going on here to help :mod:`!optparse` generate the best "
"possible help message:"
msgstr ""

msgid "the script defines its own usage message::"
msgstr "o script define a sua própria mensagem de utilização::"

msgid "usage = \"usage: %prog [options] arg1 arg2\""
msgstr "usage = \"utilização: %prog [opções] arg1 arg2\""

msgid ""
":mod:`!optparse` expands ``%prog`` in the usage string to the name of the "
"current program, i.e. ``os.path.basename(sys.argv[0])``.  The expanded "
"string is then printed before the detailed option help."
msgstr ""

msgid ""
"If you don't supply a usage string, :mod:`!optparse` uses a bland but "
"sensible default: ``\"Usage: %prog [options]\"``, which is fine if your "
"script doesn't take any positional arguments."
msgstr ""

msgid ""
"every option defines a help string, and doesn't worry about line-wrapping---"
"\\ :mod:`!optparse` takes care of wrapping lines and making the help output "
"look good."
msgstr ""

msgid ""
"options that take a value indicate this fact in their automatically "
"generated help message, e.g. for the \"mode\" option::"
msgstr ""
"as opções que aceitam um valor indicam esse facto na sua mensagem de ajuda "
"gerada automaticamente, por exemplo, para a opção \"mode\"::"

msgid "-m MODE, --mode=MODE"
msgstr "-m MODO, --mode=MODO"

msgid ""
"Here, \"MODE\" is called the meta-variable: it stands for the argument that "
"the user is expected to supply to ``-m``/``--mode``.  By default, :mod:`!"
"optparse` converts the destination variable name to uppercase and uses that "
"for the meta-variable.  Sometimes, that's not what you want---for example, "
"the ``--filename`` option explicitly sets ``metavar=\"FILE\"``, resulting in "
"this automatically generated option description::"
msgstr ""

msgid "-f FILE, --filename=FILE"
msgstr "-f FICHEIRO, --filename=FICHEIRO"

msgid ""
"This is important for more than just saving space, though: the manually "
"written help text uses the meta-variable ``FILE`` to clue the user in that "
"there's a connection between the semi-formal syntax ``-f FILE`` and the "
"informal semantic description \"write output to FILE\". This is a simple but "
"effective way to make your help text a lot clearer and more useful for end "
"users."
msgstr ""
"Isto é importante para mais do que apenas poupar espaço: o texto de ajuda "
"escrito manualmente usa a meta-variável ``FILE`` para indicar ao utilizador "
"que existe uma ligação entre a sintaxe semi-formal ``-f FILE`` e a descrição "
"semântica informal \"escrever saída para FICHEIRO\". Esta é uma forma "
"simples mas eficaz de tornar o seu texto de ajuda muito mais claro e útil "
"para os utilizadores finais."

msgid ""
"options that have a default value can include ``%default`` in the help "
"string---\\ :mod:`!optparse` will replace it with :func:`str` of the "
"option's default value.  If an option has no default value (or the default "
"value is ``None``), ``%default`` expands to ``none``."
msgstr ""

msgid "Grouping Options"
msgstr "Agrupamento de Opções"

msgid ""
"When dealing with many options, it is convenient to group these options for "
"better help output.  An :class:`OptionParser` can contain several option "
"groups, each of which can contain several options."
msgstr ""
"Ao lidar com muitas opções, é conveniente agrupar estas opções para uma "
"melhor saída de ajuda. Um :class:`OptionParser` pode conter vários grupos de "
"opções, cada um dos quais pode conter várias opções."

msgid "An option group is obtained using the class :class:`OptionGroup`:"
msgstr "Um grupo de opções é obtido usando a classe :class:`OptionGroup`:"

msgid "where"
msgstr "onde"

msgid ""
"parser is the :class:`OptionParser` instance the group will be inserted in to"
msgstr ""
"parser é a instância :class:`OptionParser` na qual o grupo será inserido"

msgid "title is the group title"
msgstr "title é o título do grupo"

msgid "description, optional, is a long description of the group"
msgstr "description, opcional, é uma descrição longa do grupo"

msgid ""
":class:`OptionGroup` inherits from :class:`OptionContainer` (like :class:"
"`OptionParser`) and so the :meth:`add_option` method can be used to add an "
"option to the group."
msgstr ""
":class:`OptionGroup` herda de :class:`OptionContainer` (como :class:"
"`OptionParser`) e, portanto, o método :meth:`add_option` pode ser usado para "
"adicionar uma opção ao grupo."

msgid ""
"Once all the options are declared, using the :class:`OptionParser` method :"
"meth:`add_option_group` the group is added to the previously defined parser."
msgstr ""
"Depois de todas as opções serem declaradas, usando o método :meth:"
"`add_option_group` de :class:`OptionParser`, o grupo é adicionado ao "
"analisador definido anteriormente."

msgid ""
"Continuing with the parser defined in the previous section, adding an :class:"
"`OptionGroup` to a parser is easy::"
msgstr ""
"Continuando com o analisador definido na secção anterior, adicionar um :"
"class:`OptionGroup` a um analisador é fácil::"

msgid ""
"group = OptionGroup(parser, \"Dangerous Options\",\n"
"                    \"Caution: use these options at your own risk.  \"\n"
"                    \"It is believed that some of them bite.\")\n"
"group.add_option(\"-g\", action=\"store_true\", help=\"Group option.\")\n"
"parser.add_option_group(group)"
msgstr ""
"group = OptionGroup(parser, \"Opções Perigosas\",\n"
"                    \"Atenção: use estas opções por sua conta e risco.  \"\n"
"                    \"Acredita-se que algumas delas mordem.\")\n"
"group.add_option(\"-g\", action=\"store_true\", help=\"Opção de grupo.\")\n"
"parser.add_option_group(group)"

msgid "This would result in the following help output:"
msgstr "Isto resultaria na seguinte saída de ajuda:"

msgid ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or\n"
"                        expert [default: intermediate]\n"
"\n"
"  Dangerous Options:\n"
"    Caution: use these options at your own risk.  It is believed that some\n"
"    of them bite.\n"
"\n"
"    -g                  Group option."
msgstr ""
"Utilização: <oseuscript> [opções] arg1 arg2\n"
"\n"
"Opções:\n"
"  -h, --help            mostrar esta mensagem de ajuda e sair\n"
"  -v, --verbose         fazer muito barulho [predefinição]\n"
"  -q, --quiet           ser muito quieto (estou a caçar coelhos)\n"
"  -f FICHEIRO, --filename=FICHEIRO\n"
"                        escrever saída para FICHEIRO\n"
"  -m MODO, --mode=MODO  modo de interação: principiante, intermédio, ou\n"
"                        experiente [predefinição: intermédio]\n"
"\n"
"  Opções Perigosas:\n"
"    Atenção: use estas opções por sua conta e risco.  Acredita-se que "
"algumas\n"
"    delas mordem.\n"
"\n"
"    -g                  Opção de grupo."

msgid ""
"A bit more complete example might involve using more than one group: still "
"extending the previous example::"
msgstr ""
"Um exemplo um pouco mais completo pode envolver o uso de mais do que um "
"grupo: ainda estendendo o exemplo anterior::"

msgid ""
"group = OptionGroup(parser, \"Dangerous Options\",\n"
"                    \"Caution: use these options at your own risk.  \"\n"
"                    \"It is believed that some of them bite.\")\n"
"group.add_option(\"-g\", action=\"store_true\", help=\"Group option.\")\n"
"parser.add_option_group(group)\n"
"\n"
"group = OptionGroup(parser, \"Debug Options\")\n"
"group.add_option(\"-d\", \"--debug\", action=\"store_true\",\n"
"                 help=\"Print debug information\")\n"
"group.add_option(\"-s\", \"--sql\", action=\"store_true\",\n"
"                 help=\"Print all SQL statements executed\")\n"
"group.add_option(\"-e\", action=\"store_true\", help=\"Print every action "
"done\")\n"
"parser.add_option_group(group)"
msgstr ""
"group = OptionGroup(parser, \"Opções Perigosas\",\n"
"                    \"Atenção: use estas opções por sua conta e risco.  \"\n"
"                    \"Acredita-se que algumas delas mordem.\")\n"
"group.add_option(\"-g\", action=\"store_true\", help=\"Opção de grupo.\")\n"
"parser.add_option_group(group)\n"
"\n"
"group = OptionGroup(parser, \"Opções de Depuração\")\n"
"group.add_option(\"-d\", \"--debug\", action=\"store_true\",\n"
"                 help=\"Imprimir informações de depuração\")\n"
"group.add_option(\"-s\", \"--sql\", action=\"store_true\",\n"
"                 help=\"Imprimir todas as instruções SQL executadas\")\n"
"group.add_option(\"-e\", action=\"store_true\", help=\"Imprimir cada ação "
"feita\")\n"
"parser.add_option_group(group)"

msgid "that results in the following output:"
msgstr "que resulta na seguinte saída:"

msgid ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or expert\n"
"                        [default: intermediate]\n"
"\n"
"  Dangerous Options:\n"
"    Caution: use these options at your own risk.  It is believed that some\n"
"    of them bite.\n"
"\n"
"    -g                  Group option.\n"
"\n"
"  Debug Options:\n"
"    -d, --debug         Print debug information\n"
"    -s, --sql           Print all SQL statements executed\n"
"    -e                  Print every action done"
msgstr ""
"Utilização: <oseuscript> [opções] arg1 arg2\n"
"\n"
"Opções:\n"
"  -h, --help            mostrar esta mensagem de ajuda e sair\n"
"  -v, --verbose         fazer muito barulho [predefinição]\n"
"  -q, --quiet           ser muito quieto (estou a caçar coelhos)\n"
"  -f FICHEIRO, --filename=FICHEIRO\n"
"                        escrever saída para FICHEIRO\n"
"  -m MODO, --mode=MODO  modo de interação: principiante, intermédio, ou "
"experiente\n"
"                        [predefinição: intermédio]\n"
"\n"
"  Opções Perigosas:\n"
"    Atenção: use estas opções por sua conta e risco.  Acredita-se que "
"algumas\n"
"    delas mordem.\n"
"\n"
"    -g                  Opção de grupo.\n"
"\n"
"  Opções de Depuração:\n"
"    -d, --debug         Imprimir informações de depuração\n"
"    -s, --sql           Imprimir todas as instruções SQL executadas\n"
"    -e                  Imprimir cada ação feita"

msgid ""
"Another interesting method, in particular when working programmatically with "
"option groups is:"
msgstr ""
"Outro método interessante, em particular ao trabalhar programaticamente com "
"grupos de opções é:"

msgid ""
"Return the :class:`OptionGroup` to which the short or long option string "
"*opt_str* (e.g. ``'-o'`` or ``'--option'``) belongs. If there's no such :"
"class:`OptionGroup`, return ``None``."
msgstr ""
"Retorna o :class:`OptionGroup` ao qual a string de opção curta ou longa "
"*opt_str* (por exemplo, ``'-o'`` ou ``'--option'``) pertence. Se não existir "
"tal :class:`OptionGroup`, retorna ``None``."

msgid "Printing a version string"
msgstr "Imprimir uma string de versão"

msgid ""
"Similar to the brief usage string, :mod:`!optparse` can also print a version "
"string for your program.  You have to supply the string as the ``version`` "
"argument to OptionParser::"
msgstr ""

msgid "parser = OptionParser(usage=\"%prog [-f] [-q]\", version=\"%prog 1.0\")"
msgstr ""
"parser = OptionParser(usage=\"%prog [-f] [-q]\", version=\"%prog 1.0\")"

msgid ""
"``%prog`` is expanded just like it is in ``usage``.  Apart from that, "
"``version`` can contain anything you like.  When you supply it, :mod:`!"
"optparse` automatically adds a ``--version`` option to your parser. If it "
"encounters this option on the command line, it expands your ``version`` "
"string (by replacing ``%prog``), prints it to stdout, and exits."
msgstr ""

msgid "For example, if your script is called ``/usr/bin/foo``:"
msgstr "Por exemplo, se o seu script se chamar ``/usr/bin/foo``:"

msgid ""
"$ /usr/bin/foo --version\n"
"foo 1.0"
msgstr ""
"$ /usr/bin/foo --version\n"
"foo 1.0"

msgid ""
"The following two methods can be used to print and get the ``version`` "
"string:"
msgstr ""
"Os seguintes dois métodos podem ser usados para imprimir e obter a string "
"``version``:"

msgid ""
"Print the version message for the current program (``self.version``) to "
"*file* (default stdout).  As with :meth:`print_usage`, any occurrence of "
"``%prog`` in ``self.version`` is replaced with the name of the current "
"program.  Does nothing if ``self.version`` is empty or undefined."
msgstr ""
"Imprime a mensagem de versão para o programa atual (``self.version``) para "
"*file* (predefinição stdout). Tal como com :meth:`print_usage`, qualquer "
"ocorrência de ``%prog`` em ``self.version`` é substituída pelo nome do "
"programa atual. Não faz nada se ``self.version`` estiver vazio ou indefinido."

msgid ""
"Same as :meth:`print_version` but returns the version string instead of "
"printing it."
msgstr ""
"Semelhante a :meth:`print_version`, mas retorna a string de versão em vez de "
"a imprimir."

msgid "How :mod:`!optparse` handles errors"
msgstr ""

msgid ""
"There are two broad classes of errors that :mod:`!optparse` has to worry "
"about: programmer errors and user errors.  Programmer errors are usually "
"erroneous calls to :func:`OptionParser.add_option`, e.g. invalid option "
"strings, unknown option attributes, missing option attributes, etc.  These "
"are dealt with in the usual way: raise an exception (either :exc:`optparse."
"OptionError` or :exc:`TypeError`) and let the program crash."
msgstr ""

msgid ""
"Handling user errors is much more important, since they are guaranteed to "
"happen no matter how stable your code is.  :mod:`!optparse` can "
"automatically detect some user errors, such as bad option arguments (passing "
"``-n 4x`` where ``-n`` takes an integer argument), missing arguments (``-n`` "
"at the end of the command line, where ``-n`` takes an argument of any "
"type).  Also, you can call :func:`OptionParser.error` to signal an "
"application-defined error condition::"
msgstr ""

msgid ""
"(options, args) = parser.parse_args()\n"
"...\n"
"if options.a and options.b:\n"
"    parser.error(\"options -a and -b are mutually exclusive\")"
msgstr ""
"(options, args) = parser.parse_args()\n"
"...\n"
"if options.a and options.b:\n"
"    parser.error(\"as opções -a e -b são mutuamente exclusivas\")"

msgid ""
"In either case, :mod:`!optparse` handles the error the same way: it prints "
"the program's usage message and an error message to standard error and exits "
"with error status 2."
msgstr ""

msgid ""
"Consider the first example above, where the user passes ``4x`` to an option "
"that takes an integer:"
msgstr ""
"Considere o primeiro exemplo acima, onde o utilizador passa ``4x`` para uma "
"opção que aceita um inteiro:"

msgid ""
"$ /usr/bin/foo -n 4x\n"
"Usage: foo [options]\n"
"\n"
"foo: error: option -n: invalid integer value: '4x'"
msgstr ""
"$ /usr/bin/foo -n 4x\n"
"Utilização: foo [opções]\n"
"\n"
"foo: erro: opção -n: valor inteiro inválido: '4x'"

msgid "Or, where the user fails to pass a value at all:"
msgstr "Ou, onde o utilizador falha ao passar um valor:"

msgid ""
"$ /usr/bin/foo -n\n"
"Usage: foo [options]\n"
"\n"
"foo: error: -n option requires an argument"
msgstr ""
"$ /usr/bin/foo -n\n"
"Utilização: foo [opções]\n"
"\n"
"foo: erro: a opção -n requer um argumento"

msgid ""
":mod:`!optparse`\\ -generated error messages take care always to mention the "
"option involved in the error; be sure to do the same when calling :func:"
"`OptionParser.error` from your application code."
msgstr ""

msgid ""
"If :mod:`!optparse`'s default error-handling behaviour does not suit your "
"needs, you'll need to subclass OptionParser and override its :meth:"
"`~OptionParser.exit` and/or :meth:`~OptionParser.error` methods."
msgstr ""

msgid "Putting it all together"
msgstr "Juntando tudo"

msgid "Here's what :mod:`!optparse`\\ -based scripts usually look like::"
msgstr ""

msgid ""
"from optparse import OptionParser\n"
"...\n"
"def main():\n"
"    usage = \"usage: %prog [options] arg\"\n"
"    parser = OptionParser(usage)\n"
"    parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n"
"                      help=\"read data from FILENAME\")\n"
"    parser.add_option(\"-v\", \"--verbose\",\n"
"                      action=\"store_true\", dest=\"verbose\")\n"
"    parser.add_option(\"-q\", \"--quiet\",\n"
"                      action=\"store_false\", dest=\"verbose\")\n"
"    ...\n"
"    (options, args) = parser.parse_args()\n"
"    if len(args) != 1:\n"
"        parser.error(\"incorrect number of arguments\")\n"
"    if options.verbose:\n"
"        print(\"reading %s...\" % options.filename)\n"
"    ...\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"
msgstr ""
"from optparse import OptionParser\n"
"...\n"
"def main():\n"
"    usage = \"utilização: %prog [opções] arg\"\n"
"    parser = OptionParser(usage)\n"
"    parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n"
"                      help=\"ler dados de FICHEIRO\")\n"
"    parser.add_option(\"-v\", \"--verbose\",\n"
"                      action=\"store_true\", dest=\"verbose\")\n"
"    parser.add_option(\"-q\", \"--quiet\",\n"
"                      action=\"store_false\", dest=\"verbose\")\n"
"    ...\n"
"    (options, args) = parser.parse_args()\n"
"    if len(args) != 1:\n"
"        parser.error(\"número incorreto de argumentos\")\n"
"    if options.verbose:\n"
"        print(\"a ler %s...\" % options.filename)\n"
"    ...\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"

msgid "Reference Guide"
msgstr "Guia de Referência"

msgid "Creating the parser"
msgstr "Criar o analisador"

msgid ""
"The first step in using :mod:`!optparse` is to create an OptionParser "
"instance."
msgstr ""

msgid ""
"The OptionParser constructor has no required arguments, but a number of "
"optional keyword arguments.  You should always pass them as keyword "
"arguments, i.e. do not rely on the order in which the arguments are declared."
msgstr ""
"O construtor OptionParser não tem argumentos obrigatórios, mas vários "
"argumentos de palavra-chave opcionais. Deve sempre passá-los como argumentos "
"de palavra-chave, ou seja, não deve confiar na ordem em que os argumentos "
"são declarados."

msgid "``usage`` (default: ``\"%prog [options]\"``)"
msgstr "``usage`` (predefinição: ``\"%prog [options]\"``)"

msgid ""
"The usage summary to print when your program is run incorrectly or with a "
"help option.  When :mod:`!optparse` prints the usage string, it expands "
"``%prog`` to ``os.path.basename(sys.argv[0])`` (or to ``prog`` if you passed "
"that keyword argument).  To suppress a usage message, pass the special "
"value :const:`optparse.SUPPRESS_USAGE`."
msgstr ""

msgid "``option_list`` (default: ``[]``)"
msgstr "``option_list`` (predefinição: ``[]``)"

msgid ""
"A list of Option objects to populate the parser with.  The options in "
"``option_list`` are added after any options in ``standard_option_list`` (a "
"class attribute that may be set by OptionParser subclasses), but before any "
"version or help options. Deprecated; use :meth:`add_option` after creating "
"the parser instead."
msgstr ""
"Uma lista de objetos Option para preencher o analisador. As opções em "
"``option_list`` são adicionadas após quaisquer opções em "
"``standard_option_list`` (um atributo de classe que pode ser definido por "
"subclasses de OptionParser), mas antes de quaisquer opções de versão ou "
"ajuda. Obsoleto; use :meth:`add_option` após criar o analisador em vez disso."

msgid "``option_class`` (default: optparse.Option)"
msgstr "``option_class`` (predefinição: optparse.Option)"

msgid "Class to use when adding options to the parser in :meth:`add_option`."
msgstr "Classe a usar ao adicionar opções ao analisador em :meth:`add_option`."

msgid "``version`` (default: ``None``)"
msgstr "``version`` (predefinição: ``None``)"

msgid ""
"A version string to print when the user supplies a version option. If you "
"supply a true value for ``version``, :mod:`!optparse` automatically adds a "
"version option with the single option string ``--version``.  The substring "
"``%prog`` is expanded the same as for ``usage``."
msgstr ""

msgid "``conflict_handler`` (default: ``\"error\"``)"
msgstr "``conflict_handler`` (predefinição: ``\"error\"``)"

msgid ""
"Specifies what to do when options with conflicting option strings are added "
"to the parser; see section :ref:`optparse-conflicts-between-options`."
msgstr ""
"Especifica o que fazer quando opções com strings de opção conflitantes são "
"adicionadas ao analisador; veja a secção :ref:`optparse-conflicts-between-"
"options`."

msgid "``description`` (default: ``None``)"
msgstr "``description`` (predefinição: ``None``)"

msgid ""
"A paragraph of text giving a brief overview of your program. :mod:`!"
"optparse` reformats this paragraph to fit the current terminal width and "
"prints it when the user requests help (after ``usage``, but before the list "
"of options)."
msgstr ""

msgid "``formatter`` (default: a new :class:`IndentedHelpFormatter`)"
msgstr "``formatter`` (predefinição: um novo :class:`IndentedHelpFormatter`)"

msgid ""
"An instance of optparse.HelpFormatter that will be used for printing help "
"text.  :mod:`!optparse` provides two concrete classes for this purpose: "
"IndentedHelpFormatter and TitledHelpFormatter."
msgstr ""

msgid "``add_help_option`` (default: ``True``)"
msgstr "``add_help_option`` (predefinição: ``True``)"

msgid ""
"If true, :mod:`!optparse` will add a help option (with option strings ``-h`` "
"and ``--help``) to the parser."
msgstr ""

msgid "``prog``"
msgstr "``prog``"

msgid ""
"The string to use when expanding ``%prog`` in ``usage`` and ``version`` "
"instead of ``os.path.basename(sys.argv[0])``."
msgstr ""
"A string a usar ao expandir ``%prog`` em ``usage`` e ``version`` em vez de "
"``os.path.basename(sys.argv[0])``."

msgid "``epilog`` (default: ``None``)"
msgstr "``epilog`` (predefinição: ``None``)"

msgid "A paragraph of help text to print after the option help."
msgstr "Um parágrafo de texto de ajuda a imprimir após a ajuda das opções."

msgid "Populating the parser"
msgstr "Preencher o analisador"

msgid ""
"There are several ways to populate the parser with options.  The preferred "
"way is by using :meth:`OptionParser.add_option`, as shown in section :ref:"
"`optparse-tutorial`.  :meth:`add_option` can be called in one of two ways:"
msgstr ""
"Existem várias formas de preencher o analisador com opções. A forma "
"preferida é usando :meth:`OptionParser.add_option`, como mostrado na secção :"
"ref:`optparse-tutorial`. :meth:`add_option` pode ser chamado de duas formas:"

msgid "pass it an Option instance (as returned by :func:`make_option`)"
msgstr ""
"passar-lhe uma instância Option (como retornada por :func:`make_option`)"

msgid ""
"pass it any combination of positional and keyword arguments that are "
"acceptable to :func:`make_option` (i.e., to the Option constructor), and it "
"will create the Option instance for you"
msgstr ""
"passar-lhe qualquer combinação de argumentos posicionais e de palavra-chave "
"que sejam aceitáveis para :func:`make_option` (ou seja, para o construtor "
"Option), e ele criará a instância Option para si"

msgid ""
"The other alternative is to pass a list of pre-constructed Option instances "
"to the OptionParser constructor, as in::"
msgstr ""
"A outra alternativa é passar uma lista de instâncias Option pré-construídas "
"para o construtor OptionParser, como em::"

msgid ""
"option_list = [\n"
"    make_option(\"-f\", \"--filename\",\n"
"                action=\"store\", type=\"string\", dest=\"filename\"),\n"
"    make_option(\"-q\", \"--quiet\",\n"
"                action=\"store_false\", dest=\"verbose\"),\n"
"    ]\n"
"parser = OptionParser(option_list=option_list)"
msgstr ""
"option_list = [\n"
"    make_option(\"-f\", \"--filename\",\n"
"                action=\"store\", type=\"string\", dest=\"filename\"),\n"
"    make_option(\"-q\", \"--quiet\",\n"
"                action=\"store_false\", dest=\"verbose\"),\n"
"    ]\n"
"parser = OptionParser(option_list=option_list)"

msgid ""
"(:func:`make_option` is a factory function for creating Option instances; "
"currently it is an alias for the Option constructor.  A future version of :"
"mod:`!optparse` may split Option into several classes, and :func:"
"`make_option` will pick the right class to instantiate.  Do not instantiate "
"Option directly.)"
msgstr ""

msgid "Defining options"
msgstr "Definir opções"

msgid ""
"Each Option instance represents a set of synonymous command-line option "
"strings, e.g. ``-f`` and ``--file``.  You can specify any number of short or "
"long option strings, but you must specify at least one overall option string."
msgstr ""
"Cada instância Option representa um conjunto de strings de opção de linha de "
"comandos sinónimas, por exemplo, ``-f`` e ``--file``. Pode especificar "
"qualquer número de strings de opção curtas ou longas, mas deve especificar "
"pelo menos uma string de opção no total."

msgid ""
"The canonical way to create an :class:`Option` instance is with the :meth:"
"`add_option` method of :class:`OptionParser`."
msgstr ""
"A forma canónica de criar uma instância :class:`Option` é com o método :meth:"
"`add_option` de :class:`OptionParser`."

msgid "To define an option with only a short option string::"
msgstr "Para definir uma opção com apenas uma string de opção curta::"

msgid "parser.add_option(\"-f\", attr=value, ...)"
msgstr "parser.add_option(\"-f\", attr=valor, ...)"

msgid "And to define an option with only a long option string::"
msgstr "E para definir uma opção com apenas uma string de opção longa::"

msgid "parser.add_option(\"--foo\", attr=value, ...)"
msgstr "parser.add_option(\"--foo\", attr=valor, ...)"

msgid ""
"The keyword arguments define attributes of the new Option object.  The most "
"important option attribute is :attr:`~Option.action`, and it largely "
"determines which other attributes are relevant or required.  If you pass "
"irrelevant option attributes, or fail to pass required ones, :mod:`!"
"optparse` raises an :exc:`OptionError` exception explaining your mistake."
msgstr ""

msgid ""
"An option's *action* determines what :mod:`!optparse` does when it "
"encounters this option on the command-line.  The standard option actions "
"hard-coded into :mod:`!optparse` are:"
msgstr ""

msgid "``\"store\"``"
msgstr "``\"store\"``"

msgid "store this option's argument (default)"
msgstr "armazenar o argumento desta opção (predefinição)"

msgid "``\"store_true\"``"
msgstr "``\"store_true\"``"

msgid "store ``True``"
msgstr "armazenar ``True``"

msgid "``\"store_false\"``"
msgstr "``\"store_false\"``"

msgid "store ``False``"
msgstr "armazenar ``False``"

msgid "``\"append_const\"``"
msgstr "``\"append_const\"``"

msgid "append a constant value to a list, pre-set via :attr:`Option.const`"
msgstr ""
"anexar um valor constante a uma lista, pré-definido via :attr:`Option.const`"

msgid "``\"help\"``"
msgstr "``\"help\"``"

msgid ""
"print a usage message including all options and the documentation for them"
msgstr ""
"imprimir uma mensagem de utilização incluindo todas as opções e a "
"documentação para elas"

msgid ""
"(If you don't supply an action, the default is ``\"store\"``.  For this "
"action, you may also supply :attr:`~Option.type` and :attr:`~Option.dest` "
"option attributes; see :ref:`optparse-standard-option-actions`.)"
msgstr ""
"(Se não fornecer uma ação, a predefinição é ``\"store\"``. Para esta ação, "
"também pode fornecer os atributos de opção :attr:`~Option.type` e :attr:"
"`~Option.dest`; veja :ref:`optparse-standard-option-actions`.)"

msgid ""
"As you can see, most actions involve storing or updating a value somewhere. :"
"mod:`!optparse` always creates a special object for this, conventionally "
"called ``options``, which is an instance of :class:`optparse.Values`."
msgstr ""

msgid ""
"An object holding parsed argument names and values as attributes. Normally "
"created by calling when calling :meth:`OptionParser.parse_args`, and can be "
"overridden by a custom subclass passed to the *values* argument of :meth:"
"`OptionParser.parse_args` (as described in :ref:`optparse-parsing-"
"arguments`)."
msgstr ""
"Um objeto que contém nomes e valores de argumentos analisados como "
"atributos. Normalmente criado ao chamar :meth:`OptionParser.parse_args`, e "
"pode ser substituído por uma subclasse personalizada passada para o "
"argumento *values* de :meth:`OptionParser.parse_args` (como descrito em :ref:"
"`optparse-parsing-arguments`)."

msgid ""
"Option arguments (and various other values) are stored as attributes of this "
"object, according to the :attr:`~Option.dest` (destination) option attribute."
msgstr ""
"Os argumentos de opção (e vários outros valores) são armazenados como "
"atributos deste objeto, de acordo com o atributo de opção :attr:`~Option."
"dest` (destino)."

msgid "For example, when you call ::"
msgstr "Por exemplo, quando chama ::"

msgid "parser.parse_args()"
msgstr "parser.parse_args()"

msgid ""
"one of the first things :mod:`!optparse` does is create the ``options`` "
"object::"
msgstr ""

msgid "options = Values()"
msgstr "options = Values()"

msgid "If one of the options in this parser is defined with ::"
msgstr "Se uma das opções neste analisador for definida com ::"

msgid ""
"parser.add_option(\"-f\", \"--file\", action=\"store\", type=\"string\", "
"dest=\"filename\")"
msgstr ""
"parser.add_option(\"-f\", \"--file\", action=\"store\", type=\"string\", "
"dest=\"filename\")"

msgid "and the command-line being parsed includes any of the following::"
msgstr ""
"e a linha de comandos a ser analisada inclui qualquer um dos seguintes::"

msgid ""
"-ffoo\n"
"-f foo\n"
"--file=foo\n"
"--file foo"
msgstr ""
"-fficheiro\n"
"-f ficheiro\n"
"--file=ficheiro\n"
"--file ficheiro"

msgid ""
"then :mod:`!optparse`, on seeing this option, will do the equivalent of ::"
msgstr ""

msgid "options.filename = \"foo\""
msgstr "options.filename = \"ficheiro\""

msgid ""
"The :attr:`~Option.type` and :attr:`~Option.dest` option attributes are "
"almost as important as :attr:`~Option.action`, but :attr:`~Option.action` is "
"the only one that makes sense for *all* options."
msgstr ""
"Os atributos de opção :attr:`~Option.type` e :attr:`~Option.dest` são quase "
"tão importantes quanto :attr:`~Option.action`, mas :attr:`~Option.action` é "
"o único que faz sentido para *todas* as opções."

msgid "Option attributes"
msgstr "Atributos de opção"

msgid ""
"A single command line argument, with various attributes passed by keyword to "
"the constructor. Normally created with :meth:`OptionParser.add_option` "
"rather than directly, and can be overridden by a custom class via the "
"*option_class* argument to :class:`OptionParser`."
msgstr ""
"Um único argumento de linha de comandos, com vários atributos passados por "
"palavra-chave para o construtor. Normalmente criado com :meth:`OptionParser."
"add_option` em vez de diretamente, e pode ser substituído por uma classe "
"personalizada através do argumento *option_class* para :class:`OptionParser`."

msgid ""
"The following option attributes may be passed as keyword arguments to :meth:"
"`OptionParser.add_option`.  If you pass an option attribute that is not "
"relevant to a particular option, or fail to pass a required option "
"attribute, :mod:`!optparse` raises :exc:`OptionError`."
msgstr ""

msgid "(default: ``\"store\"``)"
msgstr "(predefinição: ``\"store\"``)"

msgid ""
"Determines :mod:`!optparse`'s behaviour when this option is seen on the "
"command line; the available options are documented :ref:`here <optparse-"
"standard-option-actions>`."
msgstr ""

msgid "(default: ``\"string\"``)"
msgstr "(predefinição: ``\"string\"``)"

msgid ""
"The argument type expected by this option (e.g., ``\"string\"`` or "
"``\"int\"``); the available option types are documented :ref:`here <optparse-"
"standard-option-types>`."
msgstr ""
"O tipo de argumento esperado por esta opção (por exemplo, ``\"string\"`` ou "
"``\"int\"``); os tipos de opção disponíveis estão documentados :ref:`aqui "
"<optparse-standard-option-types>`."

msgid "(default: derived from option strings)"
msgstr "(predefinição: derivado das strings de opção)"

msgid ""
"If the option's action implies writing or modifying a value somewhere, this "
"tells :mod:`!optparse` where to write it: :attr:`~Option.dest` names an "
"attribute of the ``options`` object that :mod:`!optparse` builds as it "
"parses the command line."
msgstr ""

msgid ""
"The value to use for this option's destination if the option is not seen on "
"the command line.  See also :meth:`OptionParser.set_defaults`."
msgstr ""
"O valor a usar para o destino desta opção se a opção não for vista na linha "
"de comandos. Veja também :meth:`OptionParser.set_defaults`."

msgid "(default: 1)"
msgstr "(predefinição: 1)"

msgid ""
"How many arguments of type :attr:`~Option.type` should be consumed when this "
"option is seen.  If > 1, :mod:`!optparse` will store a tuple of values to :"
"attr:`~Option.dest`."
msgstr ""

msgid "For actions that store a constant value, the constant value to store."
msgstr ""
"Para ações que armazenam um valor constante, o valor constante a armazenar."

msgid ""
"For options of type ``\"choice\"``, the list of strings the user may choose "
"from."
msgstr ""
"Para opções do tipo ``\"choice\"``, a lista de strings das quais o "
"utilizador pode escolher."

msgid ""
"For options with action ``\"callback\"``, the callable to call when this "
"option is seen.  See section :ref:`optparse-option-callbacks` for detail on "
"the arguments passed to the callable."
msgstr ""
"Para opções com a ação ``\"callback\"``, o objeto chamável a chamar quando "
"esta opção é vista. Veja a secção :ref:`optparse-option-callbacks` para "
"detalhes sobre os argumentos passados ao objeto chamável."

msgid ""
"Additional positional and keyword arguments to pass to ``callback`` after "
"the four standard callback arguments."
msgstr ""
"Argumentos posicionais e de palavra-chave adicionais a passar para "
"``callback`` após os quatro argumentos padrão de callback."

msgid ""
"Help text to print for this option when listing all available options after "
"the user supplies a :attr:`~Option.help` option (such as ``--help``).  If no "
"help text is supplied, the option will be listed without help text.  To hide "
"this option, use the special value :const:`optparse.SUPPRESS_HELP`."
msgstr ""
"Texto de ajuda a imprimir para esta opção ao listar todas as opções "
"disponíveis depois de o utilizador fornecer uma opção :attr:`~Option.help` "
"(como ``--help``). Se nenhum texto de ajuda for fornecido, a opção será "
"listada sem texto de ajuda. Para ocultar esta opção, use o valor especial :"
"const:`optparse.SUPPRESS_HELP`."

msgid ""
"Stand-in for the option argument(s) to use when printing help text.  See "
"section :ref:`optparse-tutorial` for an example."
msgstr ""
"Substituto para o(s) argumento(s) de opção a usar ao imprimir texto de "
"ajuda. Veja a secção :ref:`optparse-tutorial` para um exemplo."

msgid "Standard option actions"
msgstr "Ações de opção padrão"

msgid ""
"The various option actions all have slightly different requirements and "
"effects. Most actions have several relevant option attributes which you may "
"specify to guide :mod:`!optparse`'s behaviour; a few have required "
"attributes, which you must specify for any option using that action."
msgstr ""

msgid ""
"``\"store\"`` [relevant: :attr:`~Option.type`, :attr:`~Option.dest`, :attr:"
"`~Option.nargs`, :attr:`~Option.choices`]"
msgstr ""
"``\"store\"`` [relevante: :attr:`~Option.type`, :attr:`~Option.dest`, :attr:"
"`~Option.nargs`, :attr:`~Option.choices`]"

msgid ""
"The option must be followed by an argument, which is converted to a value "
"according to :attr:`~Option.type` and stored in :attr:`~Option.dest`.  If :"
"attr:`~Option.nargs` > 1, multiple arguments will be consumed from the "
"command line; all will be converted according to :attr:`~Option.type` and "
"stored to :attr:`~Option.dest` as a tuple.  See the :ref:`optparse-standard-"
"option-types` section."
msgstr ""
"A opção deve ser seguida por um argumento, que é convertido num valor de "
"acordo com :attr:`~Option.type` e armazenado em :attr:`~Option.dest`. Se :"
"attr:`~Option.nargs` > 1, vários argumentos serão consumidos da linha de "
"comandos; todos serão convertidos de acordo com :attr:`~Option.type` e "
"armazenados em :attr:`~Option.dest` como um tuplo. Veja a secção :ref:"
"`optparse-standard-option-types`."

msgid ""
"If :attr:`~Option.choices` is supplied (a list or tuple of strings), the "
"type defaults to ``\"choice\"``."
msgstr ""
"Se :attr:`~Option.choices` for fornecido (uma lista ou tuplo de strings), o "
"tipo predefinido é ``\"choice\"``."

msgid "If :attr:`~Option.type` is not supplied, it defaults to ``\"string\"``."
msgstr ""
"Se :attr:`~Option.type` não for fornecido, o predefinido é ``\"string\"``."

msgid ""
"If :attr:`~Option.dest` is not supplied, :mod:`!optparse` derives a "
"destination from the first long option string (e.g., ``--foo-bar`` implies "
"``foo_bar``). If there are no long option strings, :mod:`!optparse` derives "
"a destination from the first short option string (e.g., ``-f`` implies "
"``f``)."
msgstr ""

msgid "Example::"
msgstr "Exemplo::"

msgid ""
"parser.add_option(\"-f\")\n"
"parser.add_option(\"-p\", type=\"float\", nargs=3, dest=\"point\")"
msgstr ""
"parser.add_option(\"-f\")\n"
"parser.add_option(\"-p\", type=\"float\", nargs=3, dest=\"point\")"

msgid "As it parses the command line ::"
msgstr "À medida que analisa a linha de comandos ::"

msgid "-f foo.txt -p 1 -3.5 4 -fbar.txt"
msgstr "-f foo.txt -p 1 -3.5 4 -fbar.txt"

msgid ":mod:`!optparse` will set ::"
msgstr ""

msgid ""
"options.f = \"foo.txt\"\n"
"options.point = (1.0, -3.5, 4.0)\n"
"options.f = \"bar.txt\""
msgstr ""
"options.f = \"foo.txt\"\n"
"options.point = (1.0, -3.5, 4.0)\n"
"options.f = \"bar.txt\""

msgid ""
"``\"store_const\"`` [required: :attr:`~Option.const`; relevant: :attr:"
"`~Option.dest`]"
msgstr ""
"``\"store_const\"`` [necessário: :attr:`~Option.const`; relevante: :attr:"
"`~Option.dest`]"

msgid "The value :attr:`~Option.const` is stored in :attr:`~Option.dest`."
msgstr "O valor :attr:`~Option.const` é armazenado em :attr:`~Option.dest`."

msgid ""
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_const\", const=0, dest=\"verbose\")\n"
"parser.add_option(\"-v\", \"--verbose\",\n"
"                  action=\"store_const\", const=1, dest=\"verbose\")\n"
"parser.add_option(\"--noisy\",\n"
"                  action=\"store_const\", const=2, dest=\"verbose\")"
msgstr ""
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_const\", const=0, dest=\"verbose\")\n"
"parser.add_option(\"-v\", \"--verbose\",\n"
"                  action=\"store_const\", const=1, dest=\"verbose\")\n"
"parser.add_option(\"--noisy\",\n"
"                  action=\"store_const\", const=2, dest=\"verbose\")"

msgid "If ``--noisy`` is seen, :mod:`!optparse` will set  ::"
msgstr ""

msgid "options.verbose = 2"
msgstr "options.verbose = 2"

msgid "``\"store_true\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"store_true\"`` [relevante: :attr:`~Option.dest`]"

msgid ""
"A special case of ``\"store_const\"`` that stores ``True`` to :attr:`~Option."
"dest`."
msgstr ""
"Um caso especial de ``\"store_const\"`` que armazena ``True`` em :attr:"
"`~Option.dest`."

msgid "``\"store_false\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"store_false\"`` [relevante: :attr:`~Option.dest`]"

msgid "Like ``\"store_true\"``, but stores ``False``."
msgstr "Semelhante a ``\"store_true\"``, mas armazena ``False``."

msgid ""
"parser.add_option(\"--clobber\", action=\"store_true\", dest=\"clobber\")\n"
"parser.add_option(\"--no-clobber\", action=\"store_false\", dest=\"clobber\")"
msgstr ""
"parser.add_option(\"--clobber\", action=\"store_true\", dest=\"clobber\")\n"
"parser.add_option(\"--no-clobber\", action=\"store_false\", dest=\"clobber\")"

msgid ""
"``\"append\"`` [relevant: :attr:`~Option.type`, :attr:`~Option.dest`, :attr:"
"`~Option.nargs`, :attr:`~Option.choices`]"
msgstr ""
"``\"append\"`` [relevante: :attr:`~Option.type`, :attr:`~Option.dest`, :attr:"
"`~Option.nargs`, :attr:`~Option.choices`]"

msgid ""
"The option must be followed by an argument, which is appended to the list "
"in :attr:`~Option.dest`.  If no default value for :attr:`~Option.dest` is "
"supplied, an empty list is automatically created when :mod:`!optparse` first "
"encounters this option on the command-line.  If :attr:`~Option.nargs` > 1, "
"multiple arguments are consumed, and a tuple of length :attr:`~Option.nargs` "
"is appended to :attr:`~Option.dest`."
msgstr ""

msgid ""
"The defaults for :attr:`~Option.type` and :attr:`~Option.dest` are the same "
"as for the ``\"store\"`` action."
msgstr ""
"Os valores predefinidos para :attr:`~Option.type` e :attr:`~Option.dest` são "
"os mesmos que para a ação ``\"store\"``."

msgid ""
"parser.add_option(\"-t\", \"--tracks\", action=\"append\", type=\"int\")"
msgstr ""
"parser.add_option(\"-t\", \"--tracks\", action=\"append\", type=\"int\")"

msgid ""
"If ``-t3`` is seen on the command-line, :mod:`!optparse` does the equivalent "
"of::"
msgstr ""

msgid ""
"options.tracks = []\n"
"options.tracks.append(int(\"3\"))"
msgstr ""
"options.tracks = []\n"
"options.tracks.append(int(\"3\"))"

msgid "If, a little later on, ``--tracks=4`` is seen, it does::"
msgstr "Se, um pouco mais tarde, ``--tracks=4`` for visto, faz::"

msgid "options.tracks.append(int(\"4\"))"
msgstr "options.tracks.append(int(\"4\"))"

msgid ""
"The ``append`` action calls the ``append`` method on the current value of "
"the option.  This means that any default value specified must have an "
"``append`` method.  It also means that if the default value is non-empty, "
"the default elements will be present in the parsed value for the option, "
"with any values from the command line appended after those default values::"
msgstr ""
"A ação ``append`` chama o método ``append`` no valor atual da opção. Isto "
"significa que qualquer valor predefinido especificado deve ter um método "
"``append``. Também significa que se o valor predefinido não for vazio, os "
"elementos predefinidos estarão presentes no valor analisado para a opção, "
"com quaisquer valores da linha de comandos anexados após esses valores "
"predefinidos::"

msgid ""
">>> parser.add_option(\"--files\", action=\"append\", default=['~/.mypkg/"
"defaults'])\n"
">>> opts, args = parser.parse_args(['--files', 'overrides.mypkg'])\n"
">>> opts.files\n"
"['~/.mypkg/defaults', 'overrides.mypkg']"
msgstr ""
">>> parser.add_option(\"--files\", action=\"append\", default=['~/.mypkg/"
"defaults'])\n"
">>> opts, args = parser.parse_args(['--files', 'overrides.mypkg'])\n"
">>> opts.files\n"
"['~/.mypkg/defaults', 'overrides.mypkg']"

msgid ""
"``\"append_const\"`` [required: :attr:`~Option.const`; relevant: :attr:"
"`~Option.dest`]"
msgstr ""
"``\"append_const\"`` [necessário: :attr:`~Option.const`; relevante: :attr:"
"`~Option.dest`]"

msgid ""
"Like ``\"store_const\"``, but the value :attr:`~Option.const` is appended "
"to :attr:`~Option.dest`; as with ``\"append\"``, :attr:`~Option.dest` "
"defaults to ``None``, and an empty list is automatically created the first "
"time the option is encountered."
msgstr ""
"Semelhante a ``\"store_const\"``, mas o valor :attr:`~Option.const` é "
"anexado a :attr:`~Option.dest`; tal como com ``\"append\"``, :attr:`~Option."
"dest` predefinido é ``None``, e uma lista vazia é automaticamente criada na "
"primeira vez que a opção é encontrada."

msgid "``\"count\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"count\"`` [relevante: :attr:`~Option.dest`]"

msgid ""
"Increment the integer stored at :attr:`~Option.dest`.  If no default value "
"is supplied, :attr:`~Option.dest` is set to zero before being incremented "
"the first time."
msgstr ""
"Incrementa o inteiro armazenado em :attr:`~Option.dest`. Se nenhum valor "
"predefinido for fornecido, :attr:`~Option.dest` é definido para zero antes "
"de ser incrementado pela primeira vez."

msgid "parser.add_option(\"-v\", action=\"count\", dest=\"verbosity\")"
msgstr "parser.add_option(\"-v\", action=\"count\", dest=\"verbosity\")"

msgid ""
"The first time ``-v`` is seen on the command line, :mod:`!optparse` does the "
"equivalent of::"
msgstr ""

msgid ""
"options.verbosity = 0\n"
"options.verbosity += 1"
msgstr ""
"options.verbosity = 0\n"
"options.verbosity += 1"

msgid "Every subsequent occurrence of ``-v`` results in  ::"
msgstr "Cada ocorrência subsequente de ``-v`` resulta em ::"

msgid "options.verbosity += 1"
msgstr "options.verbosity += 1"

msgid ""
"``\"callback\"`` [required: :attr:`~Option.callback`; relevant: :attr:"
"`~Option.type`, :attr:`~Option.nargs`, :attr:`~Option.callback_args`, :attr:"
"`~Option.callback_kwargs`]"
msgstr ""
"``\"callback\"`` [necessário: :attr:`~Option.callback`; relevante: :attr:"
"`~Option.type`, :attr:`~Option.nargs`, :attr:`~Option.callback_args`, :attr:"
"`~Option.callback_kwargs`]"

msgid ""
"Call the function specified by :attr:`~Option.callback`, which is called "
"as ::"
msgstr ""
"Chama a função especificada por :attr:`~Option.callback`, que é chamada "
"como ::"

msgid "func(option, opt_str, value, parser, *args, **kwargs)"
msgstr "func(option, opt_str, value, parser, *args, **kwargs)"

msgid "See section :ref:`optparse-option-callbacks` for more detail."
msgstr "Veja a secção :ref:`optparse-option-callbacks` para mais detalhes."

msgid ""
"Prints a complete help message for all the options in the current option "
"parser.  The help message is constructed from the ``usage`` string passed to "
"OptionParser's constructor and the :attr:`~Option.help` string passed to "
"every option."
msgstr ""
"Imprime uma mensagem de ajuda completa para todas as opções no analisador de "
"opções atual. A mensagem de ajuda é construída a partir da string ``usage`` "
"passada ao construtor de OptionParser e da string :attr:`~Option.help` "
"passada a cada opção."

msgid ""
"If no :attr:`~Option.help` string is supplied for an option, it will still "
"be listed in the help message.  To omit an option entirely, use the special "
"value :const:`optparse.SUPPRESS_HELP`."
msgstr ""
"Se nenhuma string :attr:`~Option.help` for fornecida para uma opção, ela "
"ainda será listada na mensagem de ajuda. Para omitir uma opção "
"completamente, use o valor especial :const:`optparse.SUPPRESS_HELP`."

msgid ""
":mod:`!optparse` automatically adds a :attr:`~Option.help` option to all "
"OptionParsers, so you do not normally need to create one."
msgstr ""

msgid ""
"from optparse import OptionParser, SUPPRESS_HELP\n"
"\n"
"# usually, a help option is added automatically, but that can\n"
"# be suppressed using the add_help_option argument\n"
"parser = OptionParser(add_help_option=False)\n"
"\n"
"parser.add_option(\"-h\", \"--help\", action=\"help\")\n"
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\",\n"
"                  help=\"Be moderately verbose\")\n"
"parser.add_option(\"--file\", dest=\"filename\",\n"
"                  help=\"Input file to read data from\")\n"
"parser.add_option(\"--secret\", help=SUPPRESS_HELP)"
msgstr ""
"from optparse import OptionParser, SUPPRESS_HELP\n"
"\n"
"# normalmente, uma opção de ajuda é adicionada automaticamente, mas isso "
"pode\n"
"# ser suprimido usando o argumento add_help_option\n"
"parser = OptionParser(add_help_option=False)\n"
"\n"
"parser.add_option(\"-h\", \"--help\", action=\"help\")\n"
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\",\n"
"                  help=\"Ser moderadamente verboso\")\n"
"parser.add_option(\"--file\", dest=\"filename\",\n"
"                  help=\"Ficheiro de entrada para ler dados\")\n"
"parser.add_option(\"--secret\", help=SUPPRESS_HELP)"

msgid ""
"If :mod:`!optparse` sees either ``-h`` or ``--help`` on the command line, it "
"will print something like the following help message to stdout (assuming "
"``sys.argv[0]`` is ``\"foo.py\"``):"
msgstr ""

msgid ""
"Usage: foo.py [options]\n"
"\n"
"Options:\n"
"  -h, --help        Show this help message and exit\n"
"  -v                Be moderately verbose\n"
"  --file=FILENAME   Input file to read data from"
msgstr ""
"Utilização: foo.py [opções]\n"
"\n"
"Opções:\n"
"  -h, --help        Mostrar esta mensagem de ajuda e sair\n"
"  -v                Ser moderadamente verboso\n"
"  --file=FICHEIRO   Ficheiro de entrada para ler dados"

msgid ""
"After printing the help message, :mod:`!optparse` terminates your process "
"with ``sys.exit(0)``."
msgstr ""

msgid "``\"version\"``"
msgstr "``\"version\"``"

msgid ""
"Prints the version number supplied to the OptionParser to stdout and exits. "
"The version number is actually formatted and printed by the "
"``print_version()`` method of OptionParser.  Generally only relevant if the "
"``version`` argument is supplied to the OptionParser constructor.  As with :"
"attr:`~Option.help` options, you will rarely create ``version`` options, "
"since :mod:`!optparse` automatically adds them when needed."
msgstr ""

msgid "Standard option types"
msgstr "Tipos de opção padrão"

msgid ""
":mod:`!optparse` has five built-in option types: ``\"string\"``, "
"``\"int\"``, ``\"choice\"``, ``\"float\"`` and ``\"complex\"``.  If you need "
"to add new option types, see section :ref:`optparse-extending-optparse`."
msgstr ""

msgid ""
"Arguments to string options are not checked or converted in any way: the "
"text on the command line is stored in the destination (or passed to the "
"callback) as-is."
msgstr ""
"Os argumentos para opções de string não são verificados ou convertidos de "
"nenhuma forma: o texto na linha de comandos é armazenado no destino (ou "
"passado para o callback) como está."

msgid "Integer arguments (type ``\"int\"``) are parsed as follows:"
msgstr ""
"Os argumentos inteiros (tipo ``\"int\"``) são analisados da seguinte forma:"

msgid "if the number starts with ``0x``, it is parsed as a hexadecimal number"
msgstr "se o número começar com ``0x``, é analisado como um número hexadecimal"

msgid "if the number starts with ``0``, it is parsed as an octal number"
msgstr "se o número começar com ``0``, é analisado como um número octal"

msgid "if the number starts with ``0b``, it is parsed as a binary number"
msgstr "se o número começar com ``0b``, é analisado como um número binário"

msgid "otherwise, the number is parsed as a decimal number"
msgstr "caso contrário, o número é analisado como um número decimal"

msgid ""
"The conversion is done by calling :func:`int` with the appropriate base (2, "
"8, 10, or 16).  If this fails, so will :mod:`!optparse`, although with a "
"more useful error message."
msgstr ""

msgid ""
"``\"float\"`` and ``\"complex\"`` option arguments are converted directly "
"with :func:`float` and :func:`complex`, with similar error-handling."
msgstr ""
"Os argumentos de opção ``\"float\"`` e ``\"complex\"`` são convertidos "
"diretamente com :func:`float` e :func:`complex`, com tratamento de erros "
"semelhante."

msgid ""
"``\"choice\"`` options are a subtype of ``\"string\"`` options.  The :attr:"
"`~Option.choices` option attribute (a sequence of strings) defines the set "
"of allowed option arguments.  :func:`optparse.check_choice` compares user-"
"supplied option arguments against this master list and raises :exc:"
"`OptionValueError` if an invalid string is given."
msgstr ""
"As opções ``\"choice\"`` são um subtipo de opções ``\"string\"``. O atributo "
"de opção :attr:`~Option.choices` (uma sequência de strings) define o "
"conjunto de argumentos de opção permitidos. :func:`optparse.check_choice` "
"compara os argumentos de opção fornecidos pelo utilizador com esta lista "
"principal e levanta :exc:`OptionValueError` se for fornecida uma string "
"inválida."

msgid "Parsing arguments"
msgstr "Análise de argumentos"

msgid ""
"The whole point of creating and populating an OptionParser is to call its :"
"meth:`~OptionParser.parse_args` method."
msgstr ""
"O objetivo de criar e preencher um OptionParser é chamar o seu método :meth:"
"`~OptionParser.parse_args`."

msgid "Parse the command-line options found in *args*."
msgstr "Analisa as opções de linha de comandos encontradas em *args*."

msgid "The input parameters are"
msgstr "Os parâmetros de entrada são"

msgid "``args``"
msgstr "``args``"

msgid "the list of arguments to process (default: ``sys.argv[1:]``)"
msgstr "a lista de argumentos a processar (predefinição: ``sys.argv[1:]``)"

msgid "``values``"
msgstr "``values``"

msgid ""
"a :class:`Values` object to store option arguments in (default: a new "
"instance of :class:`Values`) -- if you give an existing object, the option "
"defaults will not be initialized on it"
msgstr ""
"um objeto :class:`Values` para armazenar argumentos de opção (predefinição: "
"uma nova instância de :class:`Values`) --- se fornecer um objeto existente, "
"os valores predefinidos das opções não serão inicializados nele"

msgid "and the return value is a pair ``(options, args)`` where"
msgstr "e o valor de retorno é um par ``(options, args)`` onde"

msgid "``options``"
msgstr "``options``"

msgid ""
"the same object that was passed in as *values*, or the ``optparse.Values`` "
"instance created by :mod:`!optparse`"
msgstr ""

msgid "the leftover positional arguments after all options have been processed"
msgstr ""
"os argumentos posicionais restantes após todas as opções terem sido "
"processadas"

msgid ""
"The most common usage is to supply neither keyword argument.  If you supply "
"``values``, it will be modified with repeated :func:`setattr` calls (roughly "
"one for every option argument stored to an option destination) and returned "
"by :meth:`~OptionParser.parse_args`."
msgstr ""
"O uso mais comum é não fornecer nenhum argumento de palavra-chave. Se "
"fornecer ``values``, este será modificado com chamadas repetidas a :func:"
"`setattr` (aproximadamente uma para cada argumento de opção armazenado num "
"destino de opção) e retornado por :meth:`~OptionParser.parse_args`."

msgid ""
"If :meth:`~OptionParser.parse_args` encounters any errors in the argument "
"list, it calls the OptionParser's :meth:`error` method with an appropriate "
"end-user error message. This ultimately terminates your process with an exit "
"status of 2 (the traditional Unix exit status for command-line errors)."
msgstr ""
"Se :meth:`~OptionParser.parse_args` encontrar quaisquer erros na lista de "
"argumentos, chama o método :meth:`error` de OptionParser com uma mensagem de "
"erro apropriada para o utilizador final. Isto termina o seu processo com um "
"estado de saída de 2 (o estado de saída tradicional do Unix para erros de "
"linha de comandos)."

msgid "Querying and manipulating your option parser"
msgstr "Consultar e manipular o seu analisador de opções"

msgid ""
"The default behavior of the option parser can be customized slightly, and "
"you can also poke around your option parser and see what's there.  "
"OptionParser provides several methods to help you out:"
msgstr ""
"O comportamento predefinido do analisador de opções pode ser ligeiramente "
"personalizado, e também pode explorar o seu analisador de opções e ver o que "
"lá está. OptionParser fornece vários métodos para o ajudar:"

msgid ""
"Set parsing to stop on the first non-option.  For example, if ``-a`` and ``-"
"b`` are both simple options that take no arguments, :mod:`!optparse` "
"normally accepts this syntax::"
msgstr ""

msgid "prog -a arg1 -b arg2"
msgstr "prog -a arg1 -b arg2"

msgid "and treats it as equivalent to  ::"
msgstr "e trata-o como equivalente a ::"

msgid "prog -a -b arg1 arg2"
msgstr "prog -a -b arg1 arg2"

msgid ""
"To disable this feature, call :meth:`disable_interspersed_args`.  This "
"restores traditional Unix syntax, where option parsing stops with the first "
"non-option argument."
msgstr ""
"Para desativar esta funcionalidade, chame :meth:`disable_interspersed_args`. "
"Isto restaura a sintaxe tradicional do Unix, onde a análise de opções para "
"no primeiro argumento não-opção."

msgid ""
"Use this if you have a command processor which runs another command which "
"has options of its own and you want to make sure these options don't get "
"confused.  For example, each command might have a different set of options."
msgstr ""
"Use isto se tiver um processador de comandos que executa outro comando que "
"tem as suas próprias opções e quer garantir que estas opções não se "
"confundam. Por exemplo, cada comando pode ter um conjunto diferente de "
"opções."

msgid ""
"Set parsing to not stop on the first non-option, allowing interspersing "
"switches with command arguments.  This is the default behavior."
msgstr ""
"Define a análise para não parar no primeiro não-opção, permitindo a "
"intercalação de opções com argumentos de comando. Este é o comportamento "
"predefinido."

msgid ""
"Returns the Option instance with the option string *opt_str*, or ``None`` if "
"no options have that option string."
msgstr ""
"Retorna a instância Option com a string de opção *opt_str*, ou ``None`` se "
"nenhuma opção tiver essa string de opção."

msgid ""
"Return ``True`` if the OptionParser has an option with option string "
"*opt_str* (e.g., ``-q`` or ``--verbose``)."
msgstr ""
"Retorna ``True`` se o OptionParser tiver uma opção com a string de opção "
"*opt_str* (por exemplo, ``-q`` ou ``--verbose``)."

msgid ""
"If the :class:`OptionParser` has an option corresponding to *opt_str*, that "
"option is removed.  If that option provided any other option strings, all of "
"those option strings become invalid. If *opt_str* does not occur in any "
"option belonging to this :class:`OptionParser`, raises :exc:`ValueError`."
msgstr ""
"Se o :class:`OptionParser` tiver uma opção correspondente a *opt_str*, essa "
"opção é removida. Se essa opção forneceu quaisquer outras strings de opção, "
"todas essas strings de opção tornam-se inválidas. Se *opt_str* não ocorrer "
"em nenhuma opção pertencente a este :class:`OptionParser`, levanta :exc:"
"`ValueError`."

msgid "Conflicts between options"
msgstr "Conflitos entre opções"

msgid ""
"If you're not careful, it's easy to define options with conflicting option "
"strings::"
msgstr ""
"Se não tiver cuidado, é fácil definir opções com strings de opção "
"conflitantes::"

msgid ""
"parser.add_option(\"-n\", \"--dry-run\", ...)\n"
"...\n"
"parser.add_option(\"-n\", \"--noisy\", ...)"
msgstr ""
"parser.add_option(\"-n\", \"--dry-run\", ...)\n"
"...\n"
"parser.add_option(\"-n\", \"--noisy\", ...)"

msgid ""
"(This is particularly true if you've defined your own OptionParser subclass "
"with some standard options.)"
msgstr ""
"(Isto é particularmente verdadeiro se definiu a sua própria subclasse "
"OptionParser com algumas opções padrão.)"

msgid ""
"Every time you add an option, :mod:`!optparse` checks for conflicts with "
"existing options.  If it finds any, it invokes the current conflict-handling "
"mechanism. You can set the conflict-handling mechanism either in the "
"constructor::"
msgstr ""

msgid "parser = OptionParser(..., conflict_handler=handler)"
msgstr "parser = OptionParser(..., conflict_handler=handler)"

msgid "or with a separate call::"
msgstr "ou com uma chamada separada::"

msgid "parser.set_conflict_handler(handler)"
msgstr "parser.set_conflict_handler(handler)"

msgid "The available conflict handlers are:"
msgstr "Os manipuladores de conflito disponíveis são:"

msgid "``\"error\"`` (default)"
msgstr "``\"error\"`` (predefinição)"

msgid ""
"assume option conflicts are a programming error and raise :exc:"
"`OptionConflictError`"
msgstr ""
"assume que os conflitos de opção são um erro de programação e levanta :exc:"
"`OptionConflictError`"

msgid "``\"resolve\"``"
msgstr "``\"resolve\"``"

msgid "resolve option conflicts intelligently (see below)"
msgstr "resolve conflitos de opção de forma inteligente (veja abaixo)"

msgid ""
"As an example, let's define an :class:`OptionParser` that resolves conflicts "
"intelligently and add conflicting options to it::"
msgstr ""
"Como exemplo, vamos definir um :class:`OptionParser` que resolve conflitos "
"de forma inteligente e adicionar opções conflitantes a ele::"

msgid ""
"parser = OptionParser(conflict_handler=\"resolve\")\n"
"parser.add_option(\"-n\", \"--dry-run\", ..., help=\"do no harm\")\n"
"parser.add_option(\"-n\", \"--noisy\", ..., help=\"be noisy\")"
msgstr ""
"parser = OptionParser(conflict_handler=\"resolve\")\n"
"parser.add_option(\"-n\", \"--dry-run\", ..., help=\"não fazer mal\")\n"
"parser.add_option(\"-n\", \"--noisy\", ..., help=\"ser barulhento\")"

msgid ""
"At this point, :mod:`!optparse` detects that a previously added option is "
"already using the ``-n`` option string.  Since ``conflict_handler`` is "
"``\"resolve\"``, it resolves the situation by removing ``-n`` from the "
"earlier option's list of option strings.  Now ``--dry-run`` is the only way "
"for the user to activate that option.  If the user asks for help, the help "
"message will reflect that::"
msgstr ""

msgid ""
"Options:\n"
"  --dry-run     do no harm\n"
"  ...\n"
"  -n, --noisy   be noisy"
msgstr ""
"Opções:\n"
"  --dry-run     não fazer mal\n"
"  ...\n"
"  -n, --noisy   ser barulhento"

msgid ""
"It's possible to whittle away the option strings for a previously added "
"option until there are none left, and the user has no way of invoking that "
"option from the command-line.  In that case, :mod:`!optparse` removes that "
"option completely, so it doesn't show up in help text or anywhere else. "
"Carrying on with our existing OptionParser::"
msgstr ""

msgid "parser.add_option(\"--dry-run\", ..., help=\"new dry-run option\")"
msgstr "parser.add_option(\"--dry-run\", ..., help=\"nova opção dry-run\")"

msgid ""
"At this point, the original ``-n``/``--dry-run`` option is no longer "
"accessible, so :mod:`!optparse` removes it, leaving this help text::"
msgstr ""

msgid ""
"Options:\n"
"  ...\n"
"  -n, --noisy   be noisy\n"
"  --dry-run     new dry-run option"
msgstr ""
"Opções:\n"
"  ...\n"
"  -n, --noisy   ser barulhento\n"
"  --dry-run     nova opção dry-run"

msgid "Cleanup"
msgstr "Limpeza"

msgid ""
"OptionParser instances have several cyclic references.  This should not be a "
"problem for Python's garbage collector, but you may wish to break the cyclic "
"references explicitly by calling :meth:`~OptionParser.destroy` on your "
"OptionParser once you are done with it.  This is particularly useful in long-"
"running applications where large object graphs are reachable from your "
"OptionParser."
msgstr ""
"As instâncias de OptionParser têm várias referências cíclicas. Isto não deve "
"ser um problema para o coletor de lixo do Python, mas pode querer quebrar "
"explicitamente as referências cíclicas chamando :meth:`~OptionParser."
"destroy` no seu OptionParser assim que terminar de o usar. Isto é "
"particularmente útil em aplicações de longa duração onde grandes grafos de "
"objetos são alcançáveis a partir do seu OptionParser."

msgid "Other methods"
msgstr "Outros métodos"

msgid "OptionParser supports several other public methods:"
msgstr "OptionParser suporta vários outros métodos públicos:"

msgid ""
"Set the usage string according to the rules described above for the "
"``usage`` constructor keyword argument.  Passing ``None`` sets the default "
"usage string; use :const:`optparse.SUPPRESS_USAGE` to suppress a usage "
"message."
msgstr ""
"Define a string de utilização de acordo com as regras descritas acima para o "
"argumento de palavra-chave do construtor ``usage``. Passar ``None`` define a "
"string de utilização predefinida; use :const:`optparse.SUPPRESS_USAGE` para "
"suprimir uma mensagem de utilização."

msgid ""
"Print the usage message for the current program (``self.usage``) to *file* "
"(default stdout).  Any occurrence of the string ``%prog`` in ``self.usage`` "
"is replaced with the name of the current program.  Does nothing if ``self."
"usage`` is empty or not defined."
msgstr ""
"Imprime a mensagem de utilização para o programa atual (``self.usage``) para "
"*file* (predefinição stdout). Qualquer ocorrência da string ``%prog`` em "
"``self.usage`` é substituída pelo nome do programa atual. Não faz nada se "
"``self.usage`` estiver vazio ou não definido."

msgid ""
"Same as :meth:`print_usage` but returns the usage string instead of printing "
"it."
msgstr ""
"Semelhante a :meth:`print_usage`, mas retorna a string de utilização em vez "
"de a imprimir."

msgid ""
"Set default values for several option destinations at once.  Using :meth:"
"`set_defaults` is the preferred way to set default values for options, since "
"multiple options can share the same destination.  For example, if several "
"\"mode\" options all set the same destination, any one of them can set the "
"default, and the last one wins::"
msgstr ""
"Define valores predefinidos para vários destinos de opção de uma só vez. "
"Usar :meth:`set_defaults` é a forma preferida de definir valores "
"predefinidos para opções, uma vez que várias opções podem partilhar o mesmo "
"destino. Por exemplo, se várias opções \"mode\" definirem todas o mesmo "
"destino, qualquer uma delas pode definir o predefinido, e a última vence::"

msgid ""
"parser.add_option(\"--advanced\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"advanced\",\n"
"                  default=\"novice\")    # overridden below\n"
"parser.add_option(\"--novice\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"novice\",\n"
"                  default=\"advanced\")  # overrides above setting"
msgstr ""
"parser.add_option(\"--advanced\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"advanced\",\n"
"                  default=\"novice\")    # substituído abaixo\n"
"parser.add_option(\"--novice\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"novice\",\n"
"                  default=\"advanced\")  # substitui a definição acima"

msgid "To avoid this confusion, use :meth:`set_defaults`::"
msgstr "Para evitar esta confusão, use :meth:`set_defaults`::"

msgid ""
"parser.set_defaults(mode=\"advanced\")\n"
"parser.add_option(\"--advanced\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"advanced\")\n"
"parser.add_option(\"--novice\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"novice\")"
msgstr ""
"parser.set_defaults(mode=\"advanced\")\n"
"parser.add_option(\"--advanced\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"advanced\")\n"
"parser.add_option(\"--novice\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"novice\")"

msgid "Option Callbacks"
msgstr "Retornos de chamada de opção"

msgid ""
"When :mod:`!optparse`'s built-in actions and types aren't quite enough for "
"your needs, you have two choices: extend :mod:`!optparse` or define a "
"callback option. Extending :mod:`!optparse` is more general, but overkill "
"for a lot of simple cases.  Quite often a simple callback is all you need."
msgstr ""

msgid "There are two steps to defining a callback option:"
msgstr "Existem dois passos para definir uma opção de retorno de chamada:"

msgid "define the option itself using the ``\"callback\"`` action"
msgstr "definir a opção em si usando a ação ``\"callback\"``"

msgid ""
"write the callback; this is a function (or method) that takes at least four "
"arguments, as described below"
msgstr ""
"escrever o retorno de chamada; isto é uma função (ou método) que aceita pelo "
"menos quatro argumentos, como descrito abaixo"

msgid "Defining a callback option"
msgstr "Definir uma opção de retorno de chamada"

msgid ""
"As always, the easiest way to define a callback option is by using the :meth:"
"`OptionParser.add_option` method.  Apart from :attr:`~Option.action`, the "
"only option attribute you must specify is ``callback``, the function to "
"call::"
msgstr ""
"Como sempre, a forma mais fácil de definir uma opção de retorno de chamada é "
"usando o método :meth:`OptionParser.add_option`. Além de :attr:`~Option."
"action`, o único atributo de opção que deve especificar é ``callback``, a "
"função a chamar::"

msgid "parser.add_option(\"-c\", action=\"callback\", callback=my_callback)"
msgstr "parser.add_option(\"-c\", action=\"callback\", callback=my_callback)"

msgid ""
"``callback`` is a function (or other callable object), so you must have "
"already defined ``my_callback()`` when you create this callback option. In "
"this simple case, :mod:`!optparse` doesn't even know if ``-c`` takes any "
"arguments, which usually means that the option takes no arguments---the mere "
"presence of ``-c`` on the command-line is all it needs to know.  In some "
"circumstances, though, you might want your callback to consume an arbitrary "
"number of command-line arguments.  This is where writing callbacks gets "
"tricky; it's covered later in this section."
msgstr ""

msgid ""
":mod:`!optparse` always passes four particular arguments to your callback, "
"and it will only pass additional arguments if you specify them via :attr:"
"`~Option.callback_args` and :attr:`~Option.callback_kwargs`.  Thus, the "
"minimal callback function signature is::"
msgstr ""

msgid "def my_callback(option, opt, value, parser):"
msgstr "def my_callback(option, opt, value, parser):"

msgid "The four arguments to a callback are described below."
msgstr "Os quatro argumentos para um retorno de chamada são descritos abaixo."

msgid ""
"There are several other option attributes that you can supply when you "
"define a callback option:"
msgstr ""
"Existem vários outros atributos de opção que pode fornecer quando define uma "
"opção de retorno de chamada:"

msgid ":attr:`~Option.type`"
msgstr ":attr:`~Option.type`"

msgid ""
"has its usual meaning: as with the ``\"store\"`` or ``\"append\"`` actions, "
"it instructs :mod:`!optparse` to consume one argument and convert it to :"
"attr:`~Option.type`.  Rather than storing the converted value(s) anywhere, "
"though, :mod:`!optparse` passes it to your callback function."
msgstr ""

msgid ":attr:`~Option.nargs`"
msgstr ":attr:`~Option.nargs`"

msgid ""
"also has its usual meaning: if it is supplied and > 1, :mod:`!optparse` will "
"consume :attr:`~Option.nargs` arguments, each of which must be convertible "
"to :attr:`~Option.type`.  It then passes a tuple of converted values to your "
"callback."
msgstr ""

msgid ":attr:`~Option.callback_args`"
msgstr ":attr:`~Option.callback_args`"

msgid "a tuple of extra positional arguments to pass to the callback"
msgstr ""
"um tuplo de argumentos posicionais extra a passar para o retorno de chamada"

msgid ":attr:`~Option.callback_kwargs`"
msgstr ":attr:`~Option.callback_kwargs`"

msgid "a dictionary of extra keyword arguments to pass to the callback"
msgstr ""
"um dicionário de argumentos de palavra-chave extra a passar para o retorno "
"de chamada"

msgid "How callbacks are called"
msgstr "Como os retornos de chamada são chamados"

msgid "All callbacks are called as follows::"
msgstr "Todos os retornos de chamada são chamados da seguinte forma::"

msgid "``option``"
msgstr "``option``"

msgid "is the Option instance that's calling the callback"
msgstr "é a instância Option que está a chamar o retorno de chamada"

msgid "``opt_str``"
msgstr "``opt_str``"

msgid ""
"is the option string seen on the command-line that's triggering the "
"callback. (If an abbreviated long option was used, ``opt_str`` will be the "
"full, canonical option string---e.g. if the user puts ``--foo`` on the "
"command-line as an abbreviation for ``--foobar``, then ``opt_str`` will be "
"``\"--foobar\"``.)"
msgstr ""
"é a string de opção vista na linha de comandos que está a acionar o retorno "
"de chamada. (Se uma opção longa abreviada foi usada, ``opt_str`` será a "
"string de opção completa e canónica --- por exemplo, se o utilizador colocar "
"``--foo`` na linha de comandos como uma abreviatura para ``--foobar``, então "
"``opt_str`` será ``\"--foobar\"``.)"

msgid "``value``"
msgstr "``value``"

msgid ""
"is the argument to this option seen on the command-line.  :mod:`!optparse` "
"will only expect an argument if :attr:`~Option.type` is set; the type of "
"``value`` will be the type implied by the option's type.  If :attr:`~Option."
"type` for this option is ``None`` (no argument expected), then ``value`` "
"will be ``None``.  If :attr:`~Option.nargs` > 1, ``value`` will be a tuple "
"of values of the appropriate type."
msgstr ""

msgid "``parser``"
msgstr "``parser``"

msgid ""
"is the OptionParser instance driving the whole thing, mainly useful because "
"you can access some other interesting data through its instance attributes:"
msgstr ""
"é a instância OptionParser que está a conduzir tudo, principalmente útil "
"porque pode aceder a outros dados interessantes através dos seus atributos "
"de instância:"

msgid "``parser.largs``"
msgstr "``parser.largs``"

msgid ""
"the current list of leftover arguments, ie. arguments that have been "
"consumed but are neither options nor option arguments. Feel free to modify "
"``parser.largs``, e.g. by adding more arguments to it.  (This list will "
"become ``args``, the second return value of :meth:`~OptionParser."
"parse_args`.)"
msgstr ""
"a lista atual de argumentos restantes, ou seja, argumentos que foram "
"consumidos mas não são nem opções nem argumentos de opção. Sinta-se à "
"vontade para modificar ``parser.largs``, por exemplo, adicionando mais "
"argumentos a ele. (Esta lista tornar-se-á ``args``, o segundo valor de "
"retorno de :meth:`~OptionParser.parse_args`.)"

msgid "``parser.rargs``"
msgstr "``parser.rargs``"

msgid ""
"the current list of remaining arguments, ie. with ``opt_str`` and ``value`` "
"(if applicable) removed, and only the arguments following them still there.  "
"Feel free to modify ``parser.rargs``, e.g. by consuming more arguments."
msgstr ""
"a lista atual de argumentos restantes, ou seja, com ``opt_str`` e ``value`` "
"(se aplicável) removidos, e apenas os argumentos que os seguem ainda "
"presentes. Sinta-se à vontade para modificar ``parser.rargs``, por exemplo, "
"consumindo mais argumentos."

msgid "``parser.values``"
msgstr "``parser.values``"

msgid ""
"the object where option values are by default stored (an instance of "
"optparse.OptionValues).  This lets callbacks use the same mechanism as the "
"rest of :mod:`!optparse` for storing option values; you don't need to mess "
"around with globals or closures.  You can also access or modify the value(s) "
"of any options already encountered on the command-line."
msgstr ""

msgid ""
"is a tuple of arbitrary positional arguments supplied via the :attr:`~Option."
"callback_args` option attribute."
msgstr ""
"é um tuplo de argumentos posicionais arbitrários fornecidos através do "
"atributo de opção :attr:`~Option.callback_args`."

msgid "``kwargs``"
msgstr "``kwargs``"

msgid ""
"is a dictionary of arbitrary keyword arguments supplied via :attr:`~Option."
"callback_kwargs`."
msgstr ""
"é um dicionário de argumentos de palavra-chave arbitrários fornecidos "
"através de :attr:`~Option.callback_kwargs`."

msgid "Raising errors in a callback"
msgstr "Levantar erros num retorno de chamada"

msgid ""
"The callback function should raise :exc:`OptionValueError` if there are any "
"problems with the option or its argument(s).  :mod:`!optparse` catches this "
"and terminates the program, printing the error message you supply to "
"stderr.  Your message should be clear, concise, accurate, and mention the "
"option at fault. Otherwise, the user will have a hard time figuring out what "
"they did wrong."
msgstr ""

msgid "Callback example 1: trivial callback"
msgstr "Exemplo de retorno de chamada 1: retorno de chamada trivial"

msgid ""
"Here's an example of a callback option that takes no arguments, and simply "
"records that the option was seen::"
msgstr ""
"Aqui está um exemplo de uma opção de retorno de chamada que não aceita "
"argumentos e simplesmente regista que a opção foi vista::"

msgid ""
"def record_foo_seen(option, opt_str, value, parser):\n"
"    parser.values.saw_foo = True\n"
"\n"
"parser.add_option(\"--foo\", action=\"callback\", callback=record_foo_seen)"
msgstr ""
"def record_foo_seen(option, opt_str, value, parser):\n"
"    parser.values.saw_foo = True\n"
"\n"
"parser.add_option(\"--foo\", action=\"callback\", callback=record_foo_seen)"

msgid "Of course, you could do that with the ``\"store_true\"`` action."
msgstr "Claro que poderia fazer isso com a ação ``\"store_true\"``."

msgid "Callback example 2: check option order"
msgstr "Exemplo de retorno de chamada 2: verificar a ordem das opções"

msgid ""
"Here's a slightly more interesting example: record the fact that ``-a`` is "
"seen, but blow up if it comes after ``-b`` in the command-line.  ::"
msgstr ""
"Aqui está um exemplo um pouco mais interessante: regista o facto de ``-a`` "
"ser visto, mas falha se vier depois de ``-b`` na linha de comandos. ::"

msgid ""
"def check_order(option, opt_str, value, parser):\n"
"    if parser.values.b:\n"
"        raise OptionValueError(\"can't use -a after -b\")\n"
"    parser.values.a = 1\n"
"...\n"
"parser.add_option(\"-a\", action=\"callback\", callback=check_order)\n"
"parser.add_option(\"-b\", action=\"store_true\", dest=\"b\")"
msgstr ""
"def check_order(option, opt_str, value, parser):\n"
"    if parser.values.b:\n"
"        raise OptionValueError(\"não pode usar -a depois de -b\")\n"
"    parser.values.a = 1\n"
"...\n"
"parser.add_option(\"-a\", action=\"callback\", callback=check_order)\n"
"parser.add_option(\"-b\", action=\"store_true\", dest=\"b\")"

msgid "Callback example 3: check option order (generalized)"
msgstr ""
"Exemplo de retorno de chamada 3: verificar a ordem das opções (generalizado)"

msgid ""
"If you want to reuse this callback for several similar options (set a flag, "
"but blow up if ``-b`` has already been seen), it needs a bit of work: the "
"error message and the flag that it sets must be generalized.  ::"
msgstr ""
"Se quiser reutilizar este retorno de chamada para várias opções semelhantes "
"(definir uma flag, mas falhar se ``-b`` já tiver sido visto), é necessário "
"algum trabalho: a mensagem de erro e a flag que define devem ser "
"generalizadas. ::"

msgid ""
"def check_order(option, opt_str, value, parser):\n"
"    if parser.values.b:\n"
"        raise OptionValueError(\"can't use %s after -b\" % opt_str)\n"
"    setattr(parser.values, option.dest, 1)\n"
"...\n"
"parser.add_option(\"-a\", action=\"callback\", callback=check_order, "
"dest='a')\n"
"parser.add_option(\"-b\", action=\"store_true\", dest=\"b\")\n"
"parser.add_option(\"-c\", action=\"callback\", callback=check_order, "
"dest='c')"
msgstr ""
"def check_order(option, opt_str, value, parser):\n"
"    if parser.values.b:\n"
"        raise OptionValueError(\"não pode usar %s depois de -b\" % opt_str)\n"
"    setattr(parser.values, option.dest, 1)\n"
"...\n"
"parser.add_option(\"-a\", action=\"callback\", callback=check_order, "
"dest='a')\n"
"parser.add_option(\"-b\", action=\"store_true\", dest=\"b\")\n"
"parser.add_option(\"-c\", action=\"callback\", callback=check_order, "
"dest='c')"

msgid "Callback example 4: check arbitrary condition"
msgstr "Exemplo de retorno de chamada 4: verificar condição arbitrária"

msgid ""
"Of course, you could put any condition in there---you're not limited to "
"checking the values of already-defined options.  For example, if you have "
"options that should not be called when the moon is full, all you have to do "
"is this::"
msgstr ""
"Claro que pode colocar qualquer condição aí --- não está limitado a "
"verificar os valores de opções já definidas. Por exemplo, se tiver opções "
"que não devem ser chamadas quando a lua está cheia, tudo o que tem de fazer "
"é isto::"

msgid ""
"def check_moon(option, opt_str, value, parser):\n"
"    if is_moon_full():\n"
"        raise OptionValueError(\"%s option invalid when moon is full\"\n"
"                               % opt_str)\n"
"    setattr(parser.values, option.dest, 1)\n"
"...\n"
"parser.add_option(\"--foo\",\n"
"                  action=\"callback\", callback=check_moon, dest=\"foo\")"
msgstr ""
"def check_moon(option, opt_str, value, parser):\n"
"    if is_moon_full():\n"
"        raise OptionValueError(\"%s opção inválida quando a lua está "
"cheia\"\n"
"                               % opt_str)\n"
"    setattr(parser.values, option.dest, 1)\n"
"...\n"
"parser.add_option(\"--foo\",\n"
"                  action=\"callback\", callback=check_moon, dest=\"foo\")"

msgid ""
"(The definition of ``is_moon_full()`` is left as an exercise for the reader.)"
msgstr ""
"(A definição de ``is_moon_full()`` é deixada como exercício para o leitor.)"

msgid "Callback example 5: fixed arguments"
msgstr "Exemplo de retorno de chamada 5: argumentos fixos"

msgid ""
"Things get slightly more interesting when you define callback options that "
"take a fixed number of arguments.  Specifying that a callback option takes "
"arguments is similar to defining a ``\"store\"`` or ``\"append\"`` option: "
"if you define :attr:`~Option.type`, then the option takes one argument that "
"must be convertible to that type; if you further define :attr:`~Option."
"nargs`, then the option takes :attr:`~Option.nargs` arguments."
msgstr ""
"As coisas ficam um pouco mais interessantes quando define opções de retorno "
"de chamada que aceitam um número fixo de argumentos. Especificar que uma "
"opção de retorno de chamada aceita argumentos é semelhante a definir uma "
"opção ``\"store\"`` ou ``\"append\"``: se definir :attr:`~Option.type`, "
"então a opção aceita um argumento que deve ser conversível para esse tipo; "
"se definir ainda :attr:`~Option.nargs`, então a opção aceita :attr:`~Option."
"nargs` argumentos."

msgid ""
"Here's an example that just emulates the standard ``\"store\"`` action::"
msgstr "Eis um exemplo que emula simplesmente a ação padrão ``\"store\"``::"

msgid ""
"def store_value(option, opt_str, value, parser):\n"
"    setattr(parser.values, option.dest, value)\n"
"...\n"
"parser.add_option(\"--foo\",\n"
"                  action=\"callback\", callback=store_value,\n"
"                  type=\"int\", nargs=3, dest=\"foo\")"
msgstr ""
"def store_value(option, opt_str, value, parser):\n"
"    setattr(parser.values, option.dest, value)\n"
"...\n"
"parser.add_option(\"--foo\",\n"
"                  action=\"callback\", callback=store_value,\n"
"                  type=\"int\", nargs=3, dest=\"foo\")"

msgid ""
"Note that :mod:`!optparse` takes care of consuming 3 arguments and "
"converting them to integers for you; all you have to do is store them.  (Or "
"whatever; obviously you don't need a callback for this example.)"
msgstr ""

msgid "Callback example 6: variable arguments"
msgstr "Exemplo de função de retorno de chamada 6: argumentos variáveis"

msgid ""
"Things get hairy when you want an option to take a variable number of "
"arguments. For this case, you must write a callback, as :mod:`!optparse` "
"doesn't provide any built-in capabilities for it.  And you have to deal with "
"certain intricacies of conventional Unix command-line parsing that :mod:`!"
"optparse` normally handles for you.  In particular, callbacks should "
"implement the conventional rules for bare ``--`` and ``-`` arguments:"
msgstr ""

msgid "either ``--`` or ``-`` can be option arguments"
msgstr "tanto ``--`` como ``-`` podem ser argumentos de opção"

msgid ""
"bare ``--`` (if not the argument to some option): halt command-line "
"processing and discard the ``--``"
msgstr ""
"``--`` isolado (se não for argumento de alguma opção): interromper o "
"processamento da linha de comandos e descartar o ``--``"

msgid ""
"bare ``-`` (if not the argument to some option): halt command-line "
"processing but keep the ``-`` (append it to ``parser.largs``)"
msgstr ""
"``-`` isolado (se não for argumento de alguma opção): interromper o "
"processamento da linha de comandos, mas manter o ``-`` (adicioná-lo a "
"``parser.largs``)"

msgid ""
"If you want an option that takes a variable number of arguments, there are "
"several subtle, tricky issues to worry about.  The exact implementation you "
"choose will be based on which trade-offs you're willing to make for your "
"application (which is why :mod:`!optparse` doesn't support this sort of "
"thing directly)."
msgstr ""

msgid ""
"Nevertheless, here's a stab at a callback for an option with variable "
"arguments::"
msgstr ""
"Não obstante, aqui está uma tentativa de função de retorno de chamada para "
"uma opção com argumentos variáveis::"

msgid ""
"def vararg_callback(option, opt_str, value, parser):\n"
"    assert value is None\n"
"    value = []\n"
"\n"
"    def floatable(str):\n"
"        try:\n"
"            float(str)\n"
"            return True\n"
"        except ValueError:\n"
"            return False\n"
"\n"
"    for arg in parser.rargs:\n"
"        # stop on --foo like options\n"
"        if arg[:2] == \"--\" and len(arg) > 2:\n"
"            break\n"
"        # stop on -a, but not on -3 or -3.0\n"
"        if arg[:1] == \"-\" and len(arg) > 1 and not floatable(arg):\n"
"            break\n"
"        value.append(arg)\n"
"\n"
"    del parser.rargs[:len(value)]\n"
"    setattr(parser.values, option.dest, value)\n"
"\n"
"...\n"
"parser.add_option(\"-c\", \"--callback\", dest=\"vararg_attr\",\n"
"                  action=\"callback\", callback=vararg_callback)"
msgstr ""
"def vararg_callback(option, opt_str, value, parser):\n"
"    assert value is None\n"
"    value = []\n"
"\n"
"    def floatable(str):\n"
"        try:\n"
"            float(str)\n"
"            return True\n"
"        except ValueError:\n"
"            return False\n"
"\n"
"    for arg in parser.rargs:\n"
"        # parar em opções como --foo\n"
"        if arg[:2] == \"--\" and len(arg) > 2:\n"
"            break\n"
"        # parar em -a, mas não em -3 ou -3.0\n"
"        if arg[:1] == \"-\" and len(arg) > 1 and not floatable(arg):\n"
"            break\n"
"        value.append(arg)\n"
"\n"
"    del parser.rargs[:len(value)]\n"
"    setattr(parser.values, option.dest, value)\n"
"\n"
"...\n"
"parser.add_option(\"-c\", \"--callback\", dest=\"vararg_attr\",\n"
"                  action=\"callback\", callback=vararg_callback)"

msgid "Extending :mod:`!optparse`"
msgstr ""

msgid ""
"Since the two major controlling factors in how :mod:`!optparse` interprets "
"command-line options are the action and type of each option, the most likely "
"direction of extension is to add new actions and new types."
msgstr ""

msgid "Adding new types"
msgstr "Adicionar novos tipos"

msgid ""
"To add new types, you need to define your own subclass of :mod:`!"
"optparse`'s :class:`Option` class.  This class has a couple of attributes "
"that define :mod:`!optparse`'s types: :attr:`~Option.TYPES` and :attr:"
"`~Option.TYPE_CHECKER`."
msgstr ""

msgid ""
"A tuple of type names; in your subclass, simply define a new tuple :attr:"
"`TYPES` that builds on the standard one."
msgstr ""
"Um tuplo de nomes de tipos; na sua subclasse, defina simplesmente um novo "
"tuplo :attr:`TYPES` que se baseie no padrão."

msgid ""
"A dictionary mapping type names to type-checking functions.  A type-checking "
"function has the following signature::"
msgstr ""
"Um dicionário que mapeia nomes de tipos para funções de verificação de "
"tipos. Uma função de verificação de tipos tem a seguinte assinatura::"

msgid "def check_mytype(option, opt, value)"
msgstr "def check_mytype(option, opt, value)"

msgid ""
"where ``option`` is an :class:`Option` instance, ``opt`` is an option string "
"(e.g., ``-f``), and ``value`` is the string from the command line that must "
"be checked and converted to your desired type.  ``check_mytype()`` should "
"return an object of the hypothetical type ``mytype``.  The value returned by "
"a type-checking function will wind up in the OptionValues instance returned "
"by :meth:`OptionParser.parse_args`, or be passed to a callback as the "
"``value`` parameter."
msgstr ""
"onde ``option`` é uma instância de :class:`Option`, ``opt`` é uma string de "
"opção (por exemplo, ``-f``), e ``value`` é a string da linha de comandos que "
"deve ser verificada e convertida para o tipo desejado. A função "
"``check_mytype()`` deve devolver um objeto do tipo hipotético ``mytype``. O "
"valor devolvido por uma função de verificação de tipos acabará na instância "
"OptionValues devolvida por :meth:`OptionParser.parse_args`, ou será passado "
"para uma função de retorno de chamada como o parâmetro ``value``."

msgid ""
"Your type-checking function should raise :exc:`OptionValueError` if it "
"encounters any problems.  :exc:`OptionValueError` takes a single string "
"argument, which is passed as-is to :class:`OptionParser`'s :meth:`error` "
"method, which in turn prepends the program name and the string ``\"error:"
"\"`` and prints everything to stderr before terminating the process."
msgstr ""
"A sua função de verificação de tipos deve gerar uma exceção :exc:"
"`OptionValueError` se encontrar algum problema. A exceção :exc:"
"`OptionValueError` aceita um único argumento de string, que é passado sem "
"alterações para o método :meth:`error` de :class:`OptionParser`, que por sua "
"vez adiciona o nome do programa e a string ``\"error:\"`` e imprime tudo "
"para stderr antes de terminar o processo."

msgid ""
"Here's a silly example that demonstrates adding a ``\"complex\"`` option "
"type to parse Python-style complex numbers on the command line.  (This is "
"even sillier than it used to be, because :mod:`!optparse` 1.3 added built-in "
"support for complex numbers, but never mind.)"
msgstr ""

msgid "First, the necessary imports::"
msgstr "Primeiro, os imports necessários::"

msgid ""
"from copy import copy\n"
"from optparse import Option, OptionValueError"
msgstr ""
"from copy import copy\n"
"from optparse import Option, OptionValueError"

msgid ""
"You need to define your type-checker first, since it's referred to later (in "
"the :attr:`~Option.TYPE_CHECKER` class attribute of your Option subclass)::"
msgstr ""
"É necessário definir primeiro a sua função de verificação de tipos, uma vez "
"que é referenciada mais tarde (no atributo de classe :attr:`~Option."
"TYPE_CHECKER` da sua subclasse Option)::"

msgid ""
"def check_complex(option, opt, value):\n"
"    try:\n"
"        return complex(value)\n"
"    except ValueError:\n"
"        raise OptionValueError(\n"
"            \"option %s: invalid complex value: %r\" % (opt, value))"
msgstr ""
"def check_complex(option, opt, value):\n"
"    try:\n"
"        return complex(value)\n"
"    except ValueError:\n"
"        raise OptionValueError(\n"
"            \"opção %s: valor complexo inválido: %r\" % (opt, value))"

msgid "Finally, the Option subclass::"
msgstr "Finalmente, a subclasse Option::"

msgid ""
"class MyOption (Option):\n"
"    TYPES = Option.TYPES + (\"complex\",)\n"
"    TYPE_CHECKER = copy(Option.TYPE_CHECKER)\n"
"    TYPE_CHECKER[\"complex\"] = check_complex"
msgstr ""
"class MyOption (Option):\n"
"    TYPES = Option.TYPES + (\"complex\",)\n"
"    TYPE_CHECKER = copy(Option.TYPE_CHECKER)\n"
"    TYPE_CHECKER[\"complex\"] = check_complex"

msgid ""
"(If we didn't make a :func:`copy` of :attr:`Option.TYPE_CHECKER`, we would "
"end up modifying the :attr:`~Option.TYPE_CHECKER` attribute of :mod:`!"
"optparse`'s Option class.  This being Python, nothing stops you from doing "
"that except good manners and common sense.)"
msgstr ""

msgid ""
"That's it!  Now you can write a script that uses the new option type just "
"like any other :mod:`!optparse`\\ -based script, except you have to instruct "
"your OptionParser to use MyOption instead of Option::"
msgstr ""

msgid ""
"parser = OptionParser(option_class=MyOption)\n"
"parser.add_option(\"-c\", type=\"complex\")"
msgstr ""
"parser = OptionParser(option_class=MyOption)\n"
"parser.add_option(\"-c\", type=\"complex\")"

msgid ""
"Alternately, you can build your own option list and pass it to OptionParser; "
"if you don't use :meth:`add_option` in the above way, you don't need to tell "
"OptionParser which option class to use::"
msgstr ""
"Alternativamente, pode construir a sua própria lista de opções e passá-la ao "
"OptionParser; se não utilizar o método :meth:`add_option` da forma acima, "
"não precisa de indicar ao OptionParser qual a classe de opção a utilizar::"

msgid ""
"option_list = [MyOption(\"-c\", action=\"store\", type=\"complex\", "
"dest=\"c\")]\n"
"parser = OptionParser(option_list=option_list)"
msgstr ""
"option_list = [MyOption(\"-c\", action=\"store\", type=\"complex\", "
"dest=\"c\")]\n"
"parser = OptionParser(option_list=option_list)"

msgid "Adding new actions"
msgstr "Adicionar novas ações"

msgid ""
"Adding new actions is a bit trickier, because you have to understand that :"
"mod:`!optparse` has a couple of classifications for actions:"
msgstr ""

msgid "\"store\" actions"
msgstr "Ações de \"armazenamento\""

msgid ""
"actions that result in :mod:`!optparse` storing a value to an attribute of "
"the current OptionValues instance; these options require a :attr:`~Option."
"dest` attribute to be supplied to the Option constructor."
msgstr ""

msgid "\"typed\" actions"
msgstr "Ações \"tipadas\""

msgid ""
"actions that take a value from the command line and expect it to be of a "
"certain type; or rather, a string that can be converted to a certain type. "
"These options require a :attr:`~Option.type` attribute to the Option "
"constructor."
msgstr ""
"ações que obtêm um valor da linha de comandos e esperam que seja de um "
"determinado tipo; ou melhor, uma string que possa ser convertida para um "
"determinado tipo. Estas opções requerem um atributo :attr:`~Option.type` no "
"construtor Option."

msgid ""
"These are overlapping sets: some default \"store\" actions are "
"``\"store\"``, ``\"store_const\"``, ``\"append\"``, and ``\"count\"``, while "
"the default \"typed\" actions are ``\"store\"``, ``\"append\"``, and "
"``\"callback\"``."
msgstr ""
"Estes são conjuntos sobrepostos: algumas ações de \"armazenamento\" padrão "
"são ``\"store\"``, ``\"store_const\"``, ``\"append\"`` e ``\"count\"``, "
"enquanto as ações \"tipadas\" padrão são ``\"store\"``, ``\"append\"`` e "
"``\"callback\"``."

msgid ""
"When you add an action, you need to categorize it by listing it in at least "
"one of the following class attributes of Option (all are lists of strings):"
msgstr ""
"Ao adicionar uma ação, é necessário categorizá-la, listando-a em pelo menos "
"um dos seguintes atributos de classe de Option (todos são listas de strings):"

msgid "All actions must be listed in ACTIONS."
msgstr "Todas as ações devem ser listadas em ACTIONS."

msgid "\"store\" actions are additionally listed here."
msgstr "As ações de \"armazenamento\" são adicionalmente listadas aqui."

msgid "\"typed\" actions are additionally listed here."
msgstr "As ações \"tipadas\" são adicionalmente listadas aqui."

msgid ""
"Actions that always take a type (i.e. whose options always take a value) are "
"additionally listed here.  The only effect of this is that :mod:`!optparse` "
"assigns the default type, ``\"string\"``, to options with no explicit type "
"whose action is listed in :attr:`ALWAYS_TYPED_ACTIONS`."
msgstr ""

msgid ""
"In order to actually implement your new action, you must override Option's :"
"meth:`take_action` method and add a case that recognizes your action."
msgstr ""
"Para implementar efetivamente a sua nova ação, é necessário substituir o "
"método :meth:`take_action` de Option e adicionar um caso que reconheça a sua "
"ação."

msgid ""
"For example, let's add an ``\"extend\"`` action.  This is similar to the "
"standard ``\"append\"`` action, but instead of taking a single value from "
"the command-line and appending it to an existing list, ``\"extend\"`` will "
"take multiple values in a single comma-delimited string, and extend an "
"existing list with them.  That is, if ``--names`` is an ``\"extend\"`` "
"option of type ``\"string\"``, the command line ::"
msgstr ""
"Por exemplo, vamos adicionar uma ação ``\"extend\"``. Isto é semelhante à "
"ação padrão ``\"append\"``, mas em vez de obter um único valor da linha de "
"comandos e adicioná-lo a uma lista existente, a ação ``\"extend\"`` irá "
"obter vários valores numa única string delimitada por vírgulas, e estender "
"uma lista existente com esses valores. Ou seja, se ``--names`` for uma opção "
"``\"extend\"`` do tipo ``\"string\"``, a linha de comandos ::"

msgid "--names=foo,bar --names blah --names ding,dong"
msgstr "--names=foo,bar --names blah --names ding,dong"

msgid "would result in a list  ::"
msgstr "resultaria na lista ::"

msgid "[\"foo\", \"bar\", \"blah\", \"ding\", \"dong\"]"
msgstr "[\"foo\", \"bar\", \"blah\", \"ding\", \"dong\"]"

msgid "Again we define a subclass of Option::"
msgstr "Mais uma vez, definimos uma subclasse de Option::"

msgid ""
"class MyOption(Option):\n"
"\n"
"    ACTIONS = Option.ACTIONS + (\"extend\",)\n"
"    STORE_ACTIONS = Option.STORE_ACTIONS + (\"extend\",)\n"
"    TYPED_ACTIONS = Option.TYPED_ACTIONS + (\"extend\",)\n"
"    ALWAYS_TYPED_ACTIONS = Option.ALWAYS_TYPED_ACTIONS + (\"extend\",)\n"
"\n"
"    def take_action(self, action, dest, opt, value, values, parser):\n"
"        if action == \"extend\":\n"
"            lvalue = value.split(\",\")\n"
"            values.ensure_value(dest, []).extend(lvalue)\n"
"        else:\n"
"            Option.take_action(\n"
"                self, action, dest, opt, value, values, parser)"
msgstr ""
"class MyOption(Option):\n"
"\n"
"    ACTIONS = Option.ACTIONS + (\"extend\",)\n"
"    STORE_ACTIONS = Option.STORE_ACTIONS + (\"extend\",)\n"
"    TYPED_ACTIONS = Option.TYPED_ACTIONS + (\"extend\",)\n"
"    ALWAYS_TYPED_ACTIONS = Option.ALWAYS_TYPED_ACTIONS + (\"extend\",)\n"
"\n"
"    def take_action(self, action, dest, opt, value, values, parser):\n"
"        if action == \"extend\":\n"
"            lvalue = value.split(\",\")\n"
"            values.ensure_value(dest, []).extend(lvalue)\n"
"        else:\n"
"            Option.take_action(\n"
"                self, action, dest, opt, value, values, parser)"

msgid "Features of note:"
msgstr "Características a destacar:"

msgid ""
"``\"extend\"`` both expects a value on the command-line and stores that "
"value somewhere, so it goes in both :attr:`~Option.STORE_ACTIONS` and :attr:"
"`~Option.TYPED_ACTIONS`."
msgstr ""
"A ação ``\"extend\"`` espera um valor na linha de comandos e armazena esse "
"valor em algum lugar, pelo que é incluída tanto em :attr:`~Option."
"STORE_ACTIONS` como em :attr:`~Option.TYPED_ACTIONS`."

msgid ""
"to ensure that :mod:`!optparse` assigns the default type of ``\"string\"`` "
"to ``\"extend\"`` actions, we put the ``\"extend\"`` action in :attr:"
"`~Option.ALWAYS_TYPED_ACTIONS` as well."
msgstr ""

msgid ""
":meth:`MyOption.take_action` implements just this one new action, and passes "
"control back to :meth:`Option.take_action` for the standard :mod:`!optparse` "
"actions."
msgstr ""

msgid ""
"``values`` is an instance of the optparse_parser.Values class, which "
"provides the very useful :meth:`ensure_value` method. :meth:`ensure_value` "
"is essentially :func:`getattr` with a safety valve; it is called as ::"
msgstr ""
"``values`` é uma instância da classe optparse_parser.Values, que "
"disponibiliza o método muito útil :meth:`ensure_value`. O método :meth:"
"`ensure_value` é essencialmente um :func:`getattr` com uma válvula de "
"segurança; é chamado da seguinte forma ::"

msgid "values.ensure_value(attr, value)"
msgstr "values.ensure_value(attr, value)"

msgid ""
"If the ``attr`` attribute of ``values`` doesn't exist or is ``None``, then "
"ensure_value() first sets it to ``value``, and then returns ``value``. This "
"is very handy for actions like ``\"extend\"``, ``\"append\"``, and "
"``\"count\"``, all of which accumulate data in a variable and expect that "
"variable to be of a certain type (a list for the first two, an integer for "
"the latter).  Using :meth:`ensure_value` means that scripts using your "
"action don't have to worry about setting a default value for the option "
"destinations in question; they can just leave the default as ``None`` and :"
"meth:`ensure_value` will take care of getting it right when it's needed."
msgstr ""
"Se o atributo ``attr`` de ``values`` não existir ou for ``None``, então "
"ensure_value() primeiro define-o para ``value`` e depois devolve ``value``. "
"Isto é muito útil para ações como ``\"extend\"``, ``\"append\"`` e "
"``\"count\"``, que acumulam dados numa variável e esperam que essa variável "
"seja de um determinado tipo (uma lista para as duas primeiras, um inteiro "
"para a última). Ao utilizar :meth:`ensure_value`, os scripts que usam a sua "
"ação não precisam de se preocupar em definir um valor padrão para os "
"destinos das opções em questão; podem simplesmente deixar o padrão como "
"``None`` e o método :meth:`ensure_value` tratará de o definir corretamente "
"quando necessário."

msgid "Exceptions"
msgstr "Exceções"

msgid ""
"Raised if an :class:`Option` instance is created with invalid or "
"inconsistent arguments."
msgstr ""
"Gerada se uma instância de :class:`Option` for criada com argumentos "
"inválidos ou inconsistentes."

msgid "Raised if conflicting options are added to an :class:`OptionParser`."
msgstr ""
"Gerada se opções conflitantes forem adicionadas a um :class:`OptionParser`."

msgid "Raised if an invalid option value is encountered on the command line."
msgstr ""
"Gerada se for encontrado um valor de opção inválido na linha de comandos."

msgid "Raised if an invalid option is passed on the command line."
msgstr "Gerada se for passada uma opção inválida na linha de comandos."

msgid "Raised if an ambiguous option is passed on the command line."
msgstr "Gerada se for passada uma opção ambígua na linha de comandos."
