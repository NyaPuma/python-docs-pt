# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-05 14:39+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!pkgutil` --- Package extension utility"
msgstr ":mod:`!pkgutil` --- Utilitário de extensão de pacotes"

msgid "**Source code:** :source:`Lib/pkgutil.py`"
msgstr "**Código-fonte:** :source:`Lib/pkgutil.py`"

msgid ""
"This module provides utilities for the import system, in particular package "
"support."
msgstr ""
"Este módulo fornece utilitários para o sistema de importação, em particular "
"para o suporte a pacotes."

msgid "A namedtuple that holds a brief summary of a module's info."
msgstr ""
"Uma namedtuple que contém um breve resumo das informações de um módulo."

msgid ""
"Extend the search path for the modules which comprise a package.  Intended "
"use is to place the following code in a package's :file:`__init__.py`::"
msgstr ""
"Estende o caminho de pesquisa (*search path*) para os módulos que compõem um "
"pacote. O uso pretendido é colocar o seguinte código no ficheiro :file:"
"`__init__.py` de um pacote::"

msgid ""
"from pkgutil import extend_path\n"
"__path__ = extend_path(__path__, __name__)"
msgstr ""

msgid ""
"For each directory on :data:`sys.path` that has a subdirectory that matches "
"the package name, add the subdirectory to the package's :attr:`~module."
"__path__`. This is useful if one wants to distribute different parts of a "
"single logical package as multiple directories."
msgstr ""
"Para cada diretório em :data:`sys.path` que possua um subdiretório "
"correspondente ao nome do pacote, adiciona o subdiretório ao :attr:`~module."
"__path__` do pacote. Isto é útil se se pretender distribuir diferentes "
"partes de um único pacote lógico como múltiplos diretórios."

msgid ""
"It also looks for :file:`\\*.pkg` files beginning where ``*`` matches the "
"*name* argument.  This feature is similar to :file:`\\*.pth` files (see the :"
"mod:`site` module for more information), except that it doesn't special-case "
"lines starting with ``import``.  A :file:`\\*.pkg` file is trusted at face "
"value: apart from skipping blank lines and ignoring comments, all entries "
"found in a :file:`\\*.pkg` file are added to the path, regardless of whether "
"they exist on the filesystem (this is a feature)."
msgstr ""
"Também procura por ficheiros :file:`\\*.pkg` onde o prefixo ``*`` "
"corresponde ao argumento *name*. Esta funcionalidade é semelhante aos "
"ficheiros :file:`\\*.pth` (consulte o módulo :mod:`site` para mais "
"informações), exceto que não trata de forma especial linhas que comecem por "
"``import``. Um ficheiro :file:`\\*.pkg` é aceite tal como está: além de "
"ignorar linhas em branco e comentários, todas as entradas encontradas num "
"ficheiro :file:`\\*.pkg` são adicionadas ao caminho, independentemente de "
"existirem ou não no sistema de ficheiros (isto é uma característica)."

msgid ""
"If the input path is not a list (as is the case for frozen packages) it is "
"returned unchanged.  The input path is not modified; an extended copy is "
"returned.  Items are only appended to the copy at the end."
msgstr ""
"Se o caminho de entrada não for uma lista (como acontece com pacotes "
"*frozen*) este é devolvido sem alterações. O caminho de entrada não é "
"modificado; é devolvida uma cópia estendida. Os itens são apenas anexados ao "
"final da cópia."

msgid ""
"It is assumed that :data:`sys.path` is a sequence.  Items of :data:`sys."
"path` that are not strings referring to existing directories are ignored. "
"Unicode items on :data:`sys.path` that cause errors when used as filenames "
"may cause this function to raise an exception (in line with :func:`os.path."
"isdir` behavior)."
msgstr ""
"Assume-se que :data:`sys.path` é uma sequência. Itens de :data:`sys.path` "
"que não sejam strings referentes a diretórios existentes são ignorados. "
"Itens Unicode em :data:`sys.path` que causem erros ao serem usados como "
"nomes de ficheiros podem fazer com que esta função levante uma exceção (em "
"conformidade com o comportamento de :func:`os.path.isdir`)."

msgid "Retrieve a :term:`finder` for the given *path_item*."
msgstr "Obtém um :term:`finder` para o *path_item* fornecido."

msgid ""
"The returned finder is cached in :data:`sys.path_importer_cache` if it was "
"newly created by a path hook."
msgstr ""
"O finder retornado é guardado em cache no :data:`sys.path_importer_cache` se "
"tiver sido criado recentemente por um *path hook*."

msgid ""
"The cache (or part of it) can be cleared manually if a rescan of :data:`sys."
"path_hooks` is necessary."
msgstr ""
"A cache (ou parte dela) pode ser limpa manualmente se for necessária uma "
"nova verificação de :data:`sys.path_hooks`."

msgid ""
"Updated to be based directly on :mod:`importlib` rather than relying on the "
"package internal :pep:`302` import emulation."
msgstr ""
"Atualizado para se basear diretamente no :mod:`importlib` em vez de depender "
"da emulação de importação interna do pacote :pep:`302`."

msgid "Yield :term:`finder` objects for the given module name."
msgstr "Gera objetos :term:`finder` para o nome de módulo fornecido."

msgid ""
"If *fullname* contains a ``'.'``, the finders will be for the package "
"containing *fullname*, otherwise they will be all registered top level "
"finders (i.e. those on both :data:`sys.meta_path` and :data:`sys."
"path_hooks`)."
msgstr ""
"Se *fullname* contiver um ``'.'``, os finders serão para o pacote que contém "
"*fullname*; caso contrário, serão todos os finders de nível superior "
"registados (ou seja, aqueles que estão tanto em :data:`sys.meta_path` como "
"em :data:`sys.path_hooks`)."

msgid ""
"If the named module is in a package, that package is imported as a side "
"effect of invoking this function."
msgstr ""
"Se o módulo nomeado estiver num pacote, esse pacote é importado como efeito "
"secundário da invocação desta função."

msgid "If no module name is specified, all top level finders are produced."
msgstr ""
"Se nenhum nome de módulo for especificado, são produzidos todos os finders "
"de nível superior."

msgid ""
"Yields :class:`ModuleInfo` for all submodules on *path*, or, if *path* is "
"``None``, all top-level modules on :data:`sys.path`."
msgstr ""
"Gera :class:`ModuleInfo` para todos os sub-módulos em *path* ou, se *path* "
"for ``None``, para todos os módulos de nível superior em :data:`sys.path`."

msgid ""
"*path* should be either ``None`` or a list of paths to look for modules in."
msgstr ""
"*path* deve ser ``None`` ou uma lista de caminhos para procurar módulos."

msgid ""
"*prefix* is a string to output on the front of every module name on output."
msgstr ""
"*prefix* é uma string a ser colocada à frente de cada nome de módulo na "
"saída."

msgid ""
"Only works for a :term:`finder` which defines an ``iter_modules()`` method. "
"This interface is non-standard, so the module also provides implementations "
"for :class:`importlib.machinery.FileFinder` and :class:`zipimport."
"zipimporter`."
msgstr ""
"Só funciona para um :term:`finder` que defina um método ``iter_modules()``. "
"Esta interface não é padrão, por isso o módulo também fornece implementações "
"para :class:`importlib.machinery.FileFinder` e :class:`zipimport."
"zipimporter`."

msgid ""
"Yields :class:`ModuleInfo` for all modules recursively on *path*, or, if "
"*path* is ``None``, all accessible modules."
msgstr ""
"Gera :class:`ModuleInfo` para todos os módulos recursivamente em *path* ou, "
"se *path* for ``None``, para todos os módulos acessíveis."

msgid ""
"Note that this function must import all *packages* (*not* all modules!) on "
"the given *path*, in order to access the ``__path__`` attribute to find "
"submodules."
msgstr ""
"Note que esta função tem de importar todos os *pacotes* (*não* todos os "
"módulos!) no *path* fornecido, de modo a aceder ao atributo ``__path__`` "
"para encontrar sub-módulos."

msgid ""
"*onerror* is a function which gets called with one argument (the name of the "
"package which was being imported) if any exception occurs while trying to "
"import a package.  If no *onerror* function is supplied, :exc:"
"`ImportError`\\s are caught and ignored, while all other exceptions are "
"propagated, terminating the search."
msgstr ""
"*onerror* é uma função chamada com um argumento (o nome do pacote que estava "
"a ser importado) se ocorrer alguma exceção ao tentar importar um pacote. Se "
"não for fornecida uma função *onerror*, os :exc:`ImportError`\\s são "
"capturados e ignorados, enquanto todas as outras exceções são propagadas, "
"terminando a pesquisa."

msgid "Examples::"
msgstr "Exemplos::"

msgid ""
"# list all modules python can access\n"
"walk_packages()\n"
"\n"
"# list all submodules of ctypes\n"
"walk_packages(ctypes.__path__, ctypes.__name__ + '.')"
msgstr ""
"# listar todos os módulos que o python consegue aceder\n"
"walk_packages()\n"
"\n"
"# listar todos os sub-módulos do ctypes\n"
"walk_packages(ctypes.__path__, ctypes.__name__ + '.')"

msgid "Get a resource from a package."
msgstr "Obtém um recurso de um pacote."

msgid ""
"This is a wrapper for the :term:`loader` :meth:`get_data <importlib.abc."
"ResourceLoader.get_data>` API.  The *package* argument should be the name of "
"a package, in standard module format (``foo.bar``).  The *resource* argument "
"should be in the form of a relative filename, using ``/`` as the path "
"separator.  The parent directory name ``..`` is not allowed, and nor is a "
"rooted name (starting with a ``/``)."
msgstr ""
"Este é um *wrapper* para a API do :term:`loader` :meth:`get_data <importlib."
"abc.ResourceLoader.get_data>`. O argumento *package* deve ser o nome de um "
"pacote, no formato padrão de módulo (``foo.bar``). O argumento *resource* "
"deve estar no formato de um nome de ficheiro relativo, utilizando ``/`` como "
"separador de caminho. O nome de diretório pai ``..`` não é permitido, nem um "
"nome absoluto (começado por ``/``)."

msgid ""
"The function returns a binary string that is the contents of the specified "
"resource."
msgstr ""
"A função devolve uma string binária que contém o conteúdo do recurso "
"especificado."

msgid ""
"For packages located in the filesystem, which have already been imported, "
"this is the rough equivalent of::"
msgstr ""
"Para pacotes localizados no sistema de ficheiros, que já tenham sido "
"importados, isto é aproximadamente o equivalente a::"

msgid ""
"d = os.path.dirname(sys.modules[package].__file__)\n"
"data = open(os.path.join(d, resource), 'rb').read()"
msgstr ""

msgid ""
"If the package cannot be located or loaded, or it uses a :term:`loader` "
"which does not support :meth:`get_data <importlib.abc.ResourceLoader."
"get_data>`, then ``None`` is returned.  In particular, the :term:`loader` "
"for :term:`namespace packages <namespace package>` does not support :meth:"
"`get_data <importlib.abc.ResourceLoader.get_data>`."
msgstr ""
"Se o pacote não puder ser localizado ou carregado, ou se utilizar um :term:"
"`loader` que não suporte :meth:`get_data <importlib.abc.ResourceLoader."
"get_data>`, então é devolvido ``None``. Em particular, o :term:`loader` "
"para :term:`namespace packages <namespace package>` não suporta :meth:"
"`get_data`."

msgid "Resolve a name to an object."
msgstr "Resolve um nome para um objeto."

msgid ""
"This functionality is used in numerous places in the standard library (see :"
"issue:`12915`) - and equivalent functionality is also in widely used third-"
"party packages such as setuptools, Django and Pyramid."
msgstr ""
"Esta funcionalidade é utilizada em diversos locais da biblioteca padrão "
"(ver :issue:`12915`) — e funcionalidade equivalente existe também em pacotes "
"de terceiros amplamente usados, como setuptools, Django e Pyramid."

msgid ""
"It is expected that *name* will be a string in one of the following formats, "
"where W is shorthand for a valid Python identifier and dot stands for a "
"literal period in these pseudo-regexes:"
msgstr ""
"Espera-se que *name* seja uma string num dos seguintes formatos, onde W é "
"uma abreviatura para um identificador Python válido e o ponto representa um "
"ponto literal nestas pseudo-regexes:"

msgid "``W(.W)*``"
msgstr ""

msgid "``W(.W)*:(W(.W)*)?``"
msgstr ""

msgid ""
"The first form is intended for backward compatibility only. It assumes that "
"some part of the dotted name is a package, and the rest is an object "
"somewhere within that package, possibly nested inside other objects. Because "
"the place where the package stops and the object hierarchy starts can't be "
"inferred by inspection, repeated attempts to import must be done with this "
"form."
msgstr ""
"A primeira forma destina-se apenas a compatibilidade retroativa. Assume que "
"alguma parte do nome pontuado é um pacote e o resto é um objeto algures "
"dentro desse pacote, possivelmente aninhado noutros objetos. Como o ponto "
"onde o pacote termina e a hierarquia de objetos começa não pode ser inferido "
"por inspeção, devem ser feitas tentativas repetidas de importação com esta "
"forma."

msgid ""
"In the second form, the caller makes the division point clear through the "
"provision of a single colon: the dotted name to the left of the colon is a "
"package to be imported, and the dotted name to the right is the object "
"hierarchy within that package. Only one import is needed in this form. If it "
"ends with the colon, then a module object is returned."
msgstr ""
"Na segunda forma, o chamador torna o ponto de divisão claro através da "
"utilização de dois pontos: o nome à esquerda dos dois pontos é o pacote a "
"ser importado, e o nome à direita é a hierarquia de objetos dentro desse "
"pacote. Apenas uma importação é necessária nesta forma. Se terminar com os "
"dois pontos, é devolvido um objeto de módulo."

msgid ""
"The function will return an object (which might be a module), or raise one "
"of the following exceptions:"
msgstr ""
"A função devolverá um objeto (que pode ser um módulo), ou levantará uma das "
"seguintes exceções:"

msgid ":exc:`ValueError` -- if *name* isn't in a recognised format."
msgstr ":exc:`ValueError` -- se o *name* não estiver num formato reconhecido."

msgid ":exc:`ImportError` -- if an import failed when it shouldn't have."
msgstr ":exc:`ImportError` -- se uma importação falhou quando não deveria."

msgid ""
":exc:`AttributeError` -- If a failure occurred when traversing the object "
"hierarchy within the imported package to get to the desired object."
msgstr ""
":exc:`AttributeError` -- Se ocorreu uma falha ao percorrer a hierarquia de "
"objetos dentro do pacote importado para chegar ao objeto desejado."
