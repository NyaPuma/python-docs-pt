# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-03 14:40+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!queue` --- A synchronized queue class"
msgstr ":mod:`!queue` --- Uma classe de fila sincronizada"

msgid "**Source code:** :source:`Lib/queue.py`"
msgstr "**Código-fonte:** :source:`Lib/queue.py`"

msgid ""
"The :mod:`queue` module implements multi-producer, multi-consumer queues. It "
"is especially useful in threaded programming when information must be "
"exchanged safely between multiple threads.  The :class:`Queue` class in this "
"module implements all the required locking semantics."
msgstr ""
"O módulo :mod:`queue` implementa filas multi-produtor e multi-consumidor. É "
"especialmente útil em programação com threads quando a informação deve ser "
"trocada de forma segura entre múltiplas threads. A classe :class:`Queue` "
"neste módulo implementa toda a semântica de bloqueio necessária."

msgid ""
"The module implements three types of queue, which differ only in the order "
"in which the entries are retrieved.  In a :abbr:`FIFO (first-in, first-out)` "
"queue, the first tasks added are the first retrieved.  In a :abbr:`LIFO "
"(last-in, first-out)` queue, the most recently added entry is the first "
"retrieved (operating like a stack).  With a priority queue, the entries are "
"kept sorted (using the :mod:`heapq` module) and the lowest valued entry is "
"retrieved first."
msgstr ""
"O módulo implementa três tipos de fila, que diferem apenas na ordem em que "
"as entradas são recuperadas. Numa fila :abbr:`FIFO (first-in, first-out)`, "
"as primeiras tarefas adicionadas são as primeiras a ser recuperadas. Numa "
"fila :abbr:`LIFO (last-in, first-out)`, a entrada adicionada mais "
"recentemente é a primeira a ser recuperada (funcionando como uma pilha). Com "
"uma fila de prioridade, as entradas são mantidas ordenadas (usando o módulo :"
"mod:`heapq`) e a entrada de menor valor é recuperada primeiro."

msgid ""
"Internally, those three types of queues use locks to temporarily block "
"competing threads; however, they are not designed to handle reentrancy "
"within a thread."
msgstr ""
"Internamente, esses três tipos de filas utilizam trincos (*locks*) para "
"bloquear temporariamente threads concorrentes; no entanto, não foram "
"concebidas para lidar com reentrância dentro de uma thread."

msgid ""
"In addition, the module implements a \"simple\" :abbr:`FIFO (first-in, first-"
"out)` queue type, :class:`SimpleQueue`, whose specific implementation "
"provides additional guarantees in exchange for the smaller functionality."
msgstr ""
"Além disso, o módulo implementa um tipo de fila :abbr:`FIFO (first-in, first-"
"out)` \"simples\", :class:`SimpleQueue`, cuja implementação específica "
"oferece garantias adicionais em troca de funcionalidades mais reduzidas."

msgid "The :mod:`queue` module defines the following classes and exceptions:"
msgstr "O módulo :mod:`queue` define as seguintes classes e exceções:"

msgid ""
"Constructor for a :abbr:`FIFO (first-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero, "
"the queue size is infinite."
msgstr ""
"Construtor para uma fila :abbr:`FIFO (first-in, first-out)`. *maxsize* é um "
"inteiro que define o limite superior do número de itens que podem ser "
"colocados na fila. A inserção será bloqueada assim que este tamanho for "
"atingido, até que os itens da fila sejam consumidos. Se *maxsize* for menor "
"ou igual a zero, o tamanho da fila é infinito."

msgid ""
"Constructor for a :abbr:`LIFO (last-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero, "
"the queue size is infinite."
msgstr ""
"Construtor para uma fila :abbr:`LIFO (last-in, first-out)`. *maxsize* é um "
"inteiro que define o limite superior do número de itens que podem ser "
"colocados na fila. A inserção será bloqueada assim que este tamanho for "
"atingido, até que os itens da fila sejam consumidos. Se *maxsize* for menor "
"ou igual a zero, o tamanho da fila é infinito."

msgid ""
"Constructor for a priority queue.  *maxsize* is an integer that sets the "
"upperbound limit on the number of items that can be placed in the queue.  "
"Insertion will block once this size has been reached, until queue items are "
"consumed.  If *maxsize* is less than or equal to zero, the queue size is "
"infinite."
msgstr ""
"Construtor para uma fila de prioridade. *maxsize* é um inteiro que define o "
"limite superior do número de itens que podem ser colocados na fila. A "
"inserção será bloqueada assim que este tamanho for atingido, até que os "
"itens da fila sejam consumidos. Se *maxsize* for menor ou igual a zero, o "
"tamanho da fila é infinito."

msgid ""
"The lowest valued entries are retrieved first (the lowest valued entry is "
"the one that would be returned by ``min(entries)``).  A typical pattern for "
"entries is a tuple in the form: ``(priority_number, data)``."
msgstr ""
"As entradas com o valor mais baixo são recuperadas primeiro (a entrada de "
"menor valor é a que seria devolvida por ``min(entries)``). Um padrão típico "
"para as entradas é um tuplo no formato: ``(priority_number, data)``."

msgid ""
"If the *data* elements are not comparable, the data can be wrapped in a "
"class that ignores the data item and only compares the priority number::"
msgstr ""
"Se os elementos *data* não forem comparáveis, os dados podem ser envolvidos "
"numa classe que ignore o item de dados e compare apenas o número de "
"prioridade::"

msgid ""
"from dataclasses import dataclass, field\n"
"from typing import Any\n"
"\n"
"@dataclass(order=True)\n"
"class PrioritizedItem:\n"
"    priority: int\n"
"    item: Any=field(compare=False)"
msgstr ""
"from dataclasses import dataclass, field\n"
"from typing import Any\n"
"\n"
"@dataclass(order=True)\n"
"class PrioritizedItem:\n"
"    priority: int\n"
"    item: Any=field(compare=False)"

msgid ""
"Constructor for an unbounded :abbr:`FIFO (first-in, first-out)` queue. "
"Simple queues lack advanced functionality such as task tracking."
msgstr ""
"Construtor para uma fila :abbr:`FIFO (first-in, first-out)` ilimitada. Filas "
"simples carecem de funcionalidades avançadas, como o rastreamento de tarefas."

msgid ""
"Exception raised when non-blocking :meth:`~Queue.get` (or :meth:`~Queue."
"get_nowait`) is called on a :class:`Queue` object which is empty."
msgstr ""
"Exceção lançada quando um :meth:`~Queue.get` não bloqueante (ou :meth:"
"`~Queue.get_nowait`) é chamado num objeto :class:`Queue` que está vazio."

msgid ""
"Exception raised when non-blocking :meth:`~Queue.put` (or :meth:`~Queue."
"put_nowait`) is called on a :class:`Queue` object which is full."
msgstr ""
"Exceção lançada quando um :meth:`~Queue.put` não bloqueante (ou :meth:"
"`~Queue.put_nowait`) é chamado num objeto :class:`Queue` que está cheio."

msgid ""
"Exception raised when :meth:`~Queue.put` or :meth:`~Queue.get` is called on "
"a :class:`Queue` object which has been shut down."
msgstr ""
"Exceção lançada quando :meth:`~Queue.put` ou :meth:`~Queue.get` é chamado "
"num objeto :class:`Queue` que foi encerrado (*shut down*)."

msgid "Queue Objects"
msgstr "Objetos Queue"

msgid ""
"Queue objects (:class:`Queue`, :class:`LifoQueue`, or :class:"
"`PriorityQueue`) provide the public methods described below."
msgstr ""
"Objetos de fila (:class:`Queue`, :class:`LifoQueue` ou :class:"
"`PriorityQueue`) fornecem os métodos públicos descritos abaixo."

msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block, nor will qsize() < maxsize "
"guarantee that put() will not block."
msgstr ""
"Retorna o tamanho aproximado da fila. Note que qsize() > 0 não garante que "
"um get() subsequente não bloqueie, nem qsize() < maxsize garante que o put() "
"não bloqueie."

msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``True`` it doesn't guarantee that a subsequent call to put() will "
"not block.  Similarly, if empty() returns ``False`` it doesn't guarantee "
"that a subsequent call to get() will not block."
msgstr ""
"Retorna ``True`` se a fila estiver vazia, ``False`` caso contrário. Se "
"empty() retornar ``True``, não garante que uma chamada subsequente a put() "
"não bloqueie. Da mesma forma, se empty() retornar ``False``, não garante que "
"uma chamada subsequente a get() não bloqueie."

msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  If full() "
"returns ``True`` it doesn't guarantee that a subsequent call to get() will "
"not block.  Similarly, if full() returns ``False`` it doesn't guarantee that "
"a subsequent call to put() will not block."
msgstr ""
"Retorna ``True`` se a fila estiver cheia, ``False`` caso contrário. Se "
"full() retornar ``True``, não garante que uma chamada subsequente a get() "
"não bloqueie. Da mesma forma, se full() retornar ``False``, não garante que "
"uma chamada subsequente a put() não bloqueie."

msgid ""
"Put *item* into the queue.  If optional args *block* is true and *timeout* "
"is ``None`` (the default), block if necessary until a free slot is "
"available.  If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Full` exception if no free slot was available "
"within that time. Otherwise (*block* is false), put an item on the queue if "
"a free slot is immediately available, else raise the :exc:`Full` exception "
"(*timeout* is ignored in that case)."
msgstr ""
"Coloca um *item* na fila. Se os argumentos opcionais *block* forem "
"verdadeiros e *timeout* for ``None`` (o valor predefinido), bloqueia se "
"necessário até que haja um lugar livre disponível. Se *timeout* for um "
"número positivo, bloqueia no máximo *timeout* segundos e lança a exceção :"
"exc:`Full` se nenhum lugar livre estiver disponível nesse tempo. Caso "
"contrário (*block* é falso), coloca um item na fila se houver um lugar livre "
"imediatamente disponível, caso contrário lança a exceção :exc:`Full` (o "
"*timeout* é ignorado nesse caso)."

msgid "Raises :exc:`ShutDown` if the queue has been shut down."
msgstr "Lança :exc:`ShutDown` se a fila tiver sido encerrada."

msgid "Equivalent to ``put(item, block=False)``."
msgstr "Equivalente a ``put(item, block=False)``."

msgid ""
"Remove and return an item from the queue.  If optional args *block* is true "
"and *timeout* is ``None`` (the default), block if necessary until an item is "
"available. If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Empty` exception if no item was available "
"within that time. Otherwise (*block* is false), return an item if one is "
"immediately available, else raise the :exc:`Empty` exception (*timeout* is "
"ignored in that case)."
msgstr ""
"Remove e retorna um item da fila. Se os argumentos opcionais *block* forem "
"verdadeiros e *timeout* for ``None`` (o valor predefinido), bloqueia se "
"necessário até que um item esteja disponível. Se *timeout* for um número "
"positivo, bloqueia no máximo *timeout* segundos e lança a exceção :exc:"
"`Empty` se nenhum item estiver disponível nesse tempo. Caso contrário "
"(*block* é falso), retorna um item se um estiver imediatamente disponível, "
"caso contrário lança a exceção :exc:`Empty` (o *timeout* é ignorado nesse "
"caso)."

msgid ""
"Prior to 3.0 on POSIX systems, and for all versions on Windows, if *block* "
"is true and *timeout* is ``None``, this operation goes into an "
"uninterruptible wait on an underlying lock.  This means that no exceptions "
"can occur, and in particular a SIGINT will not trigger a :exc:"
"`KeyboardInterrupt`."
msgstr ""
"Antes da versão 3.0 em sistemas POSIX, e para todas as versões em Windows, "
"se *block* for verdadeiro e *timeout* for ``None``, esta operação entra numa "
"espera ininterruptível num trinco subjacente. Isto significa que nenhuma "
"exceção pode ocorrer e, em particular, um SIGINT não desencadeará um :exc:"
"`KeyboardInterrupt`."

msgid ""
"Raises :exc:`ShutDown` if the queue has been shut down and is empty, or if "
"the queue has been shut down immediately."
msgstr ""
"Lança :exc:`ShutDown` se a fila tiver sido encerrada e estiver vazia, ou se "
"a fila tiver sido encerrada imediatamente."

msgid "Equivalent to ``get(False)``."
msgstr "Equivalente a ``get(False)``."

msgid ""
"Two methods are offered to support tracking whether enqueued tasks have been "
"fully processed by daemon consumer threads."
msgstr ""
"São oferecidos dois métodos para suportar o rastreamento de se as tarefas "
"enfileiradas foram totalmente processadas por threads consumidoras daemon."

msgid ""
"Indicate that a formerly enqueued task is complete.  Used by queue consumer "
"threads.  For each :meth:`get` used to fetch a task, a subsequent call to :"
"meth:`task_done` tells the queue that the processing on the task is complete."
msgstr ""
"Indica que uma tarefa anteriormente enfileirada está concluída. Usado por "
"threads consumidoras de fila. Para cada :meth:`get` usado para obter uma "
"tarefa, uma chamada subsequente a :meth:`task_done` informa a fila de que o "
"processamento da tarefa está concluído."

msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items have "
"been processed (meaning that a :meth:`task_done` call was received for every "
"item that had been :meth:`put` into the queue)."
msgstr ""
"Se um :meth:`join` estiver bloqueado, ele retomará quando todos os itens "
"tiverem sido processados (significando que uma chamada :meth:`task_done` foi "
"recebida para cada item que foi colocado (:meth:`put`) na fila)."

msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Lança uma exceção :exc:`ValueError` se for chamado mais vezes do que o "
"número de itens colocados na fila."

msgid "Blocks until all items in the queue have been gotten and processed."
msgstr ""
"Bloqueia até que todos os itens na fila tenham sido obtidos e processados."

msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer thread calls :meth:"
"`task_done` to indicate that the item was retrieved and all work on it is "
"complete.  When the count of unfinished tasks drops to zero, :meth:`join` "
"unblocks."
msgstr ""
"A contagem de tarefas inacabadas aumenta sempre que um item é adicionado à "
"fila. A contagem diminui sempre que uma thread consumidora chama :meth:"
"`task_done` para indicar que o item foi recuperado e todo o trabalho nele "
"está concluído. Quando a contagem de tarefas inacabadas desce para zero, o :"
"meth:`join` desbloqueia."

msgid "Waiting for task completion"
msgstr "Esperar pela conclusão da tarefa"

msgid "Example of how to wait for enqueued tasks to be completed::"
msgstr "Exemplo de como esperar que as tarefas enfileiradas sejam concluídas::"

msgid ""
"import threading\n"
"import queue\n"
"\n"
"q = queue.Queue()\n"
"\n"
"def worker():\n"
"    while True:\n"
"        item = q.get()\n"
"        print(f'Working on {item}')\n"
"        print(f'Finished {item}')\n"
"        q.task_done()\n"
"\n"
"# Turn-on the worker thread.\n"
"threading.Thread(target=worker, daemon=True).start()\n"
"\n"
"# Send thirty task requests to the worker.\n"
"for item in range(30):\n"
"    q.put(item)\n"
"\n"
"# Block until all tasks are done.\n"
"q.join()\n"
"print('All work completed')"
msgstr ""
"import threading\n"
"import queue\n"
"\n"
"q = queue.Queue()\n"
"\n"
"def worker():\n"
"    while True:\n"
"        item = q.get()\n"
"        print(f'Trabalhando em {item}')\n"
"        print(f'Terminado {item}')\n"
"        q.task_done()\n"
"\n"
"# Ligar a thread trabalhadora.\n"
"threading.Thread(target=worker, daemon=True).start()\n"
"\n"
"# Enviar trinta pedidos de tarefa para o trabalhador.\n"
"for item in range(30):\n"
"    q.put(item)\n"
"\n"
"# Bloquear até que todas as tarefas estejam concluídas.\n"
"q.join()\n"
"print('Todo o trabalho concluído')"

msgid "Terminating queues"
msgstr "Encerrar filas"

msgid ""
"When no longer needed, :class:`Queue` objects can be wound down until empty "
"or terminated immediately with a hard shutdown."
msgstr ""
"Quando já não forem necessários, os objetos :class:`Queue` podem ser "
"esvaziados gradualmente até ficarem vazios ou terminados imediatamente com "
"um encerramento forçado (*hard shutdown*)."

msgid "Put a :class:`Queue` instance into a shutdown mode."
msgstr "Coloca uma instância :class:`Queue` num modo de encerramento."

msgid ""
"The queue can no longer grow. Future calls to :meth:`~Queue.put` raise :exc:"
"`ShutDown`. Currently blocked callers of :meth:`~Queue.put` will be "
"unblocked and will raise :exc:`ShutDown` in the formerly blocked thread."
msgstr ""
"A fila já não pode crescer. Chamadas futuras a :meth:`~Queue.put` lançarão :"
"exc:`ShutDown`. Os chamadores de :meth:`~Queue.put` atualmente bloqueados "
"serão desbloqueados e lançarão :exc:`ShutDown` na thread anteriormente "
"bloqueada."

msgid ""
"If *immediate* is false (the default), the queue can be wound down normally "
"with :meth:`~Queue.get` calls to extract tasks that have already been loaded."
msgstr ""
"Se *immediate* for falso (o predefinido), a fila pode ser encerrada "
"normalmente com chamadas :meth:`~Queue.get` para extrair tarefas que já "
"tinham sido carregadas."

msgid ""
"And if :meth:`~Queue.task_done` is called for each remaining task, a "
"pending :meth:`~Queue.join` will be unblocked normally."
msgstr ""
"E se :meth:`~Queue.task_done` for chamado para cada tarefa restante, um :"
"meth:`~Queue.join` pendente será desbloqueado normalmente."

msgid ""
"Once the queue is empty, future calls to :meth:`~Queue.get` will raise :exc:"
"`ShutDown`."
msgstr ""
"Assim que a fila estiver vazia, futuras chamadas a :meth:`~Queue.get` "
"lançarão :exc:`ShutDown`."

msgid ""
"If *immediate* is true, the queue is terminated immediately. The queue is "
"drained to be completely empty and the count of unfinished tasks is reduced "
"by the number of tasks drained. If unfinished tasks is zero, callers of :"
"meth:`~Queue.join` are unblocked.  Also, blocked callers of :meth:`~Queue."
"get` are unblocked and will raise :exc:`ShutDown` because the queue is empty."
msgstr ""
"Se *immediate* for verdadeiro, a fila é terminada imediatamente. A fila é "
"esvaziada para ficar completamente vazia e a contagem de tarefas inacabadas "
"é reduzida pelo número de tarefas esvaziadas. Se as tarefas inacabadas forem "
"zero, os chamadores de :meth:`~Queue.join` são desbloqueados. Além disso, os "
"chamadores bloqueados de :meth:`~Queue.get` são desbloqueados e lançarão :"
"exc:`ShutDown` porque a fila está vazia."

msgid ""
"Use caution when using :meth:`~Queue.join` with *immediate* set to true. "
"This unblocks the join even when no work has been done on the tasks, "
"violating the usual invariant for joining a queue."
msgstr ""
"Tenha cautela ao utilizar :meth:`~Queue.join` com *immediate* definido como "
"verdadeiro. Isto desbloqueia o join mesmo quando nenhum trabalho foi feito "
"nas tarefas, violando o invariante habitual para junção de uma fila."

msgid "SimpleQueue Objects"
msgstr "Objetos SimpleQueue"

msgid ""
":class:`SimpleQueue` objects provide the public methods described below."
msgstr ""
"Objetos :class:`SimpleQueue` fornecem os métodos públicos descritos abaixo."

msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block."
msgstr ""
"Retorna o tamanho aproximado da fila. Note que qsize() > 0 não garante que "
"um get() subsequente não bloqueie."

msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``False`` it doesn't guarantee that a subsequent call to get() will "
"not block."
msgstr ""
"Retorna ``True`` se a fila estiver vazia, ``False`` caso contrário. Se "
"empty() retornar ``False``, não garante que uma chamada subsequente a get() "
"não bloqueie."

msgid ""
"Put *item* into the queue.  The method never blocks and always succeeds "
"(except for potential low-level errors such as failure to allocate memory). "
"The optional args *block* and *timeout* are ignored and only provided for "
"compatibility with :meth:`Queue.put`."
msgstr ""
"Coloca o *item* na fila. O método nunca bloqueia e sucede sempre (exceto por "
"potenciais erros de baixo nível, como falha ao alocar memória). Os "
"argumentos opcionais *block* e *timeout* são ignorados e fornecidos apenas "
"para compatibilidade com :meth:`Queue.put`."

msgid ""
"This method has a C implementation which is reentrant.  That is, a ``put()`` "
"or ``get()`` call can be interrupted by another ``put()`` call in the same "
"thread without deadlocking or corrupting internal state inside the queue.  "
"This makes it appropriate for use in destructors such as ``__del__`` methods "
"or :mod:`weakref` callbacks."
msgstr ""
"Este método possui uma implementação em C que é reentrante. Ou seja, uma "
"chamada ``put()`` ou ``get()`` pode ser interrompida por outra chamada "
"``put()`` na mesma thread sem causar bloqueios ou corromper o estado interno "
"da fila. Isto torna-o apropriado para uso em destrutores, como os métodos "
"``__del__`` ou em chamadas de retorno (*callbacks*) de :mod:`weakref`."

msgid ""
"Equivalent to ``put(item, block=False)``, provided for compatibility with :"
"meth:`Queue.put_nowait`."
msgstr ""
"Equivalente a ``put(item, block=False)``, fornecido para compatibilidade "
"com :meth:`Queue.put_nowait`."

msgid "Class :class:`multiprocessing.Queue`"
msgstr "Classe :class:`multiprocessing.Queue`"

msgid ""
"A queue class for use in a multi-processing (rather than multi-threading) "
"context."
msgstr ""
"Uma classe de fila para uso num contexto de multi-processamento (em vez de "
"multi-threading)."

msgid ""
":class:`collections.deque` is an alternative implementation of unbounded "
"queues with fast atomic :meth:`~collections.deque.append` and :meth:"
"`~collections.deque.popleft` operations that do not require locking and also "
"support indexing."
msgstr ""
":class:`collections.deque` é uma implementação alternativa de filas "
"ilimitadas com operações :meth:`~collections.deque.append` e :meth:"
"`~collections.deque.popleft` atómicas e rápidas, que não requerem trincos e "
"também suportam indexação."
