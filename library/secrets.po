# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-07 14:20+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!secrets` --- Generate secure random numbers for managing secrets"
msgstr ""
":mod:`!secrets` --- Gerar números aleatórios seguros para gerir segredos"

msgid "**Source code:** :source:`Lib/secrets.py`"
msgstr "**Código-fonte:** :source:`Lib/secrets.py`"

msgid ""
"The :mod:`!secrets` module is used for generating cryptographically strong "
"random numbers suitable for managing data such as passwords, account "
"authentication, security tokens, and related secrets."
msgstr ""
"O módulo :mod:`!secrets` é utilizado para gerar números aleatórios "
"criptograficamente fortes, adequados para gerir dados como palavras-passe, "
"autenticação de contas, tokens de segurança e segredos relacionados."

msgid ""
"In particular, :mod:`!secrets` should be used in preference to the default "
"pseudo-random number generator in the :mod:`random` module, which is "
"designed for modelling and simulation, not security or cryptography."
msgstr ""
"Em particular, o :mod:`!secrets` deve ser utilizado preferencialmente em "
"relação ao gerador de números pseudo-aleatórios padrão do módulo :mod:"
"`random`, que é projetado para modelagem e simulação, e não para segurança "
"ou criptografia."

msgid ":pep:`506`"
msgstr ":pep:`506`"

msgid "Random numbers"
msgstr "Números aleatórios"

msgid ""
"The :mod:`!secrets` module provides access to the most secure source of "
"randomness that your operating system provides."
msgstr ""
"O módulo :mod:`!secrets` fornece acesso à fonte de aleatoriedade mais segura "
"que o seu sistema operativo disponibiliza."

msgid ""
"A class for generating random numbers using the highest-quality sources "
"provided by the operating system.  See :class:`random.SystemRandom` for "
"additional details."
msgstr ""
"Uma classe para gerar números aleatórios utilizando as fontes de maior "
"qualidade fornecidas pelo sistema operativo. Consulte :class:`random."
"SystemRandom` para detalhes adicionais."

msgid "Return a randomly chosen element from a non-empty sequence."
msgstr ""
"Retorna um elemento escolhido aleatoriamente de uma sequência não vazia."

msgid "Return a random int in the range [0, *exclusive_upper_bound*)."
msgstr ""
"Retorna um inteiro aleatório no intervalo [0, *exclusive_upper_bound*)."

msgid "Return a non-negative int with *k* random bits."
msgstr "Retorna um inteiro não negativo com *k* bits aleatórios."

msgid "Generating tokens"
msgstr "Gerar tokens"

msgid ""
"The :mod:`!secrets` module provides functions for generating secure tokens, "
"suitable for applications such as password resets, hard-to-guess URLs, and "
"similar."
msgstr ""
"O módulo :mod:`!secrets` fornece funções para gerar tokens seguros, "
"adequados para aplicações como redefinição de palavras-passe, URLs difíceis "
"de adivinhar e semelhantes."

msgid ""
"Return a random byte string containing *nbytes* number of bytes. If *nbytes* "
"is ``None`` or not supplied, a reasonable default is used."
msgstr ""
"Retorna uma string de bytes aleatória contendo *nbytes* número de bytes. Se "
"*nbytes* for ``None`` ou não for fornecido, é utilizado um valor padrão "
"razoável."

msgid ""
">>> token_bytes(16)\n"
"b'\\xebr\\x17D*t\\xae\\xd4\\xe3S\\xb6\\xe2\\xebP1\\x8b'"
msgstr ""

msgid ""
"Return a random text string, in hexadecimal.  The string has *nbytes* random "
"bytes, each byte converted to two hex digits.  If *nbytes* is ``None`` or "
"not supplied, a reasonable default is used."
msgstr ""
"Retorna uma string de texto aleatória, em hexadecimal. A string possui "
"*nbytes* bytes aleatórios, sendo cada byte convertido em dois dígitos "
"hexadecimais. Se *nbytes* for ``None`` ou não for fornecido, é utilizado um "
"valor padrão razoável."

msgid ""
">>> token_hex(16)\n"
"'f9bf78b9a18ce6d46a0cd2b0b86df9da'"
msgstr ""

msgid ""
"Return a random URL-safe text string, containing *nbytes* random bytes.  The "
"text is Base64 encoded, so on average each byte results in approximately 1.3 "
"characters.  If *nbytes* is ``None`` or not supplied, a reasonable default "
"is used."
msgstr ""
"Retorna uma string de texto aleatória segura para URLs (URL-safe), contendo "
"*nbytes* bytes aleatórios. O texto é codificado em Base64, pelo que, em "
"média, cada byte resulta em aproximadamente 1,3 caracteres. Se *nbytes* for "
"``None`` ou não for fornecido, é utilizado um valor padrão razoável."

msgid ""
">>> token_urlsafe(16)\n"
"'Drmhze6EPcv0fN_81Bj-nA'"
msgstr ""

msgid "How many bytes should tokens use?"
msgstr "Quantos bytes devem os tokens utilizar?"

msgid ""
"To be secure against `brute-force attacks <https://en.wikipedia.org/wiki/"
"Brute-force_attack>`_, tokens need to have sufficient randomness.  "
"Unfortunately, what is considered sufficient will necessarily increase as "
"computers get more powerful and able to make more guesses in a shorter "
"period.  As of 2015, it is believed that 32 bytes (256 bits) of randomness "
"is sufficient for the typical use-case expected for the :mod:`!secrets` "
"module."
msgstr ""
"Para serem seguros contra `ataques de força bruta <https://pt.wikipedia.org/"
"wiki/Ataque_de_for%C3%A7a_bruta>`_, os tokens precisam de ter aleatoriedade "
"suficiente. Infelizmente, o que é considerado suficiente aumentará "
"necessariamente à medida que os computadores se tornam mais potentes e "
"capazes de realizar mais tentativas num período mais curto. Desde 2015, "
"acredita-se que 32 bytes (256 bits) de aleatoriedade sejam suficientes para "
"o caso de utilização típico esperado para o módulo :mod:`!secrets`."

msgid ""
"For those who want to manage their own token length, you can explicitly "
"specify how much randomness is used for tokens by giving an :class:`int` "
"argument to the various ``token_*`` functions.  That argument is taken as "
"the number of bytes of randomness to use."
msgstr ""
"Para quem deseja gerir o comprimento do seu próprio token, pode especificar "
"explicitamente quanta aleatoriedade é utilizada para os tokens, fornecendo "
"um argumento :class:`int` às várias funções ``token_*``. Esse argumento é "
"considerado como o número de bytes de aleatoriedade a utilizar."

msgid ""
"Otherwise, if no argument is provided, or if the argument is ``None``, the "
"``token_*`` functions will use a reasonable default instead."
msgstr ""
"Caso contrário, se nenhum argumento for fornecido, ou se o argumento for "
"``None``, as funções ``token_*`` utilizarão um valor padrão razoável."

msgid ""
"That default is subject to change at any time, including during maintenance "
"releases."
msgstr ""
"Esse valor padrão está sujeito a alterações a qualquer momento, inclusive "
"durante lançamentos de manutenção."

msgid "Other functions"
msgstr "Outras funções"

msgid ""
"Return ``True`` if strings or :term:`bytes-like objects <bytes-like object>` "
"*a* and *b* are equal, otherwise ``False``, using a \"constant-time "
"compare\" to reduce the risk of `timing attacks <https://codahale.com/a-"
"lesson-in-timing-attacks/>`_. See :func:`hmac.compare_digest` for additional "
"details."
msgstr ""
"Retorna ``True`` se as strings ou :term:`objetos do tipo bytes <bytes-like "
"object>` *a* e *b* forem iguais, caso contrário ``False``, utilizando uma "
"\"comparação em tempo constante\" para reduzir o risco de `ataques de "
"temporização <https://codahale.com/a-lesson-in-timing-attacks/>`_. Consulte :"
"func:`hmac.compare_digest` para detalhes adicionais."

msgid "Recipes and best practices"
msgstr "Receitas e boas práticas"

msgid ""
"This section shows recipes and best practices for using :mod:`!secrets` to "
"manage a basic level of security."
msgstr ""
"Esta secção mostra receitas e boas práticas para utilizar o :mod:`!secrets` "
"para gerir um nível básico de segurança."

msgid "Generate an eight-character alphanumeric password:"
msgstr "Gerar uma palavra-passe alfanumérica de oito caracteres:"

msgid ""
"import string\n"
"import secrets\n"
"alphabet = string.ascii_letters + string.digits\n"
"password = ''.join(secrets.choice(alphabet) for i in range(8))"
msgstr ""

msgid ""
"Applications should not :cwe:`store passwords in a recoverable format "
"<257>`, whether plain text or encrypted.  They should be salted and hashed "
"using a cryptographically strong one-way (irreversible) hash function."
msgstr ""
"As aplicações não devem :cwe:`armazenar palavras-passe num formato "
"recuperável <257>`, seja em texto simples ou encriptado. Elas devem ser alvo "
"de \"salting\" e convertidas em hash utilizando uma função de hash "
"unidirecional (irreversível) criptograficamente forte."

msgid ""
"Generate a ten-character alphanumeric password with at least one lowercase "
"character, at least one uppercase character, and at least three digits:"
msgstr ""
"Gerar uma palavra-passe alfanumérica de dez caracteres com pelo menos um "
"caractere minúsculo, pelo menos um caractere maiúsculo e pelo menos três "
"dígitos:"

msgid ""
"import string\n"
"import secrets\n"
"alphabet = string.ascii_letters + string.digits\n"
"while True:\n"
"    password = ''.join(secrets.choice(alphabet) for i in range(10))\n"
"    if (any(c.islower() for c in password)\n"
"            and any(c.isupper() for c in password)\n"
"            and sum(c.isdigit() for c in password) >= 3):\n"
"        break"
msgstr ""

msgid "Generate an `XKCD-style passphrase <https://xkcd.com/936/>`_:"
msgstr "Gerar uma `passphrase ao estilo XKCD <https://xkcd.com/936/>`_:"

msgid ""
"import secrets\n"
"# On standard Linux systems, use a convenient dictionary file.\n"
"# Other platforms may need to provide their own word-list.\n"
"with open('/usr/share/dict/words') as f:\n"
"    words = [word.strip() for word in f]\n"
"    password = ' '.join(secrets.choice(words) for i in range(4))"
msgstr ""

msgid ""
"Generate a hard-to-guess temporary URL containing a security token suitable "
"for password recovery applications:"
msgstr ""
"Gerar um URL temporário difícil de adivinhar contendo um token de segurança "
"adequado para aplicações de recuperação de palavra-passe:"

msgid ""
"import secrets\n"
"url = 'https://example.com/reset=' + secrets.token_urlsafe()"
msgstr ""
