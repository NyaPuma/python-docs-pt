# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-07 14:20+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!timeit` --- Measure execution time of small code snippets"
msgstr ""
":mod:`!timeit` --- Medir o tempo de execução de pequenos fragmentos de código"

msgid "**Source code:** :source:`Lib/timeit.py`"
msgstr "**Código-fonte:** :source:`Lib/timeit.py`"

msgid ""
"This module provides a simple way to time small bits of Python code. It has "
"both a :ref:`timeit-command-line-interface` as well as a :ref:`callable "
"<python-interface>` one.  It avoids a number of common traps for measuring "
"execution times. See also Tim Peters' introduction to the \"Algorithms\" "
"chapter in the second edition of *Python Cookbook*, published by O'Reilly."
msgstr ""
"Este módulo fornece uma forma simples de cronometrar pequenos pedaços de "
"código Python. Possui tanto uma :ref:`timeit-command-line-interface` como "
"uma :ref:`interface chamável (callable) <python-interface>`. Evita uma série "
"de armadilhas comuns ao medir tempos de execução. Consulte também a "
"introdução de Tim Peters ao capítulo \"Algorithms\" na segunda edição do "
"*Python Cookbook*, publicado pela O'Reilly."

msgid "Basic Examples"
msgstr "Exemplos Básicos"

msgid ""
"The following example shows how the :ref:`timeit-command-line-interface` can "
"be used to compare three different expressions:"
msgstr ""
"O seguinte exemplo mostra como a :ref:`timeit-command-line-interface` pode "
"ser usada para comparar três expressões diferentes:"

msgid ""
"$ python -m timeit \"'-'.join(str(n) for n in range(100))\"\n"
"10000 loops, best of 5: 30.2 usec per loop\n"
"$ python -m timeit \"'-'.join([str(n) for n in range(100)])\"\n"
"10000 loops, best of 5: 27.5 usec per loop\n"
"$ python -m timeit \"'-'.join(map(str, range(100)))\"\n"
"10000 loops, best of 5: 23.2 usec per loop"
msgstr ""

msgid "This can be achieved from the :ref:`python-interface` with::"
msgstr "Isto pode ser alcançado a partir da :ref:`python-interface` com::"

msgid ""
">>> import timeit\n"
">>> timeit.timeit('\"-\".join(str(n) for n in range(100))', number=10000)\n"
"0.3018611848820001\n"
">>> timeit.timeit('\"-\".join([str(n) for n in range(100)])', number=10000)\n"
"0.2727368790656328\n"
">>> timeit.timeit('\"-\".join(map(str, range(100)))', number=10000)\n"
"0.23702679807320237"
msgstr ""

msgid "A callable can also be passed from the :ref:`python-interface`::"
msgstr ""
"Um objeto chamável (callable) também pode ser passado a partir da :ref:"
"`python-interface`::"

msgid ""
">>> timeit.timeit(lambda: \"-\".join(map(str, range(100))), number=10000)\n"
"0.19665591977536678"
msgstr ""

msgid ""
"Note however that :func:`.timeit` will automatically determine the number of "
"repetitions only when the command-line interface is used.  In the :ref:"
"`timeit-examples` section you can find more advanced examples."
msgstr ""
"Note, no entanto, que :func:`.timeit` determinará automaticamente o número "
"de repetições apenas quando a interface de linha de comandos for utilizada. "
"Na secção :ref:`timeit-examples` pode encontrar exemplos mais avançados."

msgid "Python Interface"
msgstr "Interface Python"

msgid "The module defines three convenience functions and a public class:"
msgstr "O módulo define três funções de conveniência e uma classe pública:"

msgid ""
"Create a :class:`Timer` instance with the given statement, *setup* code and "
"*timer* function and run its :meth:`.timeit` method with *number* "
"executions. The optional *globals* argument specifies a namespace in which "
"to execute the code."
msgstr ""
"Cria uma instância de :class:`Timer` com a instrução (statement) dada, "
"código de *setup* e função *timer*, e executa o seu método :meth:`.timeit` "
"com *number* execuções. O argumento opcional *globals* especifica um "
"namespace no qual o código será executado."

msgid "The optional *globals* parameter was added."
msgstr "O parâmetro opcional *globals* foi adicionado."

msgid ""
"Create a :class:`Timer` instance with the given statement, *setup* code and "
"*timer* function and run its :meth:`.repeat` method with the given *repeat* "
"count and *number* executions.  The optional *globals* argument specifies a "
"namespace in which to execute the code."
msgstr ""
"Cria uma instância de :class:`Timer` com a instrução dada, código de *setup* "
"e função *timer*, e executa o seu método :meth:`.repeat` com a contagem de "
"*repeat* e *number* execuções dadas. O argumento opcional *globals* "
"especifica um namespace no qual o código será executado."

msgid "Default value of *repeat* changed from 3 to 5."
msgstr "O valor por defeito de *repeat* mudou de 3 para 5."

msgid ""
"The default timer, which is always time.perf_counter(), returns float "
"seconds. An alternative, time.perf_counter_ns, returns integer nanoseconds."
msgstr ""
"O temporizador por defeito, que é sempre time.perf_counter(), devolve "
"segundos em float. Uma alternativa, time.perf_counter_ns, devolve "
"nanossegundos em inteiro."

msgid ":func:`time.perf_counter` is now the default timer."
msgstr ":func:`time.perf_counter` é agora o temporizador por defeito."

msgid "Class for timing execution speed of small code snippets."
msgstr ""
"Classe para cronometrar a velocidade de execução de pequenos fragmentos de "
"código."

msgid ""
"The constructor takes a statement to be timed, an additional statement used "
"for setup, and a timer function.  Both statements default to ``'pass'``; the "
"timer function is platform-dependent (see the module doc string). *stmt* and "
"*setup* may also contain multiple statements separated by ``;`` or newlines, "
"as long as they don't contain multi-line string literals.  The statement "
"will by default be executed within timeit's namespace; this behavior can be "
"controlled by passing a namespace to *globals*."
msgstr ""
"O construtor aceita uma instrução a ser cronometrada, uma instrução "
"adicional usada para configuração (setup) e uma função de temporizador. "
"Ambas as instruções têm como valor por defeito ``'pass'``; a função de "
"temporizador depende da plataforma (ver a docstring do módulo). *stmt* e "
"*setup* também podem conter múltiplas instruções separadas por ``;`` ou "
"quebras de linha, desde que não contenham literais de string multi-linha. A "
"instrução será, por defeito, executada dentro do namespace do timeit; este "
"comportamento pode ser controlado passando um namespace para *globals*."

msgid ""
"To measure the execution time of the first statement, use the :meth:`."
"timeit` method.  The :meth:`.repeat` and :meth:`.autorange` methods are "
"convenience methods to call :meth:`.timeit` multiple times."
msgstr ""
"Para medir o tempo de execução da primeira instrução, use o método :meth:`."
"timeit`. Os métodos :meth:`.repeat` e :meth:`.autorange` são métodos de "
"conveniência para chamar :meth:`.timeit` múltiplas vezes."

msgid ""
"The execution time of *setup* is excluded from the overall timed execution "
"run."
msgstr ""
"O tempo de execução do *setup* é excluído da execução cronometrada global."

msgid ""
"The *stmt* and *setup* parameters can also take objects that are callable "
"without arguments.  This will embed calls to them in a timer function that "
"will then be executed by :meth:`.timeit`.  Note that the timing overhead is "
"a little larger in this case because of the extra function calls."
msgstr ""
"Os parâmetros *stmt* e *setup* também podem aceitar objetos que sejam "
"chamáveis sem argumentos. Isto embutirá as chamadas aos mesmos numa função "
"de temporizador que será depois executada por :meth:`.timeit`. Note que a "
"sobrecarga (overhead) de temporização é um pouco maior neste caso devido às "
"chamadas de função extra."

msgid ""
"Time *number* executions of the main statement.  This executes the setup "
"statement once, and then returns the time it takes to execute the main "
"statement a number of times.  The default timer returns seconds as a float. "
"The argument is the number of times through the loop, defaulting to one "
"million.  The main statement, the setup statement and the timer function to "
"be used are passed to the constructor."
msgstr ""
"Cronometra *number* execuções da instrução principal. Isto executa a "
"instrução de setup uma vez e depois devolve o tempo necessário para executar "
"a instrução principal um determinado número de vezes. O temporizador por "
"defeito devolve segundos como float. O argumento é o número de vezes que o "
"loop é percorrido, sendo o valor por defeito um milhão. A instrução "
"principal, a instrução de setup e a função de temporizador a utilizar são "
"passadas ao construtor."

msgid ""
"By default, :meth:`.timeit` temporarily turns off :term:`garbage collection` "
"during the timing.  The advantage of this approach is that it makes "
"independent timings more comparable.  The disadvantage is that GC may be an "
"important component of the performance of the function being measured.  If "
"so, GC can be re-enabled as the first statement in the *setup* string.  For "
"example::"
msgstr ""
"Por defeito, o :meth:`.timeit` desativa temporariamente o :term:`garbage "
"collection` (recolha de lixo) durante a medição. A vantagem desta abordagem "
"é que torna as medições independentes mais comparáveis. A desvantagem é que "
"o GC pode ser um componente importante do desempenho da função que está a "
"ser medida. Se for o caso, o GC pode ser reativado como a primeira instrução "
"na string de *setup*. Por exemplo::"

msgid "timeit.Timer('for i in range(10): oct(i)', 'gc.enable()').timeit()"
msgstr ""

msgid "Automatically determine how many times to call :meth:`.timeit`."
msgstr "Determina automaticamente quantas vezes chamar o :meth:`.timeit`."

msgid ""
"This is a convenience function that calls :meth:`.timeit` repeatedly so that "
"the total time >= 0.2 second, returning the eventual (number of loops, time "
"taken for that number of loops). It calls :meth:`.timeit` with increasing "
"numbers from the sequence 1, 2, 5, 10, 20, 50, ... until the time taken is "
"at least 0.2 seconds."
msgstr ""
"Esta é uma função de conveniência que chama o :meth:`.timeit` repetidamente "
"para que o tempo total seja >= 0.2 segundos, devolvendo o resultado final "
"(número de loops, tempo gasto para esse número de loops). Chama o :meth:`."
"timeit` com números crescentes da sequência 1, 2, 5, 10, 20, 50, ... até que "
"o tempo gasto seja de pelo menos 0.2 segundos."

msgid ""
"If *callback* is given and is not ``None``, it will be called after each "
"trial with two arguments: ``callback(number, time_taken)``."
msgstr ""
"Se o *callback* for fornecido e não for ``None``, será chamado após cada "
"ensaio com dois argumentos: ``callback(number, time_taken)``."

msgid "Call :meth:`.timeit` a few times."
msgstr "Chama o :meth:`.timeit` algumas vezes."

msgid ""
"This is a convenience function that calls the :meth:`.timeit` repeatedly, "
"returning a list of results.  The first argument specifies how many times to "
"call :meth:`.timeit`.  The second argument specifies the *number* argument "
"for :meth:`.timeit`."
msgstr ""
"Esta é uma função de conveniência que chama o :meth:`.timeit` repetidamente, "
"devolvendo uma lista de resultados. O primeiro argumento especifica quantas "
"vezes chamar o :meth:`.timeit`. O segundo argumento especifica o argumento "
"*number* para o :meth:`.timeit`."

msgid ""
"It's tempting to calculate mean and standard deviation from the result "
"vector and report these.  However, this is not very useful. In a typical "
"case, the lowest value gives a lower bound for how fast your machine can run "
"the given code snippet; higher values in the result vector are typically not "
"caused by variability in Python's speed, but by other processes interfering "
"with your timing accuracy. So the :func:`min` of the result is probably the "
"only number you should be interested in.  After that, you should look at the "
"entire vector and apply common sense rather than statistics."
msgstr ""
"É tentador calcular a média e o desvio padrão a partir do vetor de "
"resultados e reportá-los. No entanto, isto não é muito útil. Num caso "
"típico, o valor mais baixo fornece um limite inferior de quão rápido a sua "
"máquina consegue executar o fragmento de código; valores mais altos no vetor "
"de resultados não são tipicamente causados pela variabilidade da velocidade "
"do Python, mas sim por outros processos que interferem com a precisão da "
"temporização. Portanto, o :func:`min` do resultado é provavelmente o único "
"número em que deverá estar interessado. Depois disso, deverá olhar para o "
"vetor completo e aplicar o senso comum em vez de estatística."

msgid "Helper to print a traceback from the timed code."
msgstr "Auxiliar para imprimir um traceback do código cronometrado."

msgid "Typical use::"
msgstr "Utilização típica::"

msgid ""
"t = Timer(...)       # outside the try/except\n"
"try:\n"
"    t.timeit(...)    # or t.repeat(...)\n"
"except Exception:\n"
"    t.print_exc()"
msgstr ""

msgid ""
"The advantage over the standard traceback is that source lines in the "
"compiled template will be displayed.  The optional *file* argument directs "
"where the traceback is sent; it defaults to :data:`sys.stderr`."
msgstr ""
"A vantagem sobre o traceback padrão é que as linhas de código fonte no "
"modelo compilado serão exibidas. O argumento opcional *file* direciona para "
"onde o traceback é enviado; o valor por defeito é :data:`sys.stderr`."

msgid "Command-Line Interface"
msgstr "Interface de Linha de Comandos"

msgid ""
"When called as a program from the command line, the following form is used::"
msgstr ""

msgid ""
"python -m timeit [-n N] [-r N] [-u U] [-s S] [-p] [-v] [-h] [statement ...]"
msgstr ""

msgid "Where the following options are understood:"
msgstr "Onde as seguintes opções são compreendidas:"

msgid "how many times to execute 'statement'"
msgstr "quantas vezes executar a 'instrução'"

msgid "how many times to repeat the timer (default 5)"
msgstr "quantas vezes repetir o temporizador (por defeito 5)"

msgid "statement to be executed once initially (default ``pass``)"
msgstr "instrução a ser executada uma vez inicialmente (por defeito ``pass``)"

msgid ""
"measure process time, not wallclock time, using :func:`time.process_time` "
"instead of :func:`time.perf_counter`, which is the default"
msgstr ""
"medir o tempo de processo, não o tempo de relógio (wallclock), usando :func:"
"`time.process_time` em vez de :func:`time.perf_counter`, que é o padrão"

msgid ""
"specify a time unit for timer output; can select ``nsec``, ``usec``, "
"``msec``, or ``sec``"
msgstr ""
"especificar uma unidade de tempo para a saída do temporizador; pode "
"selecionar ``nsec``, ``usec``, ``msec``, ou ``sec``"

msgid "print raw timing results; repeat for more digits precision"
msgstr ""
"imprimir resultados brutos (raw); repetir para mais dígitos de precisão"

msgid "print a short usage message and exit"
msgstr "imprimir uma mensagem curta de utilização e sair"

msgid ""
"A multi-line statement may be given by specifying each line as a separate "
"statement argument; indented lines are possible by enclosing an argument in "
"quotes and using leading spaces.  Multiple :option:`-s` options are treated "
"similarly."
msgstr ""
"Uma instrução multi-linha pode ser fornecida especificando cada linha como "
"um argumento de instrução separado; linhas indentadas são possíveis ao "
"envolver um argumento em aspas e usar espaços no início. Múltiplas opções :"
"option:`-s` são tratadas de forma semelhante."

msgid ""
"If :option:`-n` is not given, a suitable number of loops is calculated by "
"trying increasing numbers from the sequence 1, 2, 5, 10, 20, 50, ... until "
"the total time is at least 0.2 seconds."
msgstr ""
"Se :option:`-n` não for fornecido, um número adequado de loops é calculado "
"testando números crescentes da sequência 1, 2, 5, 10, 20, 50, ... até que o "
"tempo total seja de pelo menos 0.2 segundos."

msgid ""
":func:`default_timer` measurements can be affected by other programs running "
"on the same machine, so the best thing to do when accurate timing is "
"necessary is to repeat the timing a few times and use the best time.  The :"
"option:`-r` option is good for this; the default of 5 repetitions is "
"probably enough in most cases.  You can use :func:`time.process_time` to "
"measure CPU time."
msgstr ""
"As medições do :func:`default_timer` podem ser afetadas por outros programas "
"a correr na mesma máquina, por isso a melhor coisa a fazer quando é "
"necessária uma medição precisa é repetir a cronometragem algumas vezes e "
"usar o melhor tempo. A opção :option:`-r` é boa para isto; o padrão de 5 "
"repetições é provavelmente suficiente na maioria dos casos. Pode usar :func:"
"`time.process_time` para medir o tempo de CPU."

msgid ""
"There is a certain baseline overhead associated with executing a pass "
"statement. The code here doesn't try to hide it, but you should be aware of "
"it.  The baseline overhead can be measured by invoking the program without "
"arguments, and it might differ between Python versions."
msgstr ""
"Existe uma certa sobrecarga base (baseline overhead) associada à execução de "
"uma instrução pass. O código aqui não tenta escondê-la, mas deve estar "
"ciente disso. A sobrecarga base pode ser medida invocando o programa sem "
"argumentos, e pode variar entre versões do Python."

msgid "Examples"
msgstr "Exemplos"

msgid ""
"It is possible to provide a setup statement that is executed only once at "
"the beginning:"
msgstr ""
"É possível fornecer uma instrução de setup que é executada apenas uma vez no "
"início:"

msgid ""
"$ python -m timeit -s \"text = 'sample string'; char = 'g'\" \"char in "
"text\"\n"
"5000000 loops, best of 5: 0.0877 usec per loop\n"
"$ python -m timeit -s \"text = 'sample string'; char = 'g'\" \"text."
"find(char)\"\n"
"1000000 loops, best of 5: 0.342 usec per loop"
msgstr ""

msgid ""
"In the output, there are three fields. The loop count, which tells you how "
"many times the statement body was run per timing loop repetition. The "
"repetition count ('best of 5') which tells you how many times the timing "
"loop was repeated, and finally the time the statement body took on average "
"within the best repetition of the timing loop. That is, the time the fastest "
"repetition took divided by the loop count."
msgstr ""
"Na saída, existem três campos. A contagem de loops (loop count), que lhe diz "
"quantas vezes o corpo da instrução foi executado por cada repetição do loop "
"de cronometragem. A contagem de repetições ('best of 5'), que lhe diz "
"quantas vezes o loop de cronometragem foi repetido, e finalmente o tempo "
"médio que o corpo da instrução levou dentro da melhor repetição. Ou seja, o "
"tempo que a repetição mais rápida levou dividido pela contagem de loops."

msgid ""
">>> import timeit\n"
">>> timeit.timeit('char in text', setup='text = \"sample string\"; char = "
"\"g\"')\n"
"0.41440500499993504\n"
">>> timeit.timeit('text.find(char)', setup='text = \"sample string\"; char = "
"\"g\"')\n"
"1.7246671520006203"
msgstr ""

msgid "The same can be done using the :class:`Timer` class and its methods::"
msgstr ""
"O mesmo pode ser feito usando a classe :class:`Timer` e os seus métodos::"

msgid ""
">>> import timeit\n"
">>> t = timeit.Timer('char in text', setup='text = \"sample string\"; char = "
"\"g\"')\n"
">>> t.timeit()\n"
"0.3955516149999312\n"
">>> t.repeat()\n"
"[0.40183617287970225, 0.37027556854118704, 0.38344867356679524, "
"0.3712595970846668, 0.37866875250654886]"
msgstr ""

msgid ""
"The following examples show how to time expressions that contain multiple "
"lines. Here we compare the cost of using :func:`hasattr` vs. :keyword:`try`/:"
"keyword:`except` to test for missing and present object attributes:"
msgstr ""
"Os seguintes exemplos mostram como cronometrar expressões que contêm "
"múltiplas linhas. Aqui comparamos o custo de usar :func:`hasattr` vs. :"
"keyword:`try`/:keyword:`except` para testar atributos de objetos ausentes e "
"presentes:"

msgid ""
"$ python -m timeit \"try:\" \"  str.__bool__\" \"except AttributeError:\" "
"\"  pass\"\n"
"20000 loops, best of 5: 15.7 usec per loop\n"
"$ python -m timeit \"if hasattr(str, '__bool__'): pass\"\n"
"50000 loops, best of 5: 4.26 usec per loop\n"
"\n"
"$ python -m timeit \"try:\" \"  int.__bool__\" \"except AttributeError:\" "
"\"  pass\"\n"
"200000 loops, best of 5: 1.43 usec per loop\n"
"$ python -m timeit \"if hasattr(int, '__bool__'): pass\"\n"
"100000 loops, best of 5: 2.23 usec per loop"
msgstr ""

msgid ""
">>> import timeit\n"
">>> # attribute is missing\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     str.__bool__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.9138244460009446\n"
">>> s = \"if hasattr(str, '__bool__'): pass\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.5829014980008651\n"
">>>\n"
">>> # attribute is present\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     int.__bool__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.04215312199994514\n"
">>> s = \"if hasattr(int, '__bool__'): pass\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.08588060699912603"
msgstr ""

msgid ""
"To give the :mod:`!timeit` module access to functions you define, you can "
"pass a *setup* parameter which contains an import statement::"
msgstr ""

msgid ""
"def test():\n"
"    \"\"\"Stupid test function\"\"\"\n"
"    L = [i for i in range(100)]\n"
"\n"
"if __name__ == '__main__':\n"
"    import timeit\n"
"    print(timeit.timeit(\"test()\", setup=\"from __main__ import test\"))"
msgstr ""

msgid ""
"Another option is to pass :func:`globals` to the  *globals* parameter, which "
"will cause the code to be executed within your current global namespace.  "
"This can be more convenient than individually specifying imports::"
msgstr ""
"Outra opção é passar :func:`globals` para o parâmetro *globals*, o que fará "
"com que o código seja executado dentro do seu namespace global atual. Isto "
"pode ser mais conveniente do que especificar importações individualmente::"

msgid ""
"def f(x):\n"
"    return x**2\n"
"def g(x):\n"
"    return x**4\n"
"def h(x):\n"
"    return x**8\n"
"\n"
"import timeit\n"
"print(timeit.timeit('[func(42) for func in (f,g,h)]', globals=globals()))"
msgstr ""

msgid "Benchmarking"
msgstr "Benchmarking"

msgid "Performance"
msgstr "Desempenho"
