# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-03 14:40+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!xmlrpc.server` --- Basic XML-RPC servers"
msgstr ":mod:`!xmlrpc.server` --- Servidores XML-RPC básicos"

msgid "**Source code:** :source:`Lib/xmlrpc/server.py`"
msgstr "**Código-fonte:** :source:`Lib/xmlrpc/server.py`"

msgid ""
"The :mod:`xmlrpc.server` module provides a basic server framework for XML-"
"RPC servers written in Python.  Servers can either be free standing, using :"
"class:`SimpleXMLRPCServer`, or embedded in a CGI environment, using :class:"
"`CGIXMLRPCRequestHandler`."
msgstr ""
"O módulo :mod:`xmlrpc.server` fornece uma infraestrutura básica para "
"servidores XML-RPC escritos em Python. Os servidores podem ser autónomos, "
"usando :class:`SimpleXMLRPCServer`, ou integrados num ambiente CGI, usando :"
"class:`CGIXMLRPCRequestHandler`."

msgid ""
"The :mod:`xmlrpc.server` module is not secure against maliciously "
"constructed data.  If you need to parse untrusted or unauthenticated data, "
"see :ref:`xml-security`."
msgstr ""
"O módulo :mod:`xmlrpc.server` não é seguro contra dados construídos "
"maliciosamente. Se precisar de processar dados não confiáveis ou não "
"autenticados, consulte :ref:`xml-security`."

msgid "Availability"
msgstr "Disponibilidade"

msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Este módulo não funciona ou não está disponível em WebAssembly. Consulte :"
"ref:`wasm-availability` para mais informações."

msgid ""
"Create a new server instance.  This class provides methods for registration "
"of functions that can be called by the XML-RPC protocol.  The "
"*requestHandler* parameter should be a factory for request handler "
"instances; it defaults to :class:`SimpleXMLRPCRequestHandler`.  The *addr* "
"and *requestHandler* parameters are passed to the :class:`socketserver."
"TCPServer` constructor.  If *logRequests* is true (the default), requests "
"will be logged; setting this parameter to false will turn off logging.   The "
"*allow_none* and *encoding* parameters are passed on to :mod:`xmlrpc.client` "
"and control the XML-RPC responses that will be returned from the server. The "
"*bind_and_activate* parameter controls whether :meth:`server_bind` and :meth:"
"`server_activate` are called immediately by the constructor; it defaults to "
"true. Setting it to false allows code to manipulate the "
"*allow_reuse_address* class variable before the address is bound. The "
"*use_builtin_types* parameter is passed to the :func:`~xmlrpc.client.loads` "
"function and controls which types are processed when date/times values or "
"binary data are received; it defaults to false."
msgstr ""

msgid "The *use_builtin_types* flag was added."
msgstr "A flag *use_builtin_types* foi adicionada."

msgid ""
"Create a new instance to handle XML-RPC requests in a CGI environment.  The "
"*allow_none* and *encoding* parameters are passed on to :mod:`xmlrpc.client` "
"and control the XML-RPC responses that will be returned from the server. The "
"*use_builtin_types* parameter is passed to the :func:`~xmlrpc.client.loads` "
"function and controls which types are processed when date/times values or "
"binary data are received; it defaults to false."
msgstr ""
"Cria uma nova instância para lidar com pedidos XML-RPC num ambiente CGI. Os "
"parâmetros *allow_none* e *encoding* são passados para :mod:`xmlrpc.client` "
"e controlam as respostas XML-RPC que serão retornadas pelo servidor. O "
"parâmetro *use_builtin_types* é passado para a função :func:`~xmlrpc.client."
"loads` e controla quais os tipos processados quando são recebidos valores de "
"data/hora ou dados binários; o valor predefinido é falso."

msgid ""
"Create a new request handler instance.  This request handler supports "
"``POST`` requests and modifies logging so that the *logRequests* parameter "
"to the :class:`SimpleXMLRPCServer` constructor parameter is honored."
msgstr ""
"Cria uma nova instância de manipulador de pedidos (*request handler*). Este "
"manipulador suporta pedidos ``POST`` e modifica o registo de log para que o "
"parâmetro *logRequests* passado ao construtor de :class:`SimpleXMLRPCServer` "
"seja respeitado."

msgid "SimpleXMLRPCServer Objects"
msgstr "Objetos SimpleXMLRPCServer"

msgid ""
"The :class:`SimpleXMLRPCServer` class is based on :class:`socketserver."
"TCPServer` and provides a means of creating simple, stand alone XML-RPC "
"servers."
msgstr ""
"A classe :class:`SimpleXMLRPCServer` é baseada em :class:`socketserver."
"TCPServer` e fornece um meio de criar servidores XML-RPC simples e autónomos."

msgid ""
"Register a function that can respond to XML-RPC requests.  If *name* is "
"given, it will be the method name associated with *function*, otherwise :"
"attr:`function.__name__` will be used.  *name* is a string, and may contain "
"characters not legal in Python identifiers, including the period character."
msgstr ""
"Regista uma função que pode responder a pedidos XML-RPC. Se *name* for "
"fornecido, será o nome do método associado à *function*, caso contrário será "
"usado :attr:`function.__name__`. *name* é uma string e pode conter "
"caracteres não permitidos em identificadores Python, incluindo o ponto."

msgid ""
"This method can also be used as a decorator.  When used as a decorator, "
"*name* can only be given as a keyword argument to register *function* under "
"*name*.  If no *name* is given, :attr:`function.__name__` will be used."
msgstr ""
"Este método também pode ser usado como um decorador. Quando usado como "
"decorador, o *name* só pode ser passado como um argumento de palavra-chave "
"para registar a *function* sob esse *name*. Se nenhum *name* for fornecido, "
"será usado :attr:`function.__name__`."

msgid ":meth:`register_function` can be used as a decorator."
msgstr ":meth:`register_function` pode ser usado como um decorador."

msgid ""
"Register an object which is used to expose method names which have not been "
"registered using :meth:`register_function`.  If *instance* contains a :meth:"
"`_dispatch` method, it is called with the requested method name and the "
"parameters from the request.  Its API is ``def _dispatch(self, method, "
"params)`` (note that *params* does not represent a variable argument list).  "
"If it calls an underlying function to perform its task, that function is "
"called as ``func(*params)``, expanding the parameter list. The return value "
"from :meth:`_dispatch` is returned to the client as the result.  If "
"*instance* does not have a :meth:`_dispatch` method, it is searched for an "
"attribute matching the name of the requested method."
msgstr ""
"Regista um objeto que é usado para expor nomes de métodos que não foram "
"registados usando :meth:`register_function`. Se *instance* contiver um "
"método :meth:`_dispatch`, este é chamado com o nome do método solicitado e "
"os parâmetros do pedido. A sua API é ``def _dispatch(self, method, params)`` "
"(note que *params* não representa uma lista variável de argumentos). Se "
"chamar uma função subjacente para realizar a tarefa, essa função é chamada "
"como ``func(*params)``, expandindo a lista de parâmetros. O valor de retorno "
"de :meth:`_dispatch` é devolvido ao cliente como resultado. Se *instance* "
"não tiver um método :meth:`_dispatch`, é procurado um atributo que "
"corresponda ao nome do método solicitado."

msgid ""
"If the optional *allow_dotted_names* argument is true and the instance does "
"not have a :meth:`_dispatch` method, then if the requested method name "
"contains periods, each component of the method name is searched for "
"individually, with the effect that a simple hierarchical search is "
"performed.  The value found from this search is then called with the "
"parameters from the request, and the return value is passed back to the "
"client."
msgstr ""
"Se o argumento opcional *allow_dotted_names* for verdadeiro e a instância "
"não tiver um método :meth:`_dispatch`, então, se o nome do método solicitado "
"contiver pontos, cada componente do nome do método é pesquisado "
"individualmente, resultando numa pesquisa hierárquica simples. O valor "
"encontrado nesta pesquisa é então chamado com os parâmetros do pedido e o "
"valor de retorno é enviado de volta para o cliente."

msgid ""
"Enabling the *allow_dotted_names* option allows intruders to access your "
"module's global variables and may allow intruders to execute arbitrary code "
"on your machine.  Only use this option on a secure, closed network."
msgstr ""
"Ativar a opção *allow_dotted_names* permite que intrusos acedam às variáveis "
"globais do seu módulo e pode permitir que executem código arbitrário na sua "
"máquina. Utilize esta opção apenas numa rede segura e fechada."

msgid ""
"Registers the XML-RPC introspection functions ``system.listMethods``, "
"``system.methodHelp`` and ``system.methodSignature``."
msgstr ""
"Regista as funções de introspeção XML-RPC ``system.listMethods``, ``system."
"methodHelp`` e ``system.methodSignature``."

msgid "Registers the XML-RPC multicall function system.multicall."
msgstr "Regista a função de multicall XML-RPC system.multicall."

msgid ""
"An attribute value that must be a tuple listing valid path portions of the "
"URL for receiving XML-RPC requests.  Requests posted to other paths will "
"result in a 404 \"no such page\" HTTP error.  If this tuple is empty, all "
"paths will be considered valid. The default value is ``('/', '/RPC2')``."
msgstr ""
"Um valor de atributo que deve ser um tuplo listando partes válidas do "
"caminho do URL para receber pedidos XML-RPC. Pedidos enviados para outros "
"caminhos resultarão num erro HTTP 404 \"no such page\". Se este tuplo "
"estiver vazio, todos os caminhos serão considerados válidos. O valor "
"predefinido é ``('/', '/RPC2')``."

msgid "SimpleXMLRPCServer Example"
msgstr "Exemplo de SimpleXMLRPCServer"

msgid "Server code::"
msgstr "Código do servidor::"

msgid ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"# Restrict to a particular path.\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"# Create server\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # Register pow() function; this will use the value of\n"
"    # pow.__name__ as the name, which is just 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # Register a function under a different name\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"    server.register_function(adder_function, 'add')\n"
"\n"
"    # Register an instance; all the methods of the instance are\n"
"    # published as XML-RPC methods (in this case, just 'mul').\n"
"    class MyFuncs:\n"
"        def mul(self, x, y):\n"
"            return x * y\n"
"\n"
"    server.register_instance(MyFuncs())\n"
"\n"
"    # Run the server's main loop\n"
"    server.serve_forever()"
msgstr ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"# Restringir a um caminho específico.\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"# Criar servidor\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # Registar a função pow(); isto usará o valor de\n"
"    # pow.__name__ como nome, que é apenas 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # Registar uma função sob um nome diferente\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"    server.register_function(adder_function, 'add')\n"
"\n"
"    # Registar uma instância; todos os métodos da instância são\n"
"    # publicados como métodos XML-RPC (neste caso, apenas 'mul').\n"
"    class MyFuncs:\n"
"        def mul(self, x, y):\n"
"            return x * y\n"
"\n"
"    server.register_instance(MyFuncs())\n"
"\n"
"    # Correr o loop principal do servidor\n"
"    server.serve_forever()"

msgid ""
"The following client code will call the methods made available by the "
"preceding server::"
msgstr ""
"O seguinte código de cliente chamará os métodos disponibilizados pelo "
"servidor anterior::"

msgid ""
"import xmlrpc.client\n"
"\n"
"s = xmlrpc.client.ServerProxy('http://localhost:8000')\n"
"print(s.pow(2,3))  # Returns 2**3 = 8\n"
"print(s.add(2,3))  # Returns 5\n"
"print(s.mul(5,2))  # Returns 5*2 = 10\n"
"\n"
"# Print list of available methods\n"
"print(s.system.listMethods())"
msgstr ""
"import xmlrpc.client\n"
"\n"
"s = xmlrpc.client.ServerProxy('http://localhost:8000')\n"
"print(s.pow(2,3))  # Retorna 2**3 = 8\n"
"print(s.add(2,3))  # Retorna 5\n"
"print(s.mul(5,2))  # Retorna 5*2 = 10\n"
"\n"
"# Imprimir lista de métodos disponíveis\n"
"print(s.system.listMethods())"

msgid ""
":meth:`register_function` can also be used as a decorator. The previous "
"server example can register functions in a decorator way::"
msgstr ""
":meth:`register_function` também pode ser usado como decorador. O exemplo de "
"servidor anterior pode registar funções através de decoradores::"

msgid ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # Register pow() function; this will use the value of\n"
"    # pow.__name__ as the name, which is just 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # Register a function under a different name, using\n"
"    # register_function as a decorator. *name* can only be given\n"
"    # as a keyword argument.\n"
"    @server.register_function(name='add')\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"\n"
"    # Register a function under function.__name__.\n"
"    @server.register_function\n"
"    def mul(x, y):\n"
"        return x * y\n"
"\n"
"    server.serve_forever()"
msgstr ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # Registar a função pow(); isto usará o valor de\n"
"    # pow.__name__ como nome, que é apenas 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # Registar uma função sob um nome diferente, usando\n"
"    # register_function como decorador. *name* só pode ser passado\n"
"    # como argumento de palavra-chave.\n"
"    @server.register_function(name='add')\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"\n"
"    # Registar uma função sob function.__name__.\n"
"    @server.register_function\n"
"    def mul(x, y):\n"
"        return x * y\n"
"\n"
"    server.serve_forever()"

msgid ""
"The following example included in the :file:`Lib/xmlrpc/server.py` module "
"shows a server allowing dotted names and registering a multicall function."
msgstr ""
"O seguinte exemplo incluído no módulo :file:`Lib/xmlrpc/server.py` mostra um "
"servidor que permite nomes com pontos e regista uma função multicall."

msgid ""
"Enabling the *allow_dotted_names* option allows intruders to access your "
"module's global variables and may allow intruders to execute arbitrary code "
"on your machine.  Only use this example only within a secure, closed network."
msgstr ""
"Ativar a opção *allow_dotted_names* permite que intrusos acedam às variáveis "
"globais do seu módulo e pode permitir que executem código arbitrário na sua "
"máquina. Utilize este exemplo apenas dentro de uma rede segura e fechada."

msgid ""
"import datetime\n"
"\n"
"class ExampleService:\n"
"    def getData(self):\n"
"        return '42'\n"
"\n"
"    class currentTime:\n"
"        @staticmethod\n"
"        def getCurrentTime():\n"
"            return datetime.datetime.now()\n"
"\n"
"with SimpleXMLRPCServer((\"localhost\", 8000)) as server:\n"
"    server.register_function(pow)\n"
"    server.register_function(lambda x,y: x+y, 'add')\n"
"    server.register_instance(ExampleService(), allow_dotted_names=True)\n"
"    server.register_multicall_functions()\n"
"    print('Serving XML-RPC on localhost port 8000')\n"
"    try:\n"
"        server.serve_forever()\n"
"    except KeyboardInterrupt:\n"
"        print(\"\\nKeyboard interrupt received, exiting.\")\n"
"        sys.exit(0)"
msgstr ""
"import datetime\n"
"import sys\n"
"\n"
"class ExampleService:\n"
"    def getData(self):\n"
"        return '42'\n"
"\n"
"    class currentTime:\n"
"        @staticmethod\n"
"        def getCurrentTime():\n"
"            return datetime.datetime.now()\n"
"\n"
"with SimpleXMLRPCServer((\"localhost\", 8000)) as server:\n"
"    server.register_function(pow)\n"
"    server.register_function(lambda x,y: x+y, 'add')\n"
"    server.register_instance(ExampleService(), allow_dotted_names=True)\n"
"    server.register_multicall_functions()\n"
"    print('A servir XML-RPC em localhost na porta 8000')\n"
"    try:\n"
"        server.serve_forever()\n"
"    except KeyboardInterrupt:\n"
"        print(\"\\nInterrupção de teclado recebida, a sair.\")\n"
"        sys.exit(0)"

msgid "This ExampleService demo can be invoked from the command line::"
msgstr ""
"Esta demonstração do ExampleService pode ser invocada na linha de comandos::"

msgid "python -m xmlrpc.server"
msgstr "python -m xmlrpc.server"

msgid ""
"The client that interacts with the above server is included in ``Lib/xmlrpc/"
"client.py``::"
msgstr ""
"O cliente que interage com o servidor acima está incluído em ``Lib/xmlrpc/"
"client.py``::"

msgid ""
"server = ServerProxy(\"http://localhost:8000\")\n"
"\n"
"try:\n"
"    print(server.currentTime.getCurrentTime())\n"
"except Error as v:\n"
"    print(\"ERROR\", v)\n"
"\n"
"multi = MultiCall(server)\n"
"multi.getData()\n"
"multi.pow(2,9)\n"
"multi.add(1,2)\n"
"try:\n"
"    for response in multi():\n"
"        print(response)\n"
"except Error as v:\n"
"    print(\"ERROR\", v)"
msgstr ""
"from xmlrpc.client import ServerProxy, Error, MultiCall\n"
"server = ServerProxy(\"http://localhost:8000\")\n"
"\n"
"try:\n"
"    print(server.currentTime.getCurrentTime())\n"
"except Error as v:\n"
"    print(\"ERRO\", v)\n"
"\n"
"multi = MultiCall(server)\n"
"multi.getData()\n"
"multi.pow(2,9)\n"
"multi.add(1,2)\n"
"try:\n"
"    for response in multi():\n"
"        print(response)\n"
"except Error as v:\n"
"    print(\"ERRO\", v)"

msgid ""
"This client which interacts with the demo XMLRPC server can be invoked as::"
msgstr ""
"Este cliente que interage com o servidor XMLRPC de demonstração pode ser "
"invocado como::"

msgid "python -m xmlrpc.client"
msgstr "python -m xmlrpc.client"

msgid "CGIXMLRPCRequestHandler"
msgstr "CGIXMLRPCRequestHandler"

msgid ""
"The :class:`CGIXMLRPCRequestHandler` class can be used to handle XML-RPC "
"requests sent to Python CGI scripts."
msgstr ""
"A classe :class:`CGIXMLRPCRequestHandler` pode ser usada para lidar com "
"pedidos XML-RPC enviados para scripts CGI em Python."

msgid ""
"Register an object which is used to expose method names  which have not been "
"registered using :meth:`register_function`. If  instance contains a :meth:"
"`_dispatch` method, it is called with the  requested method name and the "
"parameters from the  request; the return value is returned to the client as "
"the result. If instance does not have a :meth:`_dispatch` method, it is "
"searched for an attribute matching the name of the requested method; if  the "
"requested method name contains periods, each  component of the method name "
"is searched for individually,  with the effect that a simple hierarchical "
"search is performed. The value found from this search is then called with "
"the  parameters from the request, and the return value is passed  back to "
"the client."
msgstr ""
"Regista um objeto usado para expor nomes de métodos que não foram registados "
"com :meth:`register_function`. Se a instância contiver um método :meth:"
"`_dispatch`, este é chamado com o nome do método solicitado e os parâmetros "
"do pedido; o valor de retorno é enviado ao cliente como resultado. Se a "
"instância não tiver um método :meth:`_dispatch`, é procurado um atributo que "
"corresponda ao nome do método solicitado; se o nome do método contiver "
"pontos, cada componente é pesquisado individualmente, realizando uma "
"pesquisa hierárquica. O valor encontrado é chamado com os parâmetros do "
"pedido e o resultado é devolvido ao cliente."

msgid ""
"Register the XML-RPC introspection functions  ``system.listMethods``, "
"``system.methodHelp`` and  ``system.methodSignature``."
msgstr ""
"Regista as funções de introspeção XML-RPC ``system.listMethods``, ``system."
"methodHelp`` e ``system.methodSignature``."

msgid "Register the XML-RPC multicall function ``system.multicall``."
msgstr "Regista a função multicall XML-RPC ``system.multicall``."

msgid ""
"Handle an XML-RPC request. If *request_text* is given, it should be the POST "
"data provided by the HTTP server,  otherwise the contents of stdin will be "
"used."
msgstr ""
"Manipula um pedido XML-RPC. Se *request_text* for fornecido, deve ser os "
"dados POST disponibilizados pelo servidor HTTP, caso contrário será usado o "
"conteúdo do stdin."

msgid "Example::"
msgstr "Exemplo::"

msgid ""
"class MyFuncs:\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"\n"
"handler = CGIXMLRPCRequestHandler()\n"
"handler.register_function(pow)\n"
"handler.register_function(lambda x,y: x+y, 'add')\n"
"handler.register_introspection_functions()\n"
"handler.register_instance(MyFuncs())\n"
"handler.handle_request()"
msgstr ""
"class MyFuncs:\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"\n"
"handler = CGIXMLRPCRequestHandler()\n"
"handler.register_function(pow)\n"
"handler.register_function(lambda x,y: x+y, 'add')\n"
"handler.register_introspection_functions()\n"
"handler.register_instance(MyFuncs())\n"
"handler.handle_request()"

msgid "Documenting XMLRPC server"
msgstr "Documentar o servidor XMLRPC"

msgid ""
"These classes extend the above classes to serve HTML documentation in "
"response to HTTP GET requests.  Servers can either be free standing, using :"
"class:`DocXMLRPCServer`, or embedded in a CGI environment, using :class:"
"`DocCGIXMLRPCRequestHandler`."
msgstr ""
"Estas classes estendem as anteriores para servir documentação HTML em "
"resposta a pedidos HTTP GET. Os servidores podem ser autónomos, usando :"
"class:`DocXMLRPCServer`, ou integrados num ambiente CGI, usando :class:"
"`DocCGIXMLRPCRequestHandler`."

msgid ""
"Create a new server instance. All parameters have the same meaning as for :"
"class:`SimpleXMLRPCServer`; *requestHandler* defaults to :class:"
"`DocXMLRPCRequestHandler`."
msgstr ""
"Cria uma nova instância de servidor. Todos os parâmetros têm o mesmo "
"significado que em :class:`SimpleXMLRPCServer`; o *requestHandler* tem como "
"predefinido :class:`DocXMLRPCRequestHandler`."

msgid "Create a new instance to handle XML-RPC requests in a CGI environment."
msgstr ""
"Cria uma nova instância para lidar com pedidos XML-RPC num ambiente CGI."

msgid ""
"Create a new request handler instance. This request handler supports XML-RPC "
"POST requests, documentation GET requests, and modifies logging so that the "
"*logRequests* parameter to the :class:`DocXMLRPCServer` constructor "
"parameter is honored."
msgstr ""
"Cria uma nova instância de manipulador de pedidos. Este manipulador suporta "
"pedidos POST XML-RPC, pedidos GET de documentação e modifica o registo de "
"log para que o parâmetro *logRequests* do construtor de :class:"
"`DocXMLRPCServer` seja respeitado."

msgid "DocXMLRPCServer Objects"
msgstr "Objetos DocXMLRPCServer"

msgid ""
"The :class:`DocXMLRPCServer` class is derived from :class:"
"`SimpleXMLRPCServer` and provides a means of creating self-documenting, "
"stand alone XML-RPC servers. HTTP POST requests are handled as XML-RPC "
"method calls. HTTP GET requests are handled by generating pydoc-style HTML "
"documentation. This allows a server to provide its own web-based "
"documentation."
msgstr ""
"A classe :class:`DocXMLRPCServer` é derivada de :class:`SimpleXMLRPCServer` "
"e fornece meios de criar servidores XML-RPC autónomos e auto-documentados. "
"Pedidos HTTP POST são tratados como chamadas de método XML-RPC. Pedidos HTTP "
"GET são tratados gerando documentação HTML ao estilo pydoc. Isto permite que "
"um servidor forneça a sua própria documentação baseada na web."

msgid ""
"Set the title used in the generated HTML documentation. This title will be "
"used inside the HTML \"title\" element."
msgstr ""
"Define o título usado na documentação HTML gerada. Este título será usado "
"dentro do elemento HTML \"title\"."

msgid ""
"Set the name used in the generated HTML documentation. This name will appear "
"at the top of the generated documentation inside a \"h1\" element."
msgstr ""
"Define o nome usado na documentação HTML gerada. Este nome aparecerá no topo "
"da documentação dentro de um elemento \"h1\"."

msgid ""
"Set the description used in the generated HTML documentation. This "
"description will appear as a paragraph, below the server name, in the "
"documentation."
msgstr ""
"Define a descrição usada na documentação HTML gerada. Esta descrição "
"aparecerá como um parágrafo, abaixo do nome do servidor, na documentação."

msgid "DocCGIXMLRPCRequestHandler"
msgstr "DocCGIXMLRPCRequestHandler"

msgid ""
"The :class:`DocCGIXMLRPCRequestHandler` class is derived from :class:"
"`CGIXMLRPCRequestHandler` and provides a means of creating self-documenting, "
"XML-RPC CGI scripts. HTTP POST requests are handled as XML-RPC method calls. "
"HTTP GET requests are handled by generating pydoc-style HTML documentation. "
"This allows a server to provide its own web-based documentation."
msgstr ""
"A classe :class:`DocCGIXMLRPCRequestHandler` é derivada de :class:"
"`CGIXMLRPCRequestHandler` e fornece meios de criar scripts CGI XML-RPC auto-"
"documentados. Pedidos HTTP POST são tratados como chamadas de método XML-"
"RPC. Pedidos HTTP GET são tratados gerando documentação HTML ao estilo "
"pydoc. Isto permite que um servidor forneça a sua própria documentação "
"baseada na web."
