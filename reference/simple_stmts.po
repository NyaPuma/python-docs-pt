# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-07 14:20+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid "Simple statements"
msgstr "Instruções simples"

msgid ""
"A simple statement is comprised within a single logical line. Several simple "
"statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr ""
"Uma instrução simples está contida numa única linha lógica. Várias "
"instruções simples podem ocorrer numa única linha, separadas por ponto e "
"vírgula. A sintaxe para instruções simples é:"

msgid "Expression statements"
msgstr "Instruções de expressão"

msgid ""
"Expression statements are used (mostly interactively) to compute and write a "
"value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr ""
"As instruções de expressão são usadas (principalmente de forma interativa) "
"para calcular e escrever um valor, ou (geralmente) para chamar um "
"procedimento (uma função que não retorna um resultado significativo; em "
"Python, os procedimentos retornam o valor ``None``). Outros usos de "
"instruções de expressão são permitidos e ocasionalmente úteis. A sintaxe "
"para uma instrução de expressão é:"

msgid ""
"An expression statement evaluates the expression list (which may be a single "
"expression)."
msgstr ""
"Uma instrução de expressão avalia a lista de expressões (que pode ser uma "
"única expressão)."

msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output on a line by itself (except if the result is "
"``None``, so that procedure calls do not cause any output.)"
msgstr ""
"Em modo interativo, se o valor não for ``None``, é convertido para uma "
"*string* usando a função integrada :func:`repr` e a *string* resultante é "
"escrita na saída padrão, numa linha própria (exceto se o resultado for "
"``None``, de modo que chamadas de procedimento não causem qualquer saída)."

msgid "Assignment statements"
msgstr "Instruções de atribuição"

msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr ""
"As instruções de atribuição são usadas para (re)ligar nomes a valores e para "
"modificar atributos ou itens de objetos mutáveis:"

msgid ""
"(See section :ref:`primaries` for the syntax definitions for *attributeref* "
"and *subscription*.)"
msgstr ""

msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr ""
"Uma instrução de atribuição avalia a lista de expressões (lembre-se que isto "
"pode ser uma única expressão ou uma lista separada por vírgulas, sendo que "
"esta última produz um *tuple*) e atribui o objeto resultante único a cada "
"uma das listas de destino, da esquerda para a direita."

msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference or "
"subscription), the mutable object must ultimately perform the assignment and "
"decide about its validity, and may raise an exception if the assignment is "
"unacceptable.  The rules observed by various types and the exceptions raised "
"are given with the definition of the object types (see section :ref:`types`)."
msgstr ""

msgid ""
"Assignment of an object to a target list, optionally enclosed in parentheses "
"or square brackets, is recursively defined as follows."
msgstr ""
"A atribuição de um objeto a uma lista de destinos, opcionalmente encerrada "
"entre parênteses ou colchetes, é definida recursivamente da seguinte forma."

msgid ""
"If the target list is a single target with no trailing comma, optionally in "
"parentheses, the object is assigned to that target."
msgstr ""
"Se a lista de destinos for um único destino sem vírgula final, opcionalmente "
"entre parênteses, o objeto é atribuído a esse destino."

msgid "Else:"
msgstr "Caso contrário:"

msgid ""
"If the target list contains one target prefixed with an asterisk, called a "
"\"starred\" target: The object must be an iterable with at least as many "
"items as there are targets in the target list, minus one.  The first items "
"of the iterable are assigned, from left to right, to the targets before the "
"starred target.  The final items of the iterable are assigned to the targets "
"after the starred target.  A list of the remaining items in the iterable is "
"then assigned to the starred target (the list can be empty)."
msgstr ""
"Se a lista de destinos contiver um destino prefixado com um asterisco, "
"chamado de destino \"estrela\": O objeto deve ser um iterável com pelo menos "
"tantos itens quantos os destinos na lista de destinos, menos um. Os "
"primeiros itens do iterável são atribuídos, da esquerda para a direita, aos "
"destinos antes do destino \"estrela\". Os itens finais do iterável são "
"atribuídos aos destinos após o destino \"estrela\". Uma lista dos itens "
"restantes no iterável é então atribuída ao destino \"estrela\" (a lista pode "
"estar vazia)."

msgid ""
"Else: The object must be an iterable with the same number of items as there "
"are targets in the target list, and the items are assigned, from left to "
"right, to the corresponding targets."
msgstr ""
"Caso contrário: O objeto deve ser um iterável com o mesmo número de itens "
"que os destinos na lista de destinos, e os itens são atribuídos, da esquerda "
"para a direita, aos destinos correspondentes."

msgid ""
"Assignment of an object to a single target is recursively defined as follows."
msgstr ""
"A atribuição de um objeto a um único destino é definida recursivamente da "
"seguinte forma."

msgid "If the target is an identifier (name):"
msgstr "Se o destino for um identificador (nome):"

msgid ""
"If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` "
"statement in the current code block: the name is bound to the object in the "
"current local namespace."
msgstr ""
"Se o nome não ocorrer numa instrução :keyword:`global` ou :keyword:"
"`nonlocal` no bloco de código atual: o nome é ligado ao objeto no "
"*namespace* local atual."

msgid ""
"Otherwise: the name is bound to the object in the global namespace or the "
"outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr ""
"Caso contrário: o nome é ligado ao objeto no *namespace* global ou no "
"*namespace* externo determinado por :keyword:`nonlocal`, respetivamente."

msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the "
"object to be deallocated and its destructor (if it has one) to be called."
msgstr ""
"O nome é religado se já estiver ligado. Isto pode fazer com que a contagem "
"de referências para o objeto anteriormente ligado ao nome atinja zero, "
"causando a desalocação do objeto e a chamada do seu destrutor (se tiver um)."

msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not "
"necessarily :exc:`AttributeError`)."
msgstr ""
"Se o destino for uma referência de atributo: A expressão primária na "
"referência é avaliada. Deve produzir um objeto com atributos atribuíveis; se "
"não for o caso, é levantada uma exceção :exc:`TypeError`. Esse objeto é "
"então solicitado a atribuir o objeto atribuído ao atributo dado; se não "
"puder realizar a atribuição, levanta uma exceção (geralmente, mas não "
"necessariamente, :exc:`AttributeError`)."

msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the right-hand side expression, "
"``a.x`` can access either an instance attribute or (if no instance attribute "
"exists) a class attribute.  The left-hand side target ``a.x`` is always set "
"as an instance attribute, creating it if necessary.  Thus, the two "
"occurrences of ``a.x`` do not necessarily refer to the same attribute: if "
"the right-hand side expression refers to a class attribute, the left-hand "
"side creates a new instance attribute as the target of the assignment::"
msgstr ""
"Nota: Se o objeto for uma instância de classe e a referência de atributo "
"ocorrer em ambos os lados do operador de atribuição, a expressão do lado "
"direito, ``a.x``, pode aceder a um atributo de instância ou (se não existir "
"nenhum atributo de instância) a um atributo de classe. O destino do lado "
"esquerdo, ``a.x``, é sempre definido como um atributo de instância, criando-"
"o se necessário. Assim, as duas ocorrências de ``a.x`` não se referem "
"necessariamente ao mesmo atributo: se a expressão do lado direito se referir "
"a um atributo de classe, o lado esquerdo cria um novo atributo de instância "
"como destino da atribuição::"

msgid ""
"class Cls:\n"
"    x = 3             # class variable\n"
"inst = Cls()\n"
"inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3"
msgstr ""
"class Cls:\n"
"    x = 3             # variável de classe\n"
"inst = Cls()\n"
"inst.x = inst.x + 1   # escreve inst.x como 4, deixando Cls.x como 3"

msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr ""
"Esta descrição não se aplica necessariamente a atributos descritores, como "
"propriedades criadas com :func:`property`."

msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated. Next, the subscript expression is evaluated. Then, the primary's :"
"meth:`~object.__setitem__` method is called with two arguments: the "
"subscript and the assigned object."
msgstr ""

msgid ""
"Typically, :meth:`~object.__setitem__` is defined on mutable sequence "
"objects (such as lists) and mapping objects (such as dictionaries), and "
"behaves as follows."
msgstr ""

msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield an integer.  If it is negative, the sequence's length is added to "
"it.  The resulting value must be a nonnegative integer less than the "
"sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, :exc:"
"`IndexError` is raised (assignment to a subscripted sequence cannot add new "
"items to a list)."
msgstr ""
"Se o primário for um objeto de sequência mutável (como uma lista), o índice "
"deve produzir um inteiro. Se for negativo, o comprimento da sequência é "
"adicionado a ele. O valor resultante deve ser um inteiro não negativo menor "
"que o comprimento da sequência, e a sequência é solicitada a atribuir o "
"objeto atribuído ao seu item com esse índice. Se o índice estiver fora do "
"intervalo, é levantada uma exceção :exc:`IndexError` (a atribuição a uma "
"sequência indexada não pode adicionar novos itens a uma lista)."

msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/value pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr ""
"Se o primário for um objeto de mapeamento (como um dicionário), o índice "
"deve ter um tipo compatível com o tipo de chave do mapeamento, e o "
"mapeamento é então solicitado a criar um par chave/valor que mapeia o índice "
"para o objeto atribuído. Isto pode substituir um par chave/valor existente "
"com o mesmo valor de chave ou inserir um novo par chave/valor (se não "
"existir nenhuma chave com o mesmo valor)."

msgid ""
"If the target is a slicing: The primary expression should evaluate to a "
"mutable sequence object (such as a list). The assigned object should be :"
"term:`iterable`. The slicing's lower and upper bounds should be integers; if "
"they are ``None`` (or not present), the defaults are zero and the sequence's "
"length. If either bound is negative, the sequence's length is added to it.  "
"The resulting bounds are clipped to lie between zero and the sequence's "
"length, inclusive.  Finally, the sequence object is asked to replace the "
"slice with the items of the assigned sequence.  The length of the slice may "
"be different from the length of the assigned sequence, thus changing the "
"length of the target sequence, if the target sequence allows it."
msgstr ""

msgid ""
"Although the definition of assignment implies that overlaps between the left-"
"hand side and the right-hand side are 'simultaneous' (for example ``a, b = "
"b, a`` swaps two variables), overlaps *within* the collection of assigned-to "
"variables occur left-to-right, sometimes resulting in confusion.  For "
"instance, the following program prints ``[0, 2]``::"
msgstr ""
"Embora a definição de atribuição implique que as sobreposições entre o lado "
"esquerdo e o lado direito são 'simultâneas' (por exemplo, ``a, b = b, a`` "
"troca duas variáveis), as sobreposições *dentro* da coleção de variáveis "
"atribuídas ocorrem da esquerda para a direita, o que por vezes pode causar "
"confusão. Por exemplo, o seguinte programa imprime ``[0, 2]``::"

msgid ""
"x = [0, 1]\n"
"i = 0\n"
"i, x[i] = 1, 2         # i is updated, then x[i] is updated\n"
"print(x)"
msgstr ""
"x = [0, 1]\n"
"i = 0\n"
"i, x[i] = 1, 2         # i é atualizado, depois x[i] é atualizado\n"
"print(x)"

msgid ":pep:`3132` - Extended Iterable Unpacking"
msgstr ":pep:`3132` - Desempacotamento Iterável Estendido"

msgid "The specification for the ``*target`` feature."
msgstr "A especificação para a funcionalidade ``*target``."

msgid "Augmented assignment statements"
msgstr "Instruções de atribuição aumentada"

msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr ""
"A atribuição aumentada é a combinação, numa única instrução, de uma operação "
"binária e uma instrução de atribuição:"

msgid ""
"(See section :ref:`primaries` for the syntax definitions of the last three "
"symbols.)"
msgstr ""
"(Consulte a secção :ref:`primaries` para as definições de sintaxe dos "
"últimos três símbolos.)"

msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only "
"evaluated once."
msgstr ""
"Uma atribuição aumentada avalia o destino (que, ao contrário das instruções "
"de atribuição normais, não pode ser um desempacotamento) e a lista de "
"expressões, executa a operação binária específica para o tipo de atribuição "
"nos dois operandos e atribui o resultado ao destino original. O destino é "
"avaliado apenas uma vez."

msgid ""
"An augmented assignment statement like ``x += 1`` can be rewritten as ``x = "
"x + 1`` to achieve a similar, but not exactly equal effect. In the augmented "
"version, ``x`` is only evaluated once. Also, when possible, the actual "
"operation is performed *in-place*, meaning that rather than creating a new "
"object and assigning that to the target, the old object is modified instead."
msgstr ""
"Uma instrução de atribuição aumentada como ``x += 1`` pode ser reescrita "
"como ``x = x + 1`` para alcançar um efeito semelhante, mas não exatamente "
"igual. Na versão aumentada, ``x`` é avaliado apenas uma vez. Além disso, "
"sempre que possível, a operação é realizada *in-place*, o que significa que, "
"em vez de criar um novo objeto e atribuí-lo ao destino, o objeto antigo é "
"modificado."

msgid ""
"Unlike normal assignments, augmented assignments evaluate the left-hand side "
"*before* evaluating the right-hand side.  For example, ``a[i] += f(x)`` "
"first looks-up ``a[i]``, then it evaluates ``f(x)`` and performs the "
"addition, and lastly, it writes the result back to ``a[i]``."
msgstr ""
"Ao contrário das atribuições normais, as atribuições aumentadas avaliam o "
"lado esquerdo *antes* de avaliar o lado direito. Por exemplo, ``a[i] += "
"f(x)`` primeiro procura ``a[i]``, depois avalia ``f(x)`` e executa a adição, "
"e finalmente escreve o resultado de volta em ``a[i]``."

msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled "
"the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr ""
"Com exceção da atribuição a *tuples* e a múltiplos destinos numa única "
"instrução, a atribuição feita por instruções de atribuição aumentada é "
"tratada da mesma forma que as atribuições normais. Da mesma forma, com "
"exceção do possível comportamento *in-place*, a operação binária realizada "
"pela atribuição aumentada é a mesma que as operações binárias normais."

msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr ""
"Para destinos que são referências de atributos, aplica-se a mesma :ref:"
"`ressalva sobre atributos de classe e instância <attr-target-note>` que se "
"aplica a atribuições regulares."

msgid "Annotated assignment statements"
msgstr "Instruções de atribuição anotada"

msgid ""
":term:`Annotation <variable annotation>` assignment is the combination, in a "
"single statement, of a variable or attribute annotation and an optional "
"assignment statement:"
msgstr ""
"A :term:`anotação <variable annotation>` de atribuição é a combinação, numa "
"única instrução, de uma anotação de variável ou atributo e uma instrução de "
"atribuição opcional:"

msgid ""
"The difference from normal :ref:`assignment` is that only a single target is "
"allowed."
msgstr ""
"A diferença em relação à :ref:`assignment` normal é que apenas um único "
"destino é permitido."

msgid ""
"The assignment target is considered \"simple\" if it consists of a single "
"name that is not enclosed in parentheses. For simple assignment targets, if "
"in class or module scope, the annotations are gathered in a lazily "
"evaluated :ref:`annotation scope <annotation-scopes>`. The annotations can "
"be evaluated using the :attr:`~object.__annotations__` attribute of a class "
"or module, or using the facilities in the :mod:`annotationlib` module."
msgstr ""
"O destino da atribuição é considerado \"simples\" se consistir num único "
"nome que não esteja encerrado entre parênteses. Para destinos de atribuição "
"simples, se estiverem no âmbito de uma classe ou módulo, as anotações são "
"recolhidas num :ref:`âmbitos de anotação <annotation-scopes>` avaliado de "
"forma preguiçosa. As anotações podem ser avaliadas usando o atributo :attr:"
"`~object.__annotations__` de uma classe ou módulo, ou usando as "
"funcionalidades do módulo :mod:`annotationlib`."

msgid ""
"If the assignment target is not simple (an attribute, subscript node, or "
"parenthesized name), the annotation is never evaluated."
msgstr ""
"Se o destino da atribuição não for simples (um atributo, nó de "
"*subscription* ou nome entre parênteses), a anotação nunca é avaliada."

msgid ""
"If a name is annotated in a function scope, then this name is local for that "
"scope. Annotations are never evaluated and stored in function scopes."
msgstr ""
"Se um nome for anotado no âmbito de uma função, então esse nome é local para "
"esse âmbito. As anotações nunca são avaliadas nem armazenadas em âmbitos de "
"função."

msgid ""
"If the right hand side is present, an annotated assignment performs the "
"actual assignment as if there was no annotation present. If the right hand "
"side is not present for an expression target, then the interpreter evaluates "
"the target except for the last :meth:`~object.__setitem__` or :meth:`~object."
"__setattr__` call."
msgstr ""
"Se o lado direito estiver presente, uma atribuição anotada realiza a "
"atribuição real como se não houvesse anotação presente. Se o lado direito "
"não estiver presente para um destino de expressão, então o interpretador "
"avalia o destino, exceto para a última chamada a :meth:`~object.__setitem__` "
"ou :meth:`~object.__setattr__`."

msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Sintaxe para Anotações de Variáveis"

msgid ""
"The proposal that added syntax for annotating the types of variables "
"(including class variables and instance variables), instead of expressing "
"them through comments."
msgstr ""
"A proposta que adicionou sintaxe para anotar os tipos de variáveis "
"(incluindo variáveis de classe e de instância), em vez de os expressar "
"através de comentários."

msgid ":pep:`484` - Type hints"
msgstr ":pep:`484` - Dicas de tipo"

msgid ""
"The proposal that added the :mod:`typing` module to provide a standard "
"syntax for type annotations that can be used in static analysis tools and "
"IDEs."
msgstr ""
"A proposta que adicionou o módulo :mod:`typing` para fornecer uma sintaxe "
"padrão para anotações de tipo que podem ser usadas em ferramentas de análise "
"estática e IDEs."

msgid ""
"Now annotated assignments allow the same expressions in the right hand side "
"as regular assignments. Previously, some expressions (like un-parenthesized "
"tuple expressions) caused a syntax error."
msgstr ""
"Agora, as atribuições anotadas permitem as mesmas expressões no lado direito "
"que as atribuições regulares. Anteriormente, algumas expressões (como "
"expressões de *tuples* não parentizadas) causavam um erro de sintaxe."

msgid ""
"Annotations are now lazily evaluated in a separate :ref:`annotation scope "
"<annotation-scopes>`. If the assignment target is not simple, annotations "
"are never evaluated."
msgstr ""
"As anotações são agora avaliadas de forma preguiçosa num :ref:`âmbitos de "
"anotação <annotation-scopes>` separado. Se o destino da atribuição não for "
"simples, as anotações nunca são avaliadas."

msgid "The :keyword:`!assert` statement"
msgstr "A instrução :keyword:`!assert`"

msgid ""
"Assert statements are a convenient way to insert debugging assertions into a "
"program:"
msgstr ""
"As instruções assert são uma forma conveniente de inserir afirmações de "
"depuração num programa:"

msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr "A forma simples, ``assert expression``, é equivalente a ::"

msgid ""
"if __debug__:\n"
"    if not expression: raise AssertionError"
msgstr ""
"if __debug__:\n"
"    if not expressão: raise AssertionError"

msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr ""
"A forma estendida, ``assert expression1, expression2``, é equivalente a ::"

msgid ""
"if __debug__:\n"
"    if not expression1: raise AssertionError(expression2)"
msgstr ""
"if __debug__:\n"
"    if not expressão1: raise AssertionError(expressão2)"

msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable ``__debug__`` is ``True`` under normal "
"circumstances, ``False`` when optimization is requested (command line "
"option :option:`-O`).  The current code generator emits no code for an :"
"keyword:`assert` statement when optimization is requested at compile time.  "
"Note that it is unnecessary to include the source code for the expression "
"that failed in the error message; it will be displayed as part of the stack "
"trace."
msgstr ""
"Estas equivalências assumem que :const:`__debug__` e :exc:`AssertionError` "
"se referem às variáveis integradas com esses nomes. Na implementação atual, "
"a variável integrada ``__debug__`` é ``True`` em circunstâncias normais e "
"``False`` quando a otimização é solicitada (opção de linha de comandos :"
"option:`-O`). O gerador de código atual não emite código para uma instrução :"
"keyword:`assert` quando a otimização é solicitada em tempo de compilação. "
"Note que não é necessário incluir o código-fonte da expressão que falhou na "
"mensagem de erro; ele será exibido como parte do rastreio da pilha."

msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr ""
"Atribuições a :const:`__debug__` são ilegais. O valor da variável integrada "
"é determinado quando o interpretador é iniciado."

msgid "The :keyword:`!pass` statement"
msgstr "A instrução :keyword:`!pass`"

msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""
":keyword:`pass` é uma operação nula --- quando executada, nada acontece. É "
"útil como um espaço reservado quando uma instrução é necessária "
"sintaticamente, mas nenhum código precisa ser executado, por exemplo::"

msgid ""
"def f(arg): pass    # a function that does nothing (yet)\n"
"\n"
"class C: pass       # a class with no methods (yet)"
msgstr ""
"def f(arg): pass    # uma função que não faz nada (ainda)\n"
"\n"
"class C: pass       # uma classe sem métodos (ainda)"

msgid "The :keyword:`!del` statement"
msgstr "A instrução :keyword:`!del`"

msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr ""
"A eliminação é definida recursivamente de forma muito semelhante à forma "
"como a atribuição é definida. Em vez de detalhar completamente, aqui estão "
"algumas dicas."

msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr ""
"A eliminação de uma lista de destinos elimina recursivamente cada destino, "
"da esquerda para a direita."

msgid ""
"Deletion of a name removes the binding of that name from the local or global "
"namespace, depending on whether the name occurs in a :keyword:`global` "
"statement in the same code block.  Trying to delete an unbound name raises "
"a :exc:`NameError` exception."
msgstr ""
"A eliminação de um nome remove a ligação desse nome do *namespace* local ou "
"global, dependendo se o nome ocorre numa instrução :keyword:`global` no "
"mesmo bloco de código. Tentar eliminar um nome não ligado levanta uma "
"exceção :exc:`NameError`."

msgid ""
"Deletion of attribute references and subscriptions is passed to the primary "
"object involved; deletion of a slicing is in general equivalent to "
"assignment of an empty slice of the right type (but even this is determined "
"by the sliced object)."
msgstr ""

msgid ""
"Previously it was illegal to delete a name from the local namespace if it "
"occurs as a free variable in a nested block."
msgstr ""
"Anteriormente, era ilegal eliminar um nome do *namespace* local se ele "
"ocorresse como uma variável livre num bloco aninhado."

msgid "The :keyword:`!return` statement"
msgstr "A instrução :keyword:`!return`"

msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ""
":keyword:`return` só pode ocorrer sintaticamente aninhado numa definição de "
"função, não dentro de uma definição de classe aninhada."

msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr ""
"Se uma lista de expressões estiver presente, é avaliada; caso contrário, "
"``None`` é substituído."

msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ""
":keyword:`return` sai da chamada de função atual com a lista de expressões "
"(ou ``None``) como valor de retorno."

msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the function."
msgstr ""
"Quando :keyword:`return` passa o controlo para fora de uma instrução :"
"keyword:`try` com uma cláusula :keyword:`finally`, essa cláusula :keyword:`!"
"finally` é executada antes de realmente sair da função."

msgid ""
"In a generator function, the :keyword:`return` statement indicates that the "
"generator is done and will cause :exc:`StopIteration` to be raised. The "
"returned value (if any) is used as an argument to construct :exc:"
"`StopIteration` and becomes the :attr:`StopIteration.value` attribute."
msgstr ""
"Numa função geradora, a instrução :keyword:`return` indica que o gerador "
"terminou e fará com que :exc:`StopIteration` seja levantada. O valor "
"retornado (se houver) é usado como argumento para construir :exc:"
"`StopIteration` e torna-se o atributo :attr:`StopIteration.value`."

msgid ""
"In an asynchronous generator function, an empty :keyword:`return` statement "
"indicates that the asynchronous generator is done and will cause :exc:"
"`StopAsyncIteration` to be raised.  A non-empty :keyword:`!return` statement "
"is a syntax error in an asynchronous generator function."
msgstr ""
"Numa função geradora assíncrona, uma instrução :keyword:`return` vazia "
"indica que o gerador assíncrono terminou e fará com que :exc:"
"`StopAsyncIteration` seja levantada. Uma instrução :keyword:`!return` não "
"vazia é um erro de sintaxe numa função geradora assíncrona."

msgid "The :keyword:`!yield` statement"
msgstr "A instrução :keyword:`!yield`"

msgid ""
"A :keyword:`yield` statement is semantically equivalent to a :ref:`yield "
"expression <yieldexpr>`. The ``yield`` statement can be used to omit the "
"parentheses that would otherwise be required in the equivalent yield "
"expression statement. For example, the yield statements ::"
msgstr ""
"Uma instrução :keyword:`yield` é semanticamente equivalente a uma :ref:"
"`expressão yield <yieldexpr>`. A instrução ``yield`` pode ser usada para "
"omitir os parênteses que seriam necessários na instrução de expressão yield "
"equivalente. Por exemplo, as instruções yield ::"

msgid ""
"yield <expr>\n"
"yield from <expr>"
msgstr ""
"yield <expr>\n"
"yield from <expr>"

msgid "are equivalent to the yield expression statements ::"
msgstr "são equivalentes às instruções de expressão yield ::"

msgid ""
"(yield <expr>)\n"
"(yield from <expr>)"
msgstr ""
"(yield <expr>)\n"
"(yield from <expr>)"

msgid ""
"Yield expressions and statements are only used when defining a :term:"
"`generator` function, and are only used in the body of the generator "
"function.  Using :keyword:`yield` in a function definition is sufficient to "
"cause that definition to create a generator function instead of a normal "
"function."
msgstr ""
"As expressões e instruções yield são usadas apenas ao definir uma função :"
"term:`geradora` e são usadas apenas no corpo da função geradora. Usar :"
"keyword:`yield` numa definição de função é suficiente para fazer com que "
"essa definição crie uma função geradora em vez de uma função normal."

msgid ""
"For full details of :keyword:`yield` semantics, refer to the :ref:"
"`yieldexpr` section."
msgstr ""
"Para detalhes completos sobre a semântica de :keyword:`yield`, consulte a "
"secção :ref:`yieldexpr`."

msgid "The :keyword:`!raise` statement"
msgstr "A instrução :keyword:`!raise`"

msgid ""
"If no expressions are present, :keyword:`raise` re-raises the exception that "
"is currently being handled, which is also known as the *active exception*. "
"If there isn't currently an active exception, a :exc:`RuntimeError` "
"exception is raised indicating that this is an error."
msgstr ""
"Se não houver expressões presentes, :keyword:`raise` relança a exceção que "
"está atualmente a ser tratada, também conhecida como a *exceção ativa*. Se "
"não houver atualmente uma exceção ativa, é levantada uma exceção :exc:"
"`RuntimeError` indicando que isto é um erro."

msgid ""
"Otherwise, :keyword:`raise` evaluates the first expression as the exception "
"object.  It must be either a subclass or an instance of :class:"
"`BaseException`. If it is a class, the exception instance will be obtained "
"when needed by instantiating the class with no arguments."
msgstr ""
"Caso contrário, :keyword:`raise` avalia a primeira expressão como o objeto "
"de exceção. Deve ser uma subclasse ou uma instância de :class:"
"`BaseException`. Se for uma classe, a instância de exceção será obtida "
"quando necessária, instanciando a classe sem argumentos."

msgid ""
"The :dfn:`type` of the exception is the exception instance's class, the :dfn:"
"`value` is the instance itself."
msgstr ""
"O :dfn:`tipo` da exceção é a classe da instância de exceção, o :dfn:`valor` "
"é a instância em si."

msgid ""
"A traceback object is normally created automatically when an exception is "
"raised and attached to it as the :attr:`~BaseException.__traceback__` "
"attribute. You can create an exception and set your own traceback in one "
"step using the :meth:`~BaseException.with_traceback` exception method (which "
"returns the same exception instance, with its traceback set to its "
"argument), like so::"
msgstr ""
"Um objeto de rastreio é normalmente criado automaticamente quando uma "
"exceção é levantada e anexado a ela como o atributo :attr:`~BaseException."
"__traceback__`. Pode criar uma exceção e definir o seu próprio rastreio num "
"único passo usando o método de exceção :meth:`~BaseException.with_traceback` "
"(que retorna a mesma instância de exceção, com o seu rastreio definido para "
"o seu argumento), como segue::"

msgid "raise Exception(\"foo occurred\").with_traceback(tracebackobj)"
msgstr "raise Exception(\"foo ocorreu\").with_traceback(tracebackobj)"

msgid ""
"The ``from`` clause is used for exception chaining: if given, the second "
"*expression* must be another exception class or instance. If the second "
"expression is an exception instance, it will be attached to the raised "
"exception as the :attr:`~BaseException.__cause__` attribute (which is "
"writable). If the expression is an exception class, the class will be "
"instantiated and the resulting exception instance will be attached to the "
"raised exception as the :attr:`!__cause__` attribute. If the raised "
"exception is not handled, both exceptions will be printed:"
msgstr ""
"A cláusula ``from`` é usada para encadeamento de exceções: se fornecida, a "
"segunda *expressão* deve ser outra classe ou instância de exceção. Se a "
"segunda expressão for uma instância de exceção, será anexada à exceção "
"levantada como o atributo :attr:`~BaseException.__cause__` (que é gravável). "
"Se a expressão for uma classe de exceção, a classe será instanciada e a "
"instância de exceção resultante será anexada à exceção levantada como o "
"atributo :attr:`!__cause__`. Se a exceção levantada não for tratada, ambas "
"as exceções serão impressas:"

msgid ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except Exception as exc:\n"
"...     raise RuntimeError(\"Something bad happened\") from exc\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: division by zero\n"
"\n"
"The above exception was the direct cause of the following exception:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Something bad happened\") from exc\n"
"RuntimeError: Something bad happened"
msgstr ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except Exception as exc:\n"
"...     raise RuntimeError(\"Algo correu mal\") from exc\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: divisão por zero\n"
"\n"
"The above exception was the direct cause of the following exception:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Algo correu mal\") from exc\n"
"RuntimeError: Algo correu mal"

msgid ""
"A similar mechanism works implicitly if a new exception is raised when an "
"exception is already being handled.  An exception may be handled when an :"
"keyword:`except` or :keyword:`finally` clause, or a :keyword:`with` "
"statement, is used.  The previous exception is then attached as the new "
"exception's :attr:`~BaseException.__context__` attribute:"
msgstr ""
"Um mecanismo semelhante funciona implicitamente se uma nova exceção for "
"levantada quando uma exceção já está a ser tratada. Uma exceção pode ser "
"tratada quando uma cláusula :keyword:`except` ou :keyword:`finally`, ou uma "
"instrução :keyword:`with`, é usada. A exceção anterior é então anexada como "
"o atributo :attr:`~BaseException.__context__` da nova exceção:"

msgid ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Something bad happened\")\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: division by zero\n"
"\n"
"During handling of the above exception, another exception occurred:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Something bad happened\")\n"
"RuntimeError: Something bad happened"
msgstr ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Algo correu mal\")\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: divisão por zero\n"
"\n"
"During handling of the above exception, another exception occurred:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Algo correu mal\")\n"
"RuntimeError: Algo correu mal"

msgid ""
"Exception chaining can be explicitly suppressed by specifying :const:`None` "
"in the ``from`` clause:"
msgstr ""
"O encadeamento de exceções pode ser explicitamente suprimido especificando :"
"const:`None` na cláusula ``from``:"

msgid ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Something bad happened\") from None\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"RuntimeError: Something bad happened"
msgstr ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Algo correu mal\") from None\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"RuntimeError: Algo correu mal"

msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information about handling exceptions is in section :ref:"
"`try`."
msgstr ""
"Informações adicionais sobre exceções podem ser encontradas na secção :ref:"
"`exceptions`, e informações sobre o tratamento de exceções estão na secção :"
"ref:`try`."

msgid ":const:`None` is now permitted as ``Y`` in ``raise X from Y``."
msgstr ":const:`None` é agora permitido como ``Y`` em ``raise X from Y``."

msgid ""
"Added the :attr:`~BaseException.__suppress_context__` attribute to suppress "
"automatic display of the exception context."
msgstr ""
"Adicionado o atributo :attr:`~BaseException.__suppress_context__` para "
"suprimir a exibição automática do contexto da exceção."

msgid ""
"If the traceback of the active exception is modified in an :keyword:`except` "
"clause, a subsequent ``raise`` statement re-raises the exception with the "
"modified traceback. Previously, the exception was re-raised with the "
"traceback it had when it was caught."
msgstr ""
"Se o rastreio da exceção ativa for modificado numa cláusula :keyword:"
"`except`, uma instrução ``raise`` subsequente relança a exceção com o "
"rastreio modificado. Anteriormente, a exceção era relançada com o rastreio "
"que tinha quando foi capturada."

msgid "The :keyword:`!break` statement"
msgstr "A instrução :keyword:`!break`"

msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or :"
"keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ""
":keyword:`break` só pode ocorrer sintaticamente aninhado num ciclo :keyword:"
"`for` ou :keyword:`while`, mas não aninhado numa definição de função ou "
"classe dentro desse ciclo."

msgid ""
"It terminates the nearest enclosing loop, skipping the optional :keyword:`!"
"else` clause if the loop has one."
msgstr ""
"Termina o ciclo envolvente mais próximo, ignorando a cláusula :keyword:`!"
"else` opcional, se o ciclo tiver uma."

msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control "
"target keeps its current value."
msgstr ""
"Se um ciclo :keyword:`for` for terminado por :keyword:`break`, o alvo de "
"controlo do ciclo mantém o seu valor atual."

msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the loop."
msgstr ""
"Quando :keyword:`break` passa o controlo para fora de uma instrução :keyword:"
"`try` com uma cláusula :keyword:`finally`, essa cláusula :keyword:`!finally` "
"é executada antes de realmente sair do ciclo."

msgid "The :keyword:`!continue` statement"
msgstr "A instrução :keyword:`!continue`"

msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"within that loop.  It continues with the next cycle of the nearest enclosing "
"loop."
msgstr ""
":keyword:`continue` só pode ocorrer sintaticamente aninhado num ciclo :"
"keyword:`for` ou :keyword:`while`, mas não aninhado numa definição de função "
"ou classe dentro desse ciclo. Continua com o próximo ciclo do ciclo "
"envolvente mais próximo."

msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`!finally` clause is "
"executed before really starting the next loop cycle."
msgstr ""
"Quando :keyword:`continue` passa o controlo para fora de uma instrução :"
"keyword:`try` com uma cláusula :keyword:`finally`, essa cláusula :keyword:`!"
"finally` é executada antes de realmente iniciar o próximo ciclo do ciclo."

msgid "The :keyword:`!import` statement"
msgstr "A instrução :keyword:`!import`"

msgid ""
"The basic import statement (no :keyword:`from` clause) is executed in two "
"steps:"
msgstr ""
"A instrução de importação básica (sem cláusula :keyword:`from`) é executada "
"em dois passos:"

msgid "find a module, loading and initializing it if necessary"
msgstr "encontrar um módulo, carregando e inicializando-o se necessário"

msgid ""
"define a name or names in the local namespace for the scope where the :"
"keyword:`import` statement occurs."
msgstr ""
"definir um nome ou nomes no *namespace* local para o âmbito onde a "
"instrução :keyword:`import` ocorre."

msgid ""
"When the statement contains multiple clauses (separated by commas) the two "
"steps are carried out separately for each clause, just as though the clauses "
"had been separated out into individual import statements."
msgstr ""
"Quando a instrução contém múltiplas cláusulas (separadas por vírgulas), os "
"dois passos são executados separadamente para cada cláusula, como se as "
"cláusulas tivessem sido separadas em instruções de importação individuais."

msgid ""
"The details of the first step, finding and loading modules, are described in "
"greater detail in the section on the :ref:`import system <importsystem>`, "
"which also describes the various types of packages and modules that can be "
"imported, as well as all the hooks that can be used to customize the import "
"system. Note that failures in this step may indicate either that the module "
"could not be located, *or* that an error occurred while initializing the "
"module, which includes execution of the module's code."
msgstr ""
"Os detalhes do primeiro passo, encontrar e carregar módulos, são descritos "
"com maior detalhe na secção sobre o :ref:`sistema de importação "
"<importsystem>`, que também descreve os vários tipos de pacotes e módulos "
"que podem ser importados, bem como todos os *hooks* que podem ser usados "
"para personalizar o sistema de importação. Note que falhas neste passo podem "
"indicar que o módulo não foi localizado, *ou* que ocorreu um erro durante a "
"inicialização do módulo, o que inclui a execução do código do módulo."

msgid ""
"If the requested module is retrieved successfully, it will be made available "
"in the local namespace in one of three ways:"
msgstr ""
"Se o módulo solicitado for recuperado com sucesso, será disponibilizado no "
"*namespace* local de uma das três formas:"

msgid ""
"If the module name is followed by :keyword:`!as`, then the name following :"
"keyword:`!as` is bound directly to the imported module."
msgstr ""
"Se o nome do módulo for seguido por :keyword:`!as`, então o nome que segue :"
"keyword:`!as` é ligado diretamente ao módulo importado."

msgid ""
"If no other name is specified, and the module being imported is a top level "
"module, the module's name is bound in the local namespace as a reference to "
"the imported module"
msgstr ""
"Se nenhum outro nome for especificado e o módulo a ser importado for um "
"módulo de nível superior, o nome do módulo é ligado no *namespace* local "
"como uma referência ao módulo importado."

msgid ""
"If the module being imported is *not* a top level module, then the name of "
"the top level package that contains the module is bound in the local "
"namespace as a reference to the top level package. The imported module must "
"be accessed using its full qualified name rather than directly"
msgstr ""
"Se o módulo a ser importado *não* for um módulo de nível superior, então o "
"nome do pacote de nível superior que contém o módulo é ligado no *namespace* "
"local como uma referência ao pacote de nível superior. O módulo importado "
"deve ser acedido usando o seu nome qualificado completo em vez de "
"diretamente."

msgid "The :keyword:`from` form uses a slightly more complex process:"
msgstr "A forma :keyword:`from` usa um processo ligeiramente mais complexo:"

msgid ""
"find the module specified in the :keyword:`from` clause, loading and "
"initializing it if necessary;"
msgstr ""
"encontrar o módulo especificado na cláusula :keyword:`from`, carregando e "
"inicializando-o se necessário;"

msgid "for each of the identifiers specified in the :keyword:`import` clauses:"
msgstr ""
"para cada um dos identificadores especificados nas cláusulas :keyword:"
"`import`:"

msgid "check if the imported module has an attribute by that name"
msgstr "verificar se o módulo importado tem um atributo com esse nome"

msgid ""
"if not, attempt to import a submodule with that name and then check the "
"imported module again for that attribute"
msgstr ""
"se não, tentar importar um submódulo com esse nome e depois verificar "
"novamente o módulo importado quanto a esse atributo"

msgid "if the attribute is not found, :exc:`ImportError` is raised."
msgstr ""
"se o atributo não for encontrado, é levantada uma exceção :exc:`ImportError`."

msgid ""
"otherwise, a reference to that value is stored in the local namespace, using "
"the name in the :keyword:`!as` clause if it is present, otherwise using the "
"attribute name"
msgstr ""
"caso contrário, uma referência a esse valor é armazenada no *namespace* "
"local, usando o nome na cláusula :keyword:`!as` se estiver presente, caso "
"contrário usando o nome do atributo"

msgid "Examples::"
msgstr "Exemplos::"

msgid ""
"import foo                 # foo imported and bound locally\n"
"import foo.bar.baz         # foo, foo.bar, and foo.bar.baz imported, foo "
"bound locally\n"
"import foo.bar.baz as fbb  # foo, foo.bar, and foo.bar.baz imported, foo.bar."
"baz bound as fbb\n"
"from foo.bar import baz    # foo, foo.bar, and foo.bar.baz imported, foo.bar."
"baz bound as baz\n"
"from foo import attr       # foo imported and foo.attr bound as attr"
msgstr ""

msgid ""
"If the list of identifiers is replaced by a star (``'*'``), all public names "
"defined in the module are bound in the local namespace for the scope where "
"the :keyword:`import` statement occurs."
msgstr ""
"Se a lista de identificadores for substituída por um asterisco (``'*'``), "
"todos os nomes públicos definidos no módulo são ligados no *namespace* local "
"para o âmbito onde a instrução :keyword:`import` ocorre."

msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module. "
"Names containing non-ASCII characters must be in the `normalization form`_ "
"NFKC; see :ref:`lexical-names-nonascii` for details.  The names given in "
"``__all__`` are all considered public and are required to exist.  If "
"``__all__`` is not defined, the set of public names includes all names found "
"in the module's namespace which do not begin with an underscore character "
"(``'_'``).  ``__all__`` should contain the entire public API. It is intended "
"to avoid accidentally exporting items that are not part of the API (such as "
"library modules which were imported and used within the module)."
msgstr ""

msgid ""
"The wild card form of import --- ``from module import *`` --- is only "
"allowed at the module level.  Attempting to use it in class or function "
"definitions will raise a :exc:`SyntaxError`."
msgstr ""
"A forma de importação com curinga --- ``from module import *`` --- só é "
"permitida ao nível do módulo. Tentar usá-la em definições de classe ou "
"função levantará uma exceção :exc:`SyntaxError`."

msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top "
"package without having to mention the package name. By using leading dots in "
"the specified module or package after :keyword:`from` you can specify how "
"high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the "
"import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained in "
"the :ref:`relativeimports` section."
msgstr ""
"Ao especificar qual módulo importar, não é necessário especificar o nome "
"absoluto do módulo. Quando um módulo ou pacote está contido dentro de outro "
"pacote, é possível fazer uma importação relativa dentro do mesmo pacote de "
"nível superior sem ter de mencionar o nome do pacote. Usando pontos iniciais "
"no módulo ou pacote especificado após :keyword:`from`, pode especificar até "
"que nível subir na hierarquia do pacote atual sem especificar nomes exatos. "
"Um ponto inicial significa o pacote atual onde o módulo que faz a importação "
"existe. Dois pontos significam subir um nível de pacote. Três pontos "
"significam subir dois níveis, etc. Assim, se executar ``from . import mod`` "
"a partir de um módulo no pacote ``pkg``, acabará por importar ``pkg.mod``. "
"Se executar ``from ..subpkg2 import mod`` a partir de ``pkg.subpkg1``, "
"importará ``pkg.subpkg2.mod``. A especificação para importações relativas "
"está contida na secção :ref:`relativeimports`."

msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine dynamically the modules to be loaded."
msgstr ""
":func:`importlib.import_module` é fornecido para apoiar aplicações que "
"determinam dinamicamente os módulos a serem carregados."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``import`` with arguments "
"``module``, ``filename``, ``sys.path``, ``sys.meta_path``, ``sys."
"path_hooks``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``import`` com os "
"argumentos ``module``, ``filename``, ``sys.path``, ``sys.meta_path``, ``sys."
"path_hooks``."

msgid "Future statements"
msgstr "Instruções *future*"

msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python where the feature becomes standard."
msgstr ""
"Uma :dfn:`instrução *future*` é uma diretiva para o compilador de que um "
"módulo específico deve ser compilado usando sintaxe ou semântica que estarão "
"disponíveis numa versão futura especificada do Python, onde a funcionalidade "
"se torna padrão."

msgid ""
"The future statement is intended to ease migration to future versions of "
"Python that introduce incompatible changes to the language.  It allows use "
"of the new features on a per-module basis before the release in which the "
"feature becomes standard."
msgstr ""
"A instrução *future* destina-se a facilitar a migração para versões futuras "
"do Python que introduzem alterações incompatíveis na linguagem. Permite a "
"utilização das novas funcionalidades por módulo antes da versão em que a "
"funcionalidade se torna padrão."

msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr ""
"Uma instrução *future* deve aparecer perto do topo do módulo. As únicas "
"linhas que podem aparecer antes de uma instrução *future* são:"

msgid "the module docstring (if any),"
msgstr "a *docstring* do módulo (se existir),"

msgid "comments,"
msgstr "comentários,"

msgid "blank lines, and"
msgstr "linhas em branco, e"

msgid "other future statements."
msgstr "outras instruções *future*."

msgid ""
"The only feature that requires using the future statement is ``annotations`` "
"(see :pep:`563`)."
msgstr ""
"A única funcionalidade que requer o uso da instrução *future* é "
"``annotations`` (consulte :pep:`563`)."

msgid ""
"All historical features enabled by the future statement are still recognized "
"by Python 3.  The list includes ``absolute_import``, ``division``, "
"``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` and ``with_statement``.  They are all "
"redundant because they are always enabled, and only kept for backwards "
"compatibility."
msgstr ""
"Todas as funcionalidades históricas ativadas pela instrução *future* ainda "
"são reconhecidas pelo Python 3. A lista inclui ``absolute_import``, "
"``division``, ``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` e ``with_statement``. Todas são "
"redundantes porque estão sempre ativadas e são mantidas apenas para "
"compatibilidade retroativa."

msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr ""
"Uma instrução *future* é reconhecida e tratada de forma especial em tempo de "
"compilação: Alterações à semântica de construções principais são "
"frequentemente implementadas gerando código diferente. Pode até acontecer "
"que uma nova funcionalidade introduza uma nova sintaxe incompatível (como "
"uma nova palavra reservada), caso em que o compilador pode precisar de "
"analisar o módulo de forma diferente. Tais decisões não podem ser adiadas "
"até ao tempo de execução."

msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr ""
"Para qualquer versão específica, o compilador sabe quais os nomes de "
"funcionalidades que foram definidos e levanta um erro em tempo de compilação "
"se uma instrução *future* contiver uma funcionalidade desconhecida."

msgid ""
"The direct runtime semantics are the same as for any import statement: there "
"is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr ""
"A semântica direta em tempo de execução é a mesma que para qualquer "
"instrução de importação: existe um módulo padrão :mod:`__future__`, descrito "
"mais adiante, e será importado da forma habitual no momento em que a "
"instrução *future* é executada."

msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr ""
"A semântica interessante em tempo de execução depende da funcionalidade "
"específica ativada pela instrução *future*."

msgid "Note that there is nothing special about the statement::"
msgstr "Note que não há nada de especial na instrução::"

msgid "import __future__ [as name]"
msgstr "import __future__ [como nome]"

msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr ""
"Isso não é uma instrução *future*; é uma instrução de importação comum, sem "
"semântica ou restrições sintáticas especiais."

msgid ""
"Code compiled by calls to the built-in functions :func:`exec` and :func:"
"`compile` that occur in a module :mod:`!M` containing a future statement "
"will, by default, use the new syntax or semantics associated with the future "
"statement.  This can be controlled by optional arguments to :func:`compile` "
"--- see the documentation of that function for details."
msgstr ""
"O código compilado por chamadas às funções integradas :func:`exec` e :func:"
"`compile` que ocorrem num módulo :mod:`!M` contendo uma instrução *future* "
"usará, por predefinição, a nova sintaxe ou semântica associada à instrução "
"*future*. Isto pode ser controlado por argumentos opcionais para :func:"
"`compile` — consulte a documentação dessa função para mais detalhes."

msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""
"Uma instrução *future* digitada num prompt interativo do interpretador "
"entrará em vigor pelo resto da sessão do interpretador. Se um interpretador "
"for iniciado com a opção :option:`-i`, receber um nome de *script* para "
"executar e o *script* incluir uma instrução *future*, esta estará em vigor "
"na sessão interativa iniciada após a execução do *script*."

msgid ":pep:`236` - Back to the __future__"
msgstr ":pep:`236` - De volta ao __future__"

msgid "The original proposal for the __future__ mechanism."
msgstr "A proposta original para o mecanismo __future__."

msgid "The :keyword:`!global` statement"
msgstr "A instrução :keyword:`!global`"

msgid ""
"The :keyword:`global` statement causes the listed identifiers to be "
"interpreted as globals. It would be impossible to assign to a global "
"variable without :keyword:`!global`, although free variables may refer to "
"globals without being declared global."
msgstr ""
"A instrução :keyword:`global` faz com que os identificadores listados sejam "
"interpretados como globais. Seria impossível atribuir a uma variável global "
"sem :keyword:`!global`, embora variáveis livres possam referir-se a globais "
"sem serem declaradas como globais."

msgid ""
"The :keyword:`!global` statement applies to the entire current scope "
"(module, function body or class definition). A :exc:`SyntaxError` is raised "
"if a variable is used or assigned to prior to its global declaration in the "
"scope."
msgstr ""
"A instrução :keyword:`!global` aplica-se a todo o âmbito atual (módulo, "
"corpo de função ou definição de classe). Uma exceção :exc:`SyntaxError` é "
"levantada se uma variável for usada ou atribuída antes da sua declaração "
"global no âmbito."

msgid ""
"At the module level, all variables are global, so a :keyword:`!global` "
"statement has no effect. However, variables must still not be used or "
"assigned to prior to their :keyword:`!global` declaration. This requirement "
"is relaxed in the interactive prompt (:term:`REPL`)."
msgstr ""
"Ao nível do módulo, todas as variáveis são globais, por isso uma instrução :"
"keyword:`!global` não tem efeito. No entanto, as variáveis ainda não devem "
"ser usadas ou atribuídas antes da sua declaração :keyword:`!global`. Este "
"requisito é relaxado no prompt interativo (:term:`REPL`)."

msgid ""
"**Programmer's note:** :keyword:`global` is a directive to the parser.  It "
"applies only to code parsed at the same time as the :keyword:`!global` "
"statement. In particular, a :keyword:`!global` statement contained in a "
"string or code object supplied to the built-in :func:`exec` function does "
"not affect the code block *containing* the function call, and code contained "
"in such a string is unaffected by :keyword:`!global` statements in the code "
"containing the function call.  The same applies to the :func:`eval` and :"
"func:`compile` functions."
msgstr ""
"**Nota para programadores:** :keyword:`global` é uma diretiva para o "
"*parser*. Aplica-se apenas ao código analisado ao mesmo tempo que a "
"instrução :keyword:`!global`. Em particular, uma instrução :keyword:`!"
"global` contida numa *string* ou objeto de código fornecido à função "
"integrada :func:`exec` não afeta o bloco de código que *contém* a chamada da "
"função, e o código contido numa tal *string* não é afetado por instruções :"
"keyword:`!global` no código que contém a chamada da função. O mesmo se "
"aplica às funções :func:`eval` e :func:`compile`."

msgid "The :keyword:`!nonlocal` statement"
msgstr "A instrução :keyword:`!nonlocal`"

msgid ""
"When the definition of a function or class is nested (enclosed) within the "
"definitions of other functions, its nonlocal scopes are the local scopes of "
"the enclosing functions. The :keyword:`nonlocal` statement causes the listed "
"identifiers to refer to names previously bound in nonlocal scopes. It allows "
"encapsulated code to rebind such nonlocal identifiers.  If a name is bound "
"in more than one nonlocal scope, the nearest binding is used. If a name is "
"not bound in any nonlocal scope, or if there is no nonlocal scope, a :exc:"
"`SyntaxError` is raised."
msgstr ""
"Quando a definição de uma função ou classe está aninhada (encerrada) dentro "
"das definições de outras funções, os seus âmbitos não locais são os âmbitos "
"locais das funções envolventes. A instrução :keyword:`nonlocal` faz com que "
"os identificadores listados se refiram a nomes previamente ligados em "
"âmbitos não locais. Permite que o código encapsulado religue tais "
"identificadores não locais. Se um nome estiver ligado em mais do que um "
"âmbito não local, é usada a ligação mais próxima. Se um nome não estiver "
"ligado em nenhum âmbito não local, ou se não existir nenhum âmbito não "
"local, é levantada uma exceção :exc:`SyntaxError`."

msgid ""
"The :keyword:`nonlocal` statement applies to the entire scope of a function "
"or class body. A :exc:`SyntaxError` is raised if a variable is used or "
"assigned to prior to its nonlocal declaration in the scope."
msgstr ""
"A instrução :keyword:`nonlocal` aplica-se a todo o âmbito de um corpo de "
"função ou classe. Uma exceção :exc:`SyntaxError` é levantada se uma variável "
"for usada ou atribuída antes da sua declaração *nonlocal* no âmbito."

msgid ":pep:`3104` - Access to Names in Outer Scopes"
msgstr ":pep:`3104` - Acesso a Nomes em Âmbitos Externos"

msgid "The specification for the :keyword:`nonlocal` statement."
msgstr "A especificação para a instrução :keyword:`nonlocal`."

msgid ""
"**Programmer's note:** :keyword:`nonlocal` is a directive to the parser and "
"applies only to code parsed along with it.  See the note for the :keyword:"
"`global` statement."
msgstr ""
"**Nota para programadores:** :keyword:`nonlocal` é uma diretiva para o "
"*parser* e aplica-se apenas ao código analisado juntamente com ela. Consulte "
"a nota para a instrução :keyword:`global`."

msgid "The :keyword:`!type` statement"
msgstr "A instrução :keyword:`!type`"

msgid ""
"The :keyword:`!type` statement declares a type alias, which is an instance "
"of :class:`typing.TypeAliasType`."
msgstr ""
"A instrução :keyword:`!type` declara um alias de tipo, que é uma instância "
"de :class:`typing.TypeAliasType`."

msgid "For example, the following statement creates a type alias::"
msgstr "Por exemplo, a seguinte instrução cria um *alias* de tipo::"

msgid "type Point = tuple[float, float]"
msgstr "type Point = tuple[float, float]"

msgid "This code is roughly equivalent to::"
msgstr "Este código é aproximadamente equivalente a::"

msgid ""
"annotation-def VALUE_OF_Point():\n"
"    return tuple[float, float]\n"
"Point = typing.TypeAliasType(\"Point\", VALUE_OF_Point())"
msgstr ""
"annotation-def VALUE_OF_Point():\n"
"    return tuple[float, float]\n"
"Point = typing.TypeAliasType(\"Point\", VALUE_OF_Point())"

msgid ""
"``annotation-def`` indicates an :ref:`annotation scope <annotation-scopes>`, "
"which behaves mostly like a function, but with several small differences."
msgstr ""
"``annotation-def`` indica um :ref:`âmbitos de anotação <annotation-scopes>`, "
"que se comporta maioritariamente como uma função, mas com algumas pequenas "
"diferenças."

msgid ""
"The value of the type alias is evaluated in the annotation scope. It is not "
"evaluated when the type alias is created, but only when the value is "
"accessed through the type alias's :attr:`!__value__` attribute (see :ref:"
"`lazy-evaluation`). This allows the type alias to refer to names that are "
"not yet defined."
msgstr ""
"O valor do *alias* de tipo é avaliado no âmbito de anotação. Não é avaliado "
"quando o *alias* de tipo é criado, mas apenas quando o valor é acedido "
"através do atributo :attr:`!__value__` do *alias* de tipo (consulte :ref:"
"`lazy-evaluation`). Isto permite que o *alias* de tipo se refira a nomes que "
"ainda não estão definidos."

msgid ""
"Type aliases may be made generic by adding a :ref:`type parameter list <type-"
"params>` after the name. See :ref:`generic-type-aliases` for more."
msgstr ""
"Os *aliases* de tipo podem ser tornados genéricos adicionando uma :ref:"
"`lista de parâmetros de tipo <type-params>` após o nome. Consulte :ref:"
"`generic-type-aliases` para mais informações."

msgid ":keyword:`!type` is a :ref:`soft keyword <soft-keywords>`."
msgstr ":keyword:`!type` é uma :ref:`palavra-chave flexível <soft-keywords>`."

msgid ":pep:`695` - Type Parameter Syntax"
msgstr ":pep:`695` - Sintaxe de Parâmetros de Tipo"

msgid ""
"Introduced the :keyword:`!type` statement and syntax for generic classes and "
"functions."
msgstr ""
"Introduziu a instrução :keyword:`!type` e a sintaxe para classes e funções "
"genéricas."

msgid "simple"
msgstr "simples"

msgid "statement"
msgstr "instrução"

msgid "expression"
msgstr "expressão"

msgid "list"
msgstr "lista"

msgid "built-in function"
msgstr "função integrada"

msgid "repr"
msgstr "repr"

msgid "object"
msgstr "objeto"

msgid "None"
msgstr "None"

msgid "string"
msgstr "string"

msgid "conversion"
msgstr "conversão"

msgid "output"
msgstr "saída"

msgid "standard"
msgstr "padrão"

msgid "writing"
msgstr "escrita"

msgid "values"
msgstr "valores"

msgid "procedure"
msgstr "procedimento"

msgid "call"
msgstr "chamada"

msgid "= (equals)"
msgstr "= (igual)"

msgid "assignment statement"
msgstr "instrução de atribuição"

msgid "assignment"
msgstr "atribuição"

msgid "binding"
msgstr "ligação"

msgid "name"
msgstr "nome"

msgid "rebinding"
msgstr "religação"

msgid "mutable"
msgstr "mutável"

msgid "attribute"
msgstr "atributo"

msgid "target"
msgstr "alvo"

msgid ", (comma)"
msgstr ", (vírgula)"

msgid "in target list"
msgstr "na lista de alvos"

msgid "* (asterisk)"
msgstr "* (asterisco)"

msgid "in assignment target list"
msgstr "na lista de alvos de atribuição"

msgid "[] (square brackets)"
msgstr "[] (parênteses retos)"

msgid "() (parentheses)"
msgstr "() (parênteses)"

msgid "destructor"
msgstr "destrutor"

msgid "subscription"
msgstr "subscrição"

msgid "sequence"
msgstr "sequência"

msgid "mapping"
msgstr "mapeamento"

msgid "dictionary"
msgstr "dicionário"

msgid "slicing"
msgstr "fatiamento"

msgid "augmented"
msgstr "aumentada"

msgid "assignment, augmented"
msgstr "atribuição aumentada"

msgid "+="
msgstr "+="

msgid "augmented assignment"
msgstr "atribuição aumentada"

msgid "-="
msgstr "-="

msgid "*="
msgstr "*="

msgid "/="
msgstr "/="

msgid "%="
msgstr "%="

msgid "&="
msgstr "&="

msgid "^="
msgstr "^="

msgid "|="
msgstr "|="

msgid "**="
msgstr "**="

msgid "//="
msgstr "//="

msgid ">>="
msgstr ">>="

msgid "<<="
msgstr "<<="

msgid "annotated"
msgstr "anotada"

msgid "assignment, annotated"
msgstr "atribuição anotada"

msgid ": (colon)"
msgstr ": (dois pontos)"

msgid "annotated variable"
msgstr "variável anotada"

msgid "assert"
msgstr "assert"

msgid "debugging"
msgstr "depuração"

msgid "assertions"
msgstr "afirmações"

msgid "expression list"
msgstr "lista de expressões"

msgid "__debug__"
msgstr "__debug__"

msgid "exception"
msgstr "exceção"

msgid "AssertionError"
msgstr "AssertionError"

msgid "pass"
msgstr "pass"

msgid "null"
msgstr "nula"

msgid "operation"
msgstr "operação"

msgid "del"
msgstr "del"

msgid "deletion"
msgstr "eliminação"

msgid "global"
msgstr "global"

msgid "unbinding"
msgstr "desligação"

msgid "return"
msgstr "return"

msgid "function"
msgstr "função"

msgid "definition"
msgstr "definição"

msgid "class"
msgstr "classe"

msgid "keyword"
msgstr "palavra-chave"

msgid "finally"
msgstr "finally"

msgid "yield"
msgstr "yield"

msgid "generator"
msgstr "gerador"

msgid "iterator"
msgstr "iterador"

msgid "StopIteration"
msgstr "StopIteration"

msgid "raise"
msgstr "raise"

msgid "raising"
msgstr "levantamento"

msgid "__traceback__ (exception attribute)"
msgstr "__traceback__ (atributo de exceção)"

msgid "traceback"
msgstr "traceback"

msgid "chaining"
msgstr "encadeamento"

msgid "__cause__ (exception attribute)"
msgstr "__cause__ (atributo de exceção)"

msgid "__context__ (exception attribute)"
msgstr "__context__ (atributo de exceção)"

msgid "break"
msgstr "break"

msgid "for"
msgstr "for"

msgid "while"
msgstr "while"

msgid "loop"
msgstr "ciclo"

msgid "else"
msgstr "else"

msgid "loop control"
msgstr "controlo de ciclo"

msgid "continue"
msgstr "continue"

msgid "import"
msgstr "import"

msgid "module"
msgstr "módulo"

msgid "importing"
msgstr "importação"

msgid "from"
msgstr "from"

msgid "as"
msgstr "as"

msgid "ImportError"
msgstr "ImportError"

msgid "import statement"
msgstr "instrução de importação"

msgid "__all__ (optional module attribute)"
msgstr "__all__ (atributo opcional de módulo)"

msgid "relative"
msgstr "relativa"

msgid "future"
msgstr "future"

msgid "__future__"
msgstr "__future__"

msgid "future statement"
msgstr "instrução *future*"

msgid "identifier list"
msgstr "lista de identificadores"

msgid "exec"
msgstr "exec"

msgid "eval"
msgstr "eval"

msgid "compile"
msgstr "compile"

msgid "nonlocal"
msgstr "nonlocal"

msgid "type"
msgstr "tipo"
